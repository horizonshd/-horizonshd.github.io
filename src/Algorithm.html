

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Algorithm &mdash; Cheatsheet 1.0.0 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="Vocabulary" href="Vocabulary.html" />
    <link rel="prev" title="nullsoft scriptable install system 3.0.4" href="NSIS.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Cheatsheet
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="reStructuresText.html">reStructuresText</a></li>
<li class="toctree-l1"><a class="reference internal" href="sphinx.html">sphinx</a></li>
<li class="toctree-l1"><a class="reference internal" href="Encoding.html">Charset and Encoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="Graphviz.html">Graphviz - Graph Visualization Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="git.html">git</a></li>
<li class="toctree-l1"><a class="reference internal" href="CMake.html">CMake</a></li>
<li class="toctree-l1"><a class="reference internal" href="C%2B%2B.html">C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="DTD.html">DTD</a></li>
<li class="toctree-l1"><a class="reference internal" href="XSD.html">XSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="WSDL.html">WSDL</a></li>
<li class="toctree-l1"><a class="reference internal" href="dotnet.html">dotnet</a></li>
<li class="toctree-l1"><a class="reference internal" href="cmd.html">cmd</a></li>
<li class="toctree-l1"><a class="reference internal" href="SSH.html">SSH</a></li>
<li class="toctree-l1"><a class="reference internal" href="Python.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="WindowsTerminal.html">Windows Terminal</a></li>
<li class="toctree-l1"><a class="reference internal" href="manim.html">manim</a></li>
<li class="toctree-l1"><a class="reference internal" href="NSIS.html">nullsoft scriptable install system 3.0.4</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Algorithm</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">基础</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">排序</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">冒泡排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">选择排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">插入排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">快速排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">堆排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">归并排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">希尔排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">计数排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">桶排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">基数排序</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id13">查找</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id14">顺序查找</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">二分查找</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">插值查找</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">二叉树查找</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id18">拓展</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id19">Graph coloring</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">Knight’s tour</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">Minimax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">Rat maze</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">Hamming distance</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id24">进阶</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id25">Wave Function Collapse - 波函数坍缩</a></li>
<li class="toctree-l3"><a class="reference internal" href="#merkle-tree">Merkle Tree - 默克尔树</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Vocabulary.html">Vocabulary</a></li>
<li class="toctree-l1"><a class="reference internal" href="ECFDeploy.html">ECF AutoDeploy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Lua.html">Lua</a></li>
<li class="toctree-l1"><a class="reference internal" href="LaTeX.html">LaTeX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ubuntu.html">Ubuntu</a></li>
<li class="toctree-l1"><a class="reference internal" href="MEF.html">MEF in .NET Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="EMail.html">Relative Concepts of EMail</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Cheatsheet</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Algorithm</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/src/Algorithm.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="algorithm">
<h1>Algorithm<a class="headerlink" href="#algorithm" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>基础<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<div class="section" id="id2">
<h3>排序<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<div class="section" id="id3">
<h4>冒泡排序<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>冒泡排序是在给定序列中将无序区间的数据通过不断交换将目标（无序区间的最小
或最大）数据移至有序区间。</p>
</div></blockquote>
<p>特点：</p>
<blockquote>
<div><ul class="simple">
<li><p>{无序区，有序区}</p></li>
</ul>
</div></blockquote>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>在给定序列 <em>Sn</em> 中，从第一个元素开始两两比较（最大或最小）交换数据，
最后一个元素变成有序的（最大或最小）；</p></li>
<li><p>再对无序的子序列 <em>Sn-1</em> 进行步骤 1 操作，直至全部数据都为有序的。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id26">
<div class="code-block-caption"><span class="caption-text">BubbleSort.cpp</span><a class="headerlink" href="#id26" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">aIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">BubbleSort</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">BubbleSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Compare &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; times.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<p>可以做如下优化，当左侧区间已经有序时不再进行无效的遍历：</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">BubbleSort</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="hll">    <span class="kt">bool</span> <span class="n">ordered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="hll">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ordered</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span>    <span class="p">{</span>
<span class="hll">        <span class="n">ordered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>
<span class="hll">                <span class="n">ordered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span>                <span class="n">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</div>
<div class="section" id="id4">
<h4>选择排序<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>选择排序是在给定序列中将无序区间的数据中选择最小（或最大）放到有序区，直
到数据全部有序。</p>
</div></blockquote>
<p>特点：</p>
<blockquote>
<div><ul class="simple">
<li><p>{有序区，无序区}</p></li>
<li><p>比较多，交换少</p></li>
</ul>
</div></blockquote>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>在给定序列 <em>Sn</em> 中，选择最小（或最大）的数据放到有序区末尾；</p></li>
<li><p>再对无序的子序列 <em>Sn-1</em> 进行步骤 1 操作，直至全部数据都为有序的。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id27">
<div class="code-block-caption"><span class="caption-text">SelectionSort.cpp</span><a class="headerlink" href="#id27" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">aIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">SelectionSort</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">minIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">minIndex</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">minIndex</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">minIndex</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">minIndex</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">SelectionSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Compare &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; times.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id5">
<h4>插入排序<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>插入排序是在给定序列中将无序区间的第一个数据插入到有序区的合适位置，直到
全部数据有序。</p>
</div></blockquote>
<p>特点：</p>
<blockquote>
<div><ul class="simple">
<li><p>{有序区，无序区}</p></li>
<li><p>比较多，交换少</p></li>
</ul>
</div></blockquote>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>在给定序列 <em>Sn</em> 中，选择最小（或最大）的数据放到有序区的合适位置；</p></li>
<li><p>再对无序的子序列 <em>Sn-1</em> 进行步骤 1 操作，直至全部数据都为有序的。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id28">
<div class="code-block-caption"><span class="caption-text">InsertSort.cpp</span><a class="headerlink" href="#id28" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">aIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">InsertSort</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">InsertSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Compare &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; times.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id6">
<h4>快速排序<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>快速排序是在给定的序列中随机选择一个基数，然后将该序列中小于(或小于等于)
这个基数的数据放到该基数的左测，将大于等于（或大于）这个基数的数据放到该
基数的右侧，然后再分别对左右两侧的数据做同样的操作，直至待排序区间的数据
只有一个为止。</p>
</div></blockquote>
<p>特点：</p>
<blockquote>
<div><ul class="simple">
<li><p>{小数，基数，大数}</p></li>
</ul>
</div></blockquote>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>在给定序列  <em>s</em> 中将第一个数作为本次处理的基数 <em>n</em> ；</p></li>
<li><p>将 <em>s</em> 中小于 <em>n</em> 的数据放到该基数的左侧 <em>sl</em> ，将大于等于 <em>n</em> 的
数据放到该基数的右侧 <em>sr</em> ；</p></li>
<li><p>分别对 <em>sl</em> 和 <em>sr</em> 两个子序列的数据进行步骤 1 2 的操作，直至某次序
列中的数据只有一个为止。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id29">
<div class="code-block-caption"><span class="caption-text">QuickSort.cpp</span><a class="headerlink" href="#id29" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">aIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">QuickSort</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">endIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">startIndex</span> <span class="o">&lt;</span> <span class="n">endIndex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">baseIndex</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">baseValue</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">startIndex</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">endIndex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">baseValue</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 将 [baseIndex, i) 的数据右移一个索引</span>
                <span class="c1">// 将移动前的 array[i] 移到 baseIndex</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">baseIndex</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">baseIndex</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">count</span> <span class="o">+=</span> <span class="n">QuickSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">baseIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">QuickSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">baseIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">QuickSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Compare &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; times.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id7">
<h4>堆排序<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>堆排序是把给定序列的数据以二叉树的形式来处理，存储在数组中，每个节点 <cite>i</cite>
的子节点为 <cite>2i+1</cite> 和 <cite>2i+2</cite> ， 父节点为 <cite>(i-1)/2</cite> 。</p>
<p>如果整棵二叉树中每个父节点的值都大于其（一个或两个）子节点的值，则是 <code class="docutils literal notranslate"><span class="pre">最大堆</span></code> ；
如果每个父节点的值都小于其（一个或两个）子节点的值，则是 <code class="docutils literal notranslate"><span class="pre">最小堆</span></code> 。</p>
<p>排序过程则是先将给定序列的数据处理成最大堆（或最小堆），将堆顶元素（值最大或最小）
与最后一个无序的节点交换，有序区得到扩大。然后再对无序区中的序列做最大堆
处理，交换堆顶元素和无序区最后一个元素。不断迭代，直至所有数据均有序。</p>
</div></blockquote>
<p>特点：</p>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>从最后一个父子节点开始做最大堆处理，一直到对第一个父子节点完成最大堆
的处理，此时整个序列中的数据已经成为最大堆的状态；</p></li>
<li><p>交换堆顶元素和最后一个元素，交换后最后一个元素成为有序状态；</p></li>
<li><p>对第一个父子节点和无序区中的其他数据做最大堆调整；</p></li>
<li><p>重复步骤 2 和 3，直至无序区元素的数量只有一个为止。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id30">
<div class="code-block-caption"><span class="caption-text">HeapSort.cpp</span><a class="headerlink" href="#id30" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">aIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">MaxHeapify</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">dad</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">son</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">son</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">son</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">son</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">son</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="o">++</span><span class="n">son</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">dad</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="p">[</span><span class="n">son</span><span class="p">])</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dad</span><span class="p">,</span> <span class="n">son</span><span class="p">);</span>
            <span class="n">dad</span> <span class="o">=</span> <span class="n">son</span><span class="p">;</span>
            <span class="n">son</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">son</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">HeapSort</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ******************</span>
    <span class="c1">//</span>
    <span class="c1">// 建立最大堆</span>
    <span class="c1">//</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">MaxHeapify</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ******************</span>
    <span class="c1">//</span>
    <span class="c1">// 堆排序（最大堆调整）</span>
    <span class="c1">//</span>
    <span class="n">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">MaxHeapify</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">100</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span> <span class="p">};</span>

    <span class="n">HeapSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id8">
<h4>归并排序<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>归并排序是将给定序列分成两部分，以递归的方式分别将两部分数据排好序，然后
从这两部分数据的头部逐一比较将其放至最终的输出数据中。</p>
</div></blockquote>
<p>特点：</p>
<blockquote>
<div><ul class="simple">
<li><p>需要额外的空间存储过程中的已排序数据</p></li>
</ul>
</div></blockquote>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>将给定序列  <em>s</em> 分成两段 <em>sl</em> 和 <em>sr</em> ；</p></li>
<li><p>将子序列 <em>sl</em> 和 <em>sr</em> 按步骤 1 递归操作，直至子序列中只有一个数据
（默认为已排序）；</p></li>
<li><p>对通过递归操作已排好序的两部分子序列 <em>sl</em> 和 <em>sr</em> 进行合并。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id31">
<div class="code-block-caption"><span class="caption-text">MergeSort.cpp</span><a class="headerlink" href="#id31" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">aIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">MergeSort</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
    <span class="p">{</span>
<span class="hll">        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
</span>        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">start1</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">end1</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">start2</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">end2</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">MergeSort</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start1</span><span class="p">,</span> <span class="n">end1</span><span class="p">);</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">MergeSort</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start2</span><span class="p">,</span> <span class="n">end2</span><span class="p">);</span>

<span class="hll">        <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span>        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">start1</span> <span class="o">&lt;=</span> <span class="n">end1</span> <span class="o">&amp;&amp;</span> <span class="n">start2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">start1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">start2</span><span class="p">]</span> <span class="o">?</span> <span class="n">array</span><span class="p">[</span><span class="n">start1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">array</span><span class="p">[</span><span class="n">start2</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">start1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">start1</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">start2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">start2</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>

<span class="hll">        <span class="n">memcpy</span><span class="p">(</span><span class="n">array</span> <span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
</span>        <span class="k">delete</span><span class="p">[]</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">MergeSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Compare &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; times.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id9">
<h4>希尔排序<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>希尔排序主要是通过将给定序列中的数据按照一定的步进 <cite>step</cite> 进行分组再单独
对每个组内的元素进行排序（通常使用 <a class="reference internal" href="#id5"><span class="std std-ref">插入排序</span></a> ），
使每个组内的元素各自有序；再通过不断减小 <cite>step</cite> 继续对重新分组后的组内元
素进行排序使其组内的元素有序；最终当 <cite>step</cite> 等于 <cite>1</cite> 时，整个序列中的数
据将成为一个组，对其中的元素排序后将使整个序列中的元素达到有序的状态。</p>
</div></blockquote>
<p>特点：</p>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>设置初始步进 <cite>int step = N /2</cite> ，其中 <cite>N</cite> 为给定序列元素的数量；</p></li>
<li><p>将序列中间隔为 <cite>step</cite> 的元素进行排序，通常使用 <a class="reference internal" href="#id5"><span class="std std-ref">插入排序</span></a> ；</p></li>
<li><p>调整 <cite>step = step /2</cite> ，重复步骤 2 ；</p></li>
<li><p>当 <cite>step</cite> 的值为 <cite>1</cite> 时，再进行一次排序操作后所有数据均成为有序的。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id32">
<div class="code-block-caption"><span class="caption-text">ShellSort.cpp</span><a class="headerlink" href="#id32" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">aIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">ShellSort</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">step</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">step</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">++</span><span class="n">count</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

            <span class="c1">// 每个分组内部进行插入排序</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">step</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">step</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="n">step</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>

    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ShellSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Compare &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; times.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id10">
<h4>计数排序<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>计数排序主要是通过统计给定数据（ int 型 ）中每一个数字出现的次数，然后再
根据这个统计信息按照一定方式将这些数据变成有序状态。</p>
</div></blockquote>
<p>特点：</p>
<blockquote>
<div><ul class="simple">
<li><p>需要额外的空间开销存储辅助数据</p></li>
<li><p>出于算法的原因只能对 int 型的数据进行排序</p></li>
</ul>
</div></blockquote>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>找出待排序的数组中最大（ <cite>maxValue</cite> ）和最小（ <cite>minValue</cite> ）的元素；</p></li>
<li><p>统计数组中每个值为 <cite>value</cite> 的元素出现的次数，存入数组 <cite>countArray</cite>
的第 <cite>value - minValue</cite> 项；</p></li>
<li><p>对所有的计数累加（从 <cite>countArray</cite> 中的第一个元素开始，每一项和前一项相加）；</p></li>
<li><p>反向填充目标数组 <cite>sorted</cite> 中，稍微有些复杂。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id33">
<div class="code-block-caption"><span class="caption-text">CountSort.cpp</span><a class="headerlink" href="#id33" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">CountSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">minValue</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">maxValue</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minValue</span><span class="p">)</span>
            <span class="n">minValue</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxValue</span><span class="p">)</span>
            <span class="n">maxValue</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// *****************</span>
    <span class="c1">// 1. 对数据进行统计</span>
    <span class="c1">//</span>
    <span class="kt">int</span> <span class="n">tempSize</span> <span class="o">=</span> <span class="n">maxValue</span> <span class="o">-</span> <span class="n">minValue</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">countArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">tempSize</span><span class="p">]();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">countArray</span><span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">minValue</span><span class="p">]</span> <span class="o">++</span><span class="p">;</span> <span class="c1">// 这里就要求 array 数组必须是 int 型时索引 array[i] - minValue 才是合法的</span>
    <span class="p">}</span>

    <span class="c1">// *****************</span>
    <span class="c1">// 2. 对数据排序</span>
    <span class="c1">//</span>
    <span class="c1">//// 方式一</span>
    <span class="c1">//int index = 0;</span>
    <span class="c1">//for (int i = 0; i &lt; tempSize; ++i)</span>
    <span class="c1">//{</span>
    <span class="c1">//    while (countArray[i]--)</span>
    <span class="c1">//    {</span>
    <span class="c1">//        array[index++] = i + minValue;</span>
    <span class="c1">//    }</span>
    <span class="c1">//}</span>

    <span class="c1">// 方式二</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tempSize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">countArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">countArray</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 使 countArray[i] 记录待排序数组中第 i 大（0 based）的元素在最终已排序数组中的开始索引</span>
    <span class="p">}</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">sorted</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">N</span><span class="p">]();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 通过数据的至计算出其在待输出有序数组中的索引</span>
        <span class="kt">int</span> <span class="n">targetValue</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">targetIndex</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">minValue</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">finalIndex</span> <span class="o">=</span> <span class="o">--</span><span class="n">countArray</span><span class="p">[</span><span class="n">targetIndex</span><span class="p">];</span>

        <span class="n">sorted</span><span class="p">[</span><span class="n">finalIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">targetValue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">sorted</span><span class="p">,</span> <span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

    <span class="k">delete</span> <span class="n">countArray</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">sorted</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="n">CountSort</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id11">
<h4>桶排序<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>桶排序将给定序列的数据 <cite>Sn</cite> 按照一定的规则分散到 <cite>BUCKET_NUM</cite> 个桶中，
数据需要按照 <em>一定的顺序</em> 入桶，全部数据入桶后再将数据从桶中倒出（两两一
起）排序。</p>
</div></blockquote>
<p>特点：</p>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>可以使用 <cite>std::vector</cite> 来实现桶的逻辑；</p></li>
<li><p>将给定序列中的数据按照一定规则（比如可以将序列中元素的索引值对桶的数
量取模确定元素放到哪个桶中）分散到各个桶中，入桶时就可以做排序；</p></li>
<li><p>再将每两个桶中的数据取出并排序，直至所有桶中的数据取完即可。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id34">
<div class="code-block-caption"><span class="caption-text">BucketSort.cpp</span><a class="headerlink" href="#id34" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">aIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="n">bIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ListNode</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="nf">ListNode</span><span class="p">()</span> <span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">explicit</span> <span class="nf">ListNode</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">)</span> <span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">explicit</span> <span class="nf">ListNode</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">)</span> <span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">Insert</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">listNodes</span><span class="p">,</span> <span class="n">T</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">dummyNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">listNodes</span><span class="p">);</span>

    <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">prePtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummyNode</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">curPtr</span> <span class="o">=</span> <span class="n">listNodes</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">curPtr</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">curPtr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">prePtr</span> <span class="o">=</span> <span class="n">curPtr</span><span class="p">;</span>
        <span class="n">curPtr</span> <span class="o">=</span> <span class="n">curPtr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">prePtr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">curPtr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">dummyNode</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 要求两个链表均已排好序</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;</span>
<span class="c1">/// &lt;param name=&quot;listA&quot;&gt;&lt;/param&gt;</span>
<span class="c1">/// &lt;param name=&quot;listB&quot;&gt;&lt;/param&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">Merge</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">listA</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">listB</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">dummyNode</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">dummyNodePtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummyNode</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">listA</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">listB</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">listA</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">listB</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dummyNodePtr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">listA</span><span class="p">;</span>
            <span class="n">listA</span> <span class="o">=</span> <span class="n">listA</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">dummyNodePtr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">listB</span><span class="p">;</span>
            <span class="n">listB</span> <span class="o">=</span> <span class="n">listB</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">dummyNodePtr</span> <span class="o">=</span> <span class="n">dummyNodePtr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">listA</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dummyNodePtr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">listA</span><span class="p">;</span>
        <span class="n">listA</span> <span class="o">=</span> <span class="n">listA</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">dummyNodePtr</span> <span class="o">=</span> <span class="n">dummyNodePtr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">listB</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dummyNodePtr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">listB</span><span class="p">;</span>
        <span class="n">listB</span> <span class="o">=</span> <span class="n">listB</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">dummyNodePtr</span> <span class="o">=</span> <span class="n">dummyNodePtr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">dummyNode</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">BucketSort</span><span class="p">(</span><span class="n">T</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">bucketNum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span> <span class="n">buckets</span><span class="p">(</span><span class="n">bucketNum</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">bucketNum</span><span class="p">;</span>
        <span class="n">buckets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="n">Insert</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">buckets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">head</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucketNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">Merge</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">buckets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">BUCKET_NUM</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1">// 可以根据待排序数据的数量进行一定的优化</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>

    <span class="n">BucketSort</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">BUCKET_NUM</span><span class="p">);</span>
    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id12">
<h4>基数排序<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<blockquote>
<div><p>基数排序将给定序列中的数据按照每一位上的数字进行逐一比较（个位、十位…），
基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most
significant digital）。LSD 的排序方式由键值的最右边开始，而MSD则相反，
由键值的最左边开始。</p>
</div></blockquote>
<p>特点：</p>
<blockquote>
<div><ul class="simple">
<li><p>需要与待排序数据一样大的空间来存储过程中的部分排序后的数组。</p></li>
<li><p>需要额外的空间存储统计信息，通常只需进制位的大小即可（比如 10 * sizeof(int) ）。</p></li>
<li><p>只能对 int 类型的数据进行排序。</p></li>
</ul>
</div></blockquote>
<p>思路：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>遍历给定序列 <cite>Sn</cite> 中的数据获取最大值 <cite>max</cite> 并计算 <cite>max</cite> 中的位数 <cite>bits</cite>
（比如 <cite>22</cite> -&gt; 2位，<cite>456</cite> -&gt; 3位）；</p></li>
<li><p>对 <cite>Sn</cite> 中的数据以 LSD 或 MSD 的方式进行 <cite>bits</cite> 次排序。</p></li>
</ol>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id35">
<div class="code-block-caption"><span class="caption-text">RadixSortLSD.cpp</span><a class="headerlink" href="#id35" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">ConterSize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 进制</span>

<span class="kt">int</span> <span class="nf">MaxValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">MaxBit</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">MaxValue</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">max</span> <span class="o">/=</span> <span class="n">ConterSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">++</span><span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">RadixSortLSD</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">MaxBit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

    <span class="kt">int</span><span class="o">*</span> <span class="n">sortedArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]();</span>                        <span class="c1">// 用于存储根据某一进制位排序后的原始数据</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">counterArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">ConterSize</span><span class="p">]();</span>              <span class="c1">// 用于存储根据某一进制位排序后的统计信息</span>

    <span class="kt">int</span> <span class="n">radix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                                          <span class="c1">// 表示个位、十位...</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bits</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>                          <span class="c1">// 从低（右侧）到高位（左侧）遍历排序</span>
    <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">counterArray</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ConterSize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

        <span class="c1">// *************************</span>
        <span class="c1">//</span>
        <span class="c1">// 遍历待排序数据 data 获取统计信息</span>
        <span class="c1">//</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">radix</span> <span class="o">%</span> <span class="n">ConterSize</span><span class="p">;</span>       <span class="c1">// 计算 data[j] 在 radix 对应的进制位上的数字</span>
            <span class="o">++</span><span class="n">counterArray</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ConterSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">counterArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">counterArray</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// *************************</span>
        <span class="c1">//</span>
        <span class="c1">// 遍历待排序数据 data 结合统计信息</span>
        <span class="c1">// 获得本次排序后的数据放到 sortedArray 中</span>
        <span class="c1">//</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">targetValue</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">counterIndex</span> <span class="o">=</span> <span class="n">targetValue</span> <span class="o">/</span> <span class="n">radix</span> <span class="o">%</span> <span class="n">ConterSize</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">targetIndex</span> <span class="o">=</span> <span class="o">--</span><span class="n">counterArray</span><span class="p">[</span><span class="n">counterIndex</span><span class="p">];</span>

            <span class="n">sortedArray</span><span class="p">[</span><span class="n">targetIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">targetValue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sortedArray</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="n">radix</span> <span class="o">*=</span> <span class="n">ConterSize</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">delete</span><span class="p">[]</span> <span class="n">sortedArray</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">counterArray</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>

    <span class="n">RadixSortLSD</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">Print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="id13">
<h3>查找<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<div class="section" id="id14">
<h4>顺序查找<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<p>特点：</p>
<p>思路：</p>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id36">
<div class="code-block-caption"><span class="caption-text">SequentialSearch.cpp</span><a class="headerlink" href="#id36" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">SequentialSearch</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">[],</span> <span class="n">T</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span>  <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">SequentialSearch</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id15">
<h4>二分查找<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<p>特点：</p>
<blockquote>
<div><ul class="simple">
<li><p>要求给出的数据序列是有序的</p></li>
</ul>
</div></blockquote>
<p>思路：</p>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id37">
<div class="code-block-caption"><span class="caption-text">BinarySearch.cpp</span><a class="headerlink" href="#id37" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">[],</span> <span class="n">T</span> <span class="n">targetValue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">lowIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">highIndex</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">lowIndex</span> <span class="o">&lt;=</span> <span class="n">highIndex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">midIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">lowIndex</span> <span class="o">+</span> <span class="n">highIndex</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">==</span> <span class="n">targetValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">midIndex</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">targetValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">highIndex</span> <span class="o">=</span> <span class="n">midIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">lowIndex</span> <span class="o">=</span> <span class="n">midIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span>  <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">BinarySearch</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id16">
<h4>插值查找<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<p>特点：</p>
<blockquote>
<div><ul class="simple">
<li><p>要求给出的数据序列是有序的</p></li>
<li><p>序列中数据的分布是均匀的</p></li>
<li><p>是 <a class="reference internal" href="#id15"><span class="std std-ref">二分查找</span></a> 的扩展</p></li>
</ul>
</div></blockquote>
<p>思路：</p>
<blockquote>
<div><p>1.  整体思路和 <a class="reference internal" href="#id15"><span class="std std-ref">二分查找</span></a> 一样，只是每次计算中间索引
<cite>midIndex</cite> 的时候不再是使用 <cite>(lowIndex + highIndex) / 2</cite> 这样的方式来
计算，而是根据目标值的特点来计算。</p>
</div></blockquote>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id38">
<div class="code-block-caption"><span class="caption-text">InterpolationSearch.cpp</span><a class="headerlink" href="#id38" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">InterpolationSearch</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">[],</span> <span class="n">T</span> <span class="n">targetValue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">lowIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">highIndex</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">lowIndex</span> <span class="o">&lt;=</span> <span class="n">highIndex</span><span class="p">)</span>
    <span class="p">{</span>
<span class="hll">        <span class="kt">int</span> <span class="n">midIndex</span> <span class="o">=</span> <span class="n">lowIndex</span> <span class="o">+</span> <span class="kt">int</span><span class="p">((</span><span class="n">targetValue</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">lowIndex</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">highIndex</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">lowIndex</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">highIndex</span> <span class="o">-</span> <span class="n">lowIndex</span><span class="p">));</span>
</span>
<span class="hll">        <span class="k">if</span> <span class="p">(</span><span class="n">midIndex</span><span class="o">&lt;</span><span class="n">lowIndex</span> <span class="o">||</span> <span class="n">midIndex</span><span class="o">&gt;</span> <span class="n">highIndex</span><span class="p">)</span>
</span><span class="hll">        <span class="p">{</span>
</span><span class="hll">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="hll">        <span class="p">}</span>
</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">==</span> <span class="n">targetValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">midIndex</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">targetValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">highIndex</span> <span class="o">=</span> <span class="n">midIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">lowIndex</span> <span class="o">=</span> <span class="n">midIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span>  <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">InterpolationSearch</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id17">
<h4>二叉树查找<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h4>
<p>说明：</p>
<p>特点：</p>
<p>思路：</p>
<p>实现：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id39">
<div class="code-block-caption"><span class="caption-text">BinaryTreeSearch.cpp</span><a class="headerlink" href="#id39" title="永久链接至代码">¶</a></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Allocating &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; bytes!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">object</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Freeing &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; bytes!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BinaryTreeNode</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">Data</span><span class="p">;</span>
    <span class="n">BinaryTreeNode</span><span class="o">*</span> <span class="n">LChild</span><span class="p">;</span>
    <span class="n">BinaryTreeNode</span><span class="o">*</span> <span class="n">RChild</span><span class="p">;</span>

    <span class="n">BinaryTreeNode</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">Data</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">LChild</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">RChild</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">BinaryTreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">Data</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">LChild</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">RChild</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">InsertNode</span><span class="p">(</span><span class="n">BinaryTreeNode</span><span class="o">**</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">BinaryTreeNode</span><span class="o">**</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;</span> <span class="p">((</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RChild</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">LChild</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">BinaryTreeNode</span><span class="o">*</span> <span class="nf">CreateBinatyTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="n">BinaryTreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">InsertNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">FreeBinaryTree</span><span class="p">(</span><span class="n">BinaryTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FreeBinaryTree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">LChild</span><span class="p">);</span>
        <span class="n">FreeBinaryTree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">RChild</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">BinaryTreeSearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetValue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">BinaryTreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="n">CreateBinatyTree</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">BinaryTreeNode</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">Data</span> <span class="o">==</span> <span class="n">targetValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">Data</span> <span class="o">&gt;</span> <span class="n">targetValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">LChild</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">RChild</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FreeBinaryTree</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span> <span class="p">};</span>
    <span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="n">BinaryTreeSearch</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">7</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Not found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="id18">
<h3>拓展<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<div class="section" id="id19">
<h4><a class="reference external" href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/graph_coloring.cpp">Graph coloring</a><a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h4>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file</span>
<span class="cm"> * @brief prints the assigned colors</span>
<span class="cm"> * using [Graph Coloring](https://en.wikipedia.org/wiki/Graph_coloring) algorithm</span>
<span class="cm"> *</span>
<span class="cm"> * @details</span>
<span class="cm"> * In graph theory, graph coloring is a special case of graph labeling;</span>
<span class="cm"> * it is an assignment of labels traditionally called &quot;colors&quot; to elements of a graph subject to certain constraints.</span>
<span class="cm"> * In its simplest form, it is a way of coloring the vertices of a graph such that no two adjacent vertices are of the same color;</span>
<span class="cm"> * this is called a vertex coloring. Similarly, an edge coloring assigns</span>
<span class="cm"> * a color to each edge so that no two adjacent edges are of the same color,</span>
<span class="cm"> * and a face coloring of a planar graph assigns a color to each face or</span>
<span class="cm"> * region so that no two faces that share a boundary have the same color.</span>
<span class="cm"> *</span>
<span class="cm"> * @author [Anup Kumar Panwar](https://github.com/AnupKumarPanwar)</span>
<span class="cm"> * @author [David Leal](https://github.com/Panquesito7)</span>
<span class="cm"> */</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

 <span class="cm">/**</span>
<span class="cm">  * @namespace</span>
<span class="cm">  * @brief Backtracking algorithms</span>
<span class="cm">  */</span>
<span class="k">namespace</span> <span class="n">backtracking</span> <span class="p">{</span>
    <span class="cm">/** A utility function to print solution</span>
<span class="cm">     * @tparam V number of vertices in the graph</span>
<span class="cm">     * @param color array of colors assigned to the nodes</span>
<span class="cm">     */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">printSolution</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Following are the assigned colors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">col</span> <span class="p">:</span> <span class="n">color</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">col</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/** A utility function to check if the current color assignment is safe for</span>
<span class="cm">     * vertex v</span>
<span class="cm">     * @tparam V number of vertices in the graph</span>
<span class="cm">     * @param v index of graph vertex to check</span>
<span class="cm">     * @param graph matrix of graph nonnectivity</span>
<span class="cm">     * @param color vector of colors assigned to the graph nodes/vertices</span>
<span class="cm">     * @param c color value to check for the node `v`</span>
<span class="cm">     * @returns `true` if the color is safe to be assigned to the node</span>
<span class="cm">     * @returns `false` if the color is not safe to be assigned to the node</span>
<span class="cm">     */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">isSafe</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/** A recursive utility function to solve m coloring problem</span>
<span class="cm">     * @tparam V number of vertices in the graph</span>
<span class="cm">     * @param graph matrix of graph nonnectivity</span>
<span class="cm">     * @param m number of colors</span>
<span class="cm">     * @param [in,out] color description // used in,out to notify in documentation</span>
<span class="cm">     * that this parameter gets modified by the function</span>
<span class="cm">     * @param v index of graph vertex to check</span>
<span class="cm">     */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">graphColoring</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// base case:</span>
        <span class="c1">// If all vertices are assigned a color then return true</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">backtracking</span><span class="o">::</span><span class="n">printSolution</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Consider this vertex v and try different colors</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Check if assignment of color c to v is fine</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">backtracking</span><span class="o">::</span><span class="n">isSafe</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

                <span class="c1">// recur to assign colors to rest of the vertices</span>
                <span class="n">backtracking</span><span class="o">::</span><span class="n">graphColoring</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

                <span class="c1">// If assigning color c doesn&#39;t lead to a solution then remove it</span>
                <span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace backtracking</span>

<span class="cm">/**</span>
<span class="cm"> * Main function</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Create following graph and test whether it is 3 colorable</span>
    <span class="c1">// (3)---(2)</span>
    <span class="c1">// |   / |</span>
    <span class="c1">// |  /  |</span>
    <span class="c1">// | /   |</span>
    <span class="c1">// (0)---(1)</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">V</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>  <span class="c1">// number of vertices in the graph</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}),</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}),</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}),</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">})</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// Number of colors</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">{};</span>

    <span class="n">backtracking</span><span class="o">::</span><span class="n">graphColoring</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Following</span> <span class="n">are</span> <span class="n">the</span> <span class="n">assigned</span> <span class="n">colors</span>
<span class="mi">1232</span>
<span class="n">Following</span> <span class="n">are</span> <span class="n">the</span> <span class="n">assigned</span> <span class="n">colors</span>
<span class="mi">1323</span>
<span class="n">Following</span> <span class="n">are</span> <span class="n">the</span> <span class="n">assigned</span> <span class="n">colors</span>
<span class="mi">2131</span>
<span class="n">Following</span> <span class="n">are</span> <span class="n">the</span> <span class="n">assigned</span> <span class="n">colors</span>
<span class="mi">2313</span>
<span class="n">Following</span> <span class="n">are</span> <span class="n">the</span> <span class="n">assigned</span> <span class="n">colors</span>
<span class="mi">3121</span>
<span class="n">Following</span> <span class="n">are</span> <span class="n">the</span> <span class="n">assigned</span> <span class="n">colors</span>
<span class="mi">3212</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h4><a class="reference external" href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/knight_tour.cpp">Knight’s tour</a><a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h4>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file</span>
<span class="cm"> * @brief [Knight&#39;s tour](https://en.wikipedia.org/wiki/Knight%27s_tour) algorithm</span>
<span class="cm"> *</span>
<span class="cm"> * @details</span>
<span class="cm"> * A knight&#39;s tour is a sequence of moves of a knight on a chessboard</span>
<span class="cm"> * such that the knight visits every square only once. If the knight</span>
<span class="cm"> * ends on a square that is one knight&#39;s move from the beginning</span>
<span class="cm"> * square (so that it could tour the board again immediately, following</span>
<span class="cm"> * the same path, the tour is closed; otherwise, it is open.</span>
<span class="cm"> *</span>
<span class="cm"> * @author [Nikhil Arora](https://github.com/nikhilarora068)</span>
<span class="cm"> * @author [David Leal](https://github.com/Panquesito7)</span>
<span class="cm"> */</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>
<span class="hll"><span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
</span>
 <span class="cm">/**</span>
<span class="cm">  * @namespace backtracking</span>
<span class="cm">  * @brief Backtracking algorithms</span>
<span class="cm">  */</span>
<span class="k">namespace</span> <span class="n">backtracking</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * A utility function to check if i,j are valid indexes for N*N chessboard</span>
<span class="cm">     * @tparam V number of vertices in array</span>
<span class="cm">     * @param x current index in rows</span>
<span class="cm">     * @param y current index in columns</span>
<span class="cm">     * @param sol matrix where numbers are saved</span>
<span class="cm">     * @returns `true` if ....</span>
<span class="cm">     * @returns `false` if ....</span>
<span class="cm">     */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">issafe</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">sol</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sol</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Knight&#39;s tour algorithm</span>
<span class="cm">     * @tparam V number of vertices in array</span>
<span class="cm">     * @param x current index in rows</span>
<span class="cm">     * @param y current index in columns</span>
<span class="cm">     * @param mov movement to be done</span>
<span class="cm">     * @param sol matrix where numbers are saved</span>
<span class="cm">     * @param xmov next move of knight (x coordinate)</span>
<span class="cm">     * @param ymov next move of knight (y coordinate)</span>
<span class="cm">     * @returns `true` if solution exists</span>
<span class="cm">     * @returns `false` if solution does not exist</span>
<span class="cm">     */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mov</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">sol</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">xmov</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">ymov</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">xnext</span><span class="p">,</span> <span class="n">ynext</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mov</span> <span class="o">==</span> <span class="n">V</span> <span class="o">*</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">xnext</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xmov</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="n">ynext</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">ymov</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">backtracking</span><span class="o">::</span><span class="n">issafe</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xnext</span><span class="p">,</span> <span class="n">ynext</span><span class="p">,</span> <span class="n">sol</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">sol</span><span class="p">[</span><span class="n">xnext</span><span class="p">][</span><span class="n">ynext</span><span class="p">]</span> <span class="o">=</span> <span class="n">mov</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">backtracking</span><span class="o">::</span><span class="n">solve</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xnext</span><span class="p">,</span> <span class="n">ynext</span><span class="p">,</span> <span class="n">mov</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">xmov</span><span class="p">,</span> <span class="n">ymov</span><span class="p">)</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">sol</span><span class="p">[</span><span class="n">xnext</span><span class="p">][</span><span class="n">ynext</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace backtracking</span>

<span class="cm">/**</span>
<span class="cm"> * Main function</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">sol</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">xmov</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">ymov</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

    <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">backtracking</span><span class="o">::</span><span class="n">solve</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">xmov</span><span class="p">,</span> <span class="n">ymov</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error: Solution does not exist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">                <span class="c1">//std::cout &lt;&lt; sol[i][j] &lt;&lt; &quot;  &quot;;</span>
</span><span class="hll">                <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">flags</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">left</span><span class="p">);</span>
</span><span class="hll">                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span>            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span>   <span class="mi">59</span>  <span class="mi">38</span>  <span class="mi">33</span>  <span class="mi">30</span>  <span class="mi">17</span>  <span class="mi">8</span>   <span class="mi">63</span>
<span class="mi">37</span>  <span class="mi">34</span>  <span class="mi">31</span>  <span class="mi">60</span>  <span class="mi">9</span>   <span class="mi">62</span>  <span class="mi">29</span>  <span class="mi">16</span>
<span class="mi">58</span>  <span class="mi">1</span>   <span class="mi">36</span>  <span class="mi">39</span>  <span class="mi">32</span>  <span class="mi">27</span>  <span class="mi">18</span>  <span class="mi">7</span>
<span class="mi">35</span>  <span class="mi">48</span>  <span class="mi">41</span>  <span class="mi">26</span>  <span class="mi">61</span>  <span class="mi">10</span>  <span class="mi">15</span>  <span class="mi">28</span>
<span class="mi">42</span>  <span class="mi">57</span>  <span class="mi">2</span>   <span class="mi">49</span>  <span class="mi">40</span>  <span class="mi">23</span>  <span class="mi">6</span>   <span class="mi">19</span>
<span class="mi">47</span>  <span class="mi">50</span>  <span class="mi">45</span>  <span class="mi">54</span>  <span class="mi">25</span>  <span class="mi">20</span>  <span class="mi">11</span>  <span class="mi">14</span>
<span class="mi">56</span>  <span class="mi">43</span>  <span class="mi">52</span>  <span class="mi">3</span>   <span class="mi">22</span>  <span class="mi">13</span>  <span class="mi">24</span>  <span class="mi">5</span>
<span class="mi">51</span>  <span class="mi">46</span>  <span class="mi">55</span>  <span class="mi">44</span>  <span class="mi">53</span>  <span class="mi">4</span>   <span class="mi">21</span>  <span class="mi">12</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h4><a class="reference external" href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/minimax.cpp">Minimax</a><a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h4>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file</span>
<span class="cm"> * @brief returns which is the longest/shortest number</span>
<span class="cm"> * using [minimax](https://en.wikipedia.org/wiki/Minimax) algorithm</span>
<span class="cm"> *</span>
<span class="cm"> * @details</span>
<span class="cm"> * Minimax (sometimes MinMax, MM or saddle point) is a decision rule used in</span>
<span class="cm"> * artificial intelligence, decision theory, game theory, statistics,</span>
<span class="cm"> * and philosophy for minimizing the possible loss for a worst case (maximum loss) scenario.</span>
<span class="cm"> * When dealing with gains, it is referred to as &quot;maximin&quot;—to maximize the minimum gain.</span>
<span class="cm"> * Originally formulated for two-player zero-sum game theory, covering both the cases where players take</span>
<span class="cm"> * alternate moves and those where they make simultaneous moves, it has also been extended to more</span>
<span class="cm"> * complex games and to general decision-making in the presence of uncertainty.</span>
<span class="cm"> *</span>
<span class="cm"> * @author [Gleison Batista](https://github.com/gleisonbs)</span>
<span class="cm"> * @author [David Leal](https://github.com/Panquesito7)</span>
<span class="cm"> */</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>

 <span class="cm">/**</span>
<span class="cm">  * @namespace backtracking</span>
<span class="cm">  * @brief Backtracking algorithms</span>
<span class="cm">  */</span>
<span class="k">namespace</span> <span class="n">backtracking</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * Check which number is the maximum/minimum in the array</span>
<span class="cm">     * @param depth current depth in game tree</span>
<span class="cm">     * @param node_index current index in array</span>
<span class="cm">     * @param is_max if current index is the longest number</span>
<span class="cm">     * @param scores saved numbers in array</span>
<span class="cm">     * @param height maximum height for game tree</span>
<span class="cm">     * @return maximum or minimum number</span>
<span class="cm">     */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">int</span> <span class="n">minimax</span><span class="p">(</span><span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_max</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">scores</span><span class="p">,</span> <span class="kt">double</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">scores</span><span class="p">[</span><span class="n">node_index</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">minimax</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node_index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="o">!</span><span class="n">is_max</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">minimax</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node_index</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">!</span><span class="n">is_max</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">is_max</span> <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace backtracking</span>

<span class="cm">/**</span>
<span class="cm"> * Main function</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="mi">34423</span> <span class="p">};</span>

<span class="hll">    <span class="c1">// max   65 (anser)</span>
</span><span class="hll">    <span class="c1">// min   33             65</span>
</span><span class="hll">    <span class="c1">// max   90      33     65      34423</span>
</span><span class="hll">    <span class="c1">// min   90, 23, 6, 33, 21, 65, 123, 34423</span>
</span>
<span class="hll">    <span class="c1">// min   23 (anser)</span>
</span><span class="hll">    <span class="c1">// max   23             123</span>
</span><span class="hll">    <span class="c1">// min   23      6      21      123</span>
</span><span class="hll">    <span class="c1">// max   90, 23, 6, 33, 21, 65, 123, 34423</span>
</span>
    <span class="kt">double</span> <span class="n">height</span> <span class="o">=</span> <span class="n">log2</span><span class="p">(</span><span class="n">scores</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Optimal value: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">backtracking</span><span class="o">::</span><span class="n">minimax</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Optimal value: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">backtracking</span><span class="o">::</span><span class="n">minimax</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Optimal</span> <span class="n">value</span><span class="p">:</span> <span class="mi">65</span>
<span class="n">Optimal</span> <span class="n">value</span><span class="p">:</span> <span class="mi">23</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h4><a class="reference external" href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/rat_maze.cpp">Rat maze</a><a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h4>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file</span>
<span class="cm"> * @brief Implements [Rat in a</span>
<span class="cm"> * Maze](https://www.codesdope.com/blog/article/backtracking-to-</span>
<span class="cm"> * solve-a-rat-in-a-maze-c-java-pytho/) algorithm</span>
<span class="cm"> *</span>
<span class="cm"> * @details</span>
<span class="cm"> * A Maze is given as N*N binary matrix of blocks where source block is the</span>
<span class="cm"> * upper left most block i.e., maze[0][0] and destination block is lower</span>
<span class="cm"> * rightmost block i.e., maze[N-1][N-1]. A rat starts from source and has to</span>
<span class="cm"> * reach destination. The rat can move only in two directions: forward and down.</span>
<span class="cm"> * In the maze matrix, 0 means the block is dead end and 1 means the block can</span>
<span class="cm"> * be used in the path from source to destination.</span>
<span class="cm"> *</span>
<span class="cm"> * @author [Vaibhav Thakkar](https://github.com/vaithak)</span>
<span class="cm"> * @author [David Leal](https://github.com/Panquesito7)</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>

 <span class="cm">/**</span>
<span class="cm">  * @namespace backtracking</span>
<span class="cm">  * @brief Backtracking algorithms</span>
<span class="cm">  */</span>
<span class="k">namespace</span> <span class="n">backtracking</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * @namespace rat_maze</span>
<span class="cm">     * @brief Functions for [Rat in a</span>
<span class="cm">     * Maze](https://www.codesdope.com/blog/article/backtracking-to-</span>
<span class="cm">     * solve-a-rat-in-a-maze-c-java-pytho/) algorithm</span>
<span class="cm">     */</span>
    <span class="k">namespace</span> <span class="n">rat_maze</span> <span class="p">{</span>
        <span class="cm">/**</span>
<span class="cm">         * @brief Solve rat maze problem</span>
<span class="cm">         * @tparam size number of matrix size</span>
<span class="cm">         * @param currposrow current position in rows</span>
<span class="cm">         * @param currposcol current position in columns</span>
<span class="cm">         * @param maze matrix where numbers are saved</span>
<span class="cm">         * @param soln matrix to problem solution</span>
<span class="cm">         * @returns 0 on end</span>
<span class="cm">         */</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">size</span><span class="o">&gt;</span>
        <span class="kt">bool</span> <span class="n">solveMaze</span><span class="p">(</span><span class="kt">int</span> <span class="n">currposrow</span><span class="p">,</span> <span class="kt">int</span> <span class="n">currposcol</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;&amp;</span> <span class="n">maze</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span> <span class="n">soln</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">currposrow</span> <span class="o">==</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">currposcol</span> <span class="o">==</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">soln</span><span class="p">[</span><span class="n">currposrow</span><span class="p">][</span><span class="n">currposcol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">soln</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">soln</span><span class="p">[</span><span class="n">currposrow</span><span class="p">][</span><span class="n">currposcol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="c1">// if there exist a solution by moving one step ahead in a column</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">currposcol</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">maze</span><span class="p">[</span><span class="n">currposrow</span><span class="p">][</span><span class="n">currposcol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
                    <span class="n">solveMaze</span><span class="p">(</span><span class="n">currposrow</span><span class="p">,</span> <span class="n">currposcol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maze</span><span class="p">,</span> <span class="n">soln</span><span class="p">))</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">// if there exists a solution by moving one step ahead in a row</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">currposrow</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">maze</span><span class="p">[</span><span class="n">currposrow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">currposcol</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
                    <span class="n">solveMaze</span><span class="p">(</span><span class="n">currposrow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">currposcol</span><span class="p">,</span> <span class="n">maze</span><span class="p">,</span> <span class="n">soln</span><span class="p">))</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">// the backtracking part</span>
                <span class="n">soln</span><span class="p">[</span><span class="n">currposrow</span><span class="p">][</span><span class="n">currposcol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>  <span class="c1">// namespace rat_maze</span>
<span class="p">}</span>  <span class="c1">// namespace backtracking</span>

<span class="cm">/**</span>
<span class="cm"> * @brief Test implementations</span>
<span class="cm"> * @returns void</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span> <span class="n">maze</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span> <span class="n">soln</span><span class="p">{};</span>

    <span class="c1">// Backtracking: setup matrix solution to zero</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">soln</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">currposrow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Current position in rows</span>
    <span class="kt">int</span> <span class="n">currposcol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Current position in columns</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">backtracking</span><span class="o">::</span><span class="n">rat_maze</span><span class="o">::</span><span class="n">solveMaze</span><span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">(</span><span class="n">currposrow</span><span class="p">,</span> <span class="n">currposcol</span><span class="p">,</span> <span class="n">maze</span><span class="p">,</span>
        <span class="n">soln</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * @brief Main function</span>
<span class="cm"> * @returns 0 on exit</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">test</span><span class="p">();</span> <span class="c1">// run the tests</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h4><a class="reference external" href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/bit_manipulation/hamming_distance.cpp">Hamming distance</a><a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h4>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file</span>
<span class="cm"> * @brief Returns the [Hamming</span>
<span class="cm"> * distance](https://en.wikipedia.org/wiki/Hamming_distance) between two</span>
<span class="cm"> * integers</span>
<span class="cm"> *</span>
<span class="cm"> * @details</span>
<span class="cm"> * To find hamming distance between two integers, we take their xor, which will</span>
<span class="cm"> * have a set bit iff those bits differ in the two numbers.</span>
<span class="cm"> * Hence, we return the number of such set bits.</span>
<span class="cm"> *</span>
<span class="cm"> * @author [Ravishankar Joshi](https://github.com/ravibitsgoa)</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;   /// for assert</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;  /// for io operations</span><span class="cp"></span>

 <span class="cm">/**</span>
<span class="cm">  * @namespace bit_manipulation</span>
<span class="cm">  * @brief Bit Manipulation algorithms</span>
<span class="cm">  */</span>
<span class="k">namespace</span> <span class="n">bit_manipulation</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * @namespace hamming_distance</span>
<span class="cm">     * @brief Functions for [Hamming</span>
<span class="cm">     * distance](https://en.wikipedia.org/wiki/Hamming_distance) implementation</span>
<span class="cm">     */</span>
    <span class="k">namespace</span> <span class="n">hamming_distance</span> <span class="p">{</span>
        <span class="cm">/**</span>
<span class="cm">         * This function returns the number of set bits in the given number.</span>
<span class="cm">         * @param value the number of which we want to count the number of set bits.</span>
<span class="cm">         * @returns the number of set bits in the given number.</span>
<span class="cm">         */</span>
        <span class="kt">uint64_t</span> <span class="n">bitCount</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">uint64_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>       <span class="c1">// until all bits are zero</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// check lower bit</span>
                    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">value</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// shift bits, removing lower bit</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/**</span>
<span class="cm">         * This function returns the hamming distance between two integers.</span>
<span class="cm">         * @param a the first number</span>
<span class="cm">         * @param b the second number</span>
<span class="cm">         * @returns the number of bits differing between the two integers.</span>
<span class="cm">         */</span>
        <span class="kt">uint64_t</span> <span class="n">hamming_distance</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bitCount</span><span class="p">(</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">);</span> <span class="p">}</span>

        <span class="cm">/**</span>
<span class="cm">         * This function returns the hamming distance between two strings.</span>
<span class="cm">         * @param a the first string</span>
<span class="cm">         * @param b the second string</span>
<span class="cm">         * @returns the number of characters differing between the two strings.</span>
<span class="cm">         */</span>
        <span class="kt">uint64_t</span> <span class="n">hamming_distance</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
            <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="kt">uint64_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>  <span class="c1">// namespace hamming_distance</span>
<span class="p">}</span>  <span class="c1">// namespace bit_manipulation</span>

<span class="cm">/**</span>
<span class="cm"> * @brief Function to the test hamming distance.</span>
<span class="cm"> * @returns void</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="s">&quot;1101&quot;</span><span class="p">,</span>
        <span class="s">&quot;1111&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="s">&quot;1111&quot;</span><span class="p">,</span>
        <span class="s">&quot;1111&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="s">&quot;0000&quot;</span><span class="p">,</span>
        <span class="s">&quot;1111&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="s">&quot;alpha&quot;</span><span class="p">,</span>
        <span class="s">&quot;alphb&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span>
        <span class="s">&quot;abcd&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="s">&quot;dcba&quot;</span><span class="p">,</span>
        <span class="s">&quot;abcd&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * @brief Main function</span>
<span class="cm"> * @returns 0 on exit</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">test</span><span class="p">();</span>           <span class="c1">// execute the tests</span>
    <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>  <span class="c1">// 1011 in binary</span>
    <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1">// 0010 in binary</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hamming distance between &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; and &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; is &quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">bit_manipulation</span><span class="o">::</span><span class="n">hamming_distance</span><span class="o">::</span><span class="n">hamming_distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Hamming</span> <span class="n">distance</span> <span class="n">between</span> <span class="mi">11</span> <span class="ow">and</span> <span class="mi">2</span> <span class="ow">is</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id24">
<h2>进阶<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<div class="section" id="id25">
<h3><a class="reference external" href="https://github.com/mxgmn/WaveFunctionCollapse">Wave Function Collapse - 波函数坍缩</a><a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<div class="literal-block-wrapper docutils container" id="id40">
<div class="code-block-caption"><span class="caption-text">OverlappingModel.cs</span><a class="headerlink" href="#id40" title="永久链接至代码">¶</a></div>
<div class="highlight-csharp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367</pre></div></td><td class="code"><div class="highlight"><pre><span></span>/*
The MIT License(MIT)
Copyright(c) mxgmn 2016.
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
The software is provided &quot;as is&quot;, without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.
*/

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;

internal class OverlappingModel : Model
{
    #region 字段

    private readonly int _N;
    private readonly byte[][] _patterns;
    private readonly List&lt;Color&gt; _colors;
    private readonly int _ground;

    #endregion

    #region 构造函数

    /// &lt;summary&gt;
    ///
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;图片名称&lt;/param&gt;
    /// &lt;param name=&quot;N&quot;&gt;滤波窗口大小&lt;/param&gt;
    /// &lt;param name=&quot;width&quot;&gt;原图宽度&lt;/param&gt;
    /// &lt;param name=&quot;height&quot;&gt;原图高度&lt;/param&gt;
    /// &lt;param name=&quot;periodicInput&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;periodic&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;symmetry&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;ground&quot;&gt;&lt;/param&gt;
    public OverlappingModel(string name, int N, int width, int height, bool periodicInput, bool periodic, int symmetry, int ground) : base(width, height)
    {
        _N = N;
        _periodic = periodic;

        Bitmap bitmap = new Bitmap($&quot;samples/{name}.png&quot;);
        int SMX = bitmap.Width, SMY = bitmap.Height;
        byte[,] sample = new byte[SMX, SMY]; // 记录原始图片中每个像素（x,y） 的颜色映射到 colors 列表中的 index
        _colors = new List&lt;Color&gt;(); // 记录原始图片中的颜色列表

        for (int y = 0; y &lt; SMY; y++)
        {
            for (int x = 0; x &lt; SMX; x++)
            {
                Color color = bitmap.GetPixel(x, y);

                int i = 0;
                foreach (Color c in _colors)
                {
                    if (c == color)
                    {
                        break;
                    }
                    i++;
                }
                if (i == _colors.Count)
                {
                    _colors.Add(color);
                }
                sample[x, y] = (byte)i;
            }
        }

        // 输入图片中的颜色数量
        int C = _colors.Count;
        // 滤波窗口（N*N）有多少种颜色组成的可能
        long W = C.ToPower(N * N);

        byte[] pattern(Func&lt;int, int, byte&gt; f)
        {
            byte[] result = new byte[N * N];
            for (int y = 0; y &lt; N; y++)
            {
                for (int x = 0; x &lt; N; x++)
                {
                    result[x + y * N] = f(x, y);
                }
            }

            return result;
        };

        // 使用滤波窗口（N*N）在原图片(SMX*SMY)中采样
        // 返回数组大小：N*N
        byte[] patternFromSample(int x, int y)
        {
            return pattern((dx, dy) =&gt; sample[(x + dx) % SMX, (y + dy) % SMY]);
        }

        // 0,1
        // 2,3
        // To
        // 1,3
        // 0,2
        // 逆时针旋转90°
        // 输入 p 的 size : N*N
        byte[] rotate(byte[] p)
        {
            return pattern((x, y) =&gt; p[N - 1 - y + x * N]);
        }

        // 0,1
        // 2,3
        // To
        // 1,0
        // 3,2
        // 左右翻转
        // 输入 p 的 size : N*N
        byte[] reflect(byte[] p)
        {
            return pattern((x, y) =&gt; p[N - 1 - x + y * N]);
        }

        // 在 N*N 的窗口中使用 C 种颜色填充共 N*N的C次方种组合
        // 输入 p 的 size : N*N
        // 返回 给定的 数据 p (N*N) 是所有可能组合中的第几个
        long index(byte[] p)
        {
            long result = 0, power = 1;
            for (int i = 0; i &lt; p.Length; i++)
            {
                result += p[p.Length - 1 - i] * power;
                power *= C;
            }
            return result;
        };

        // 在 N*N 的窗口中使用 C 种颜色填充共 N*N的C次方种组合
        // 输入 ind 为 index ,即从 N*N的C次方种组合中选择第ind中输出
        // 返回 N*N
        byte[] patternFromIndex(long ind)
        {
            long residue = ind, power = W;
            byte[] result = new byte[N * N];

            for (int i = 0; i &lt; result.Length; i++)
            {
                power /= C;
                int count = 0;

                while (residue &gt;= power)
                {
                    residue -= power;
                    count++;
                }

                result[i] = (byte)count;
            }

            return result;
        };
        // 输入图片中存在的 N*N 索引列表对应出现的次数
        // key： index
        // value: count
        Dictionary&lt;long, int&gt; weights = new Dictionary&lt;long, int&gt;();
        // 输入图片中存在的 N*N 索引列表
        List&lt;long&gt; ordering = new List&lt;long&gt;();

        for (int y = 0; y &lt; (periodicInput ? SMY : SMY - N + 1); y++)
        {
            for (int x = 0; x &lt; (periodicInput ? SMX : SMX - N + 1); x++)
            {

                // 对采样数据（N*N）进行处理后的8种可能情况（旋转4*翻转2）
                byte[][] ps = new byte[8][];

                ps[0] = patternFromSample(x, y);    // 滤波窗口采样数据
                ps[1] = reflect(ps[0]);
                ps[2] = rotate(ps[0]);              // 逆时针旋转90°
                ps[3] = reflect(ps[2]);
                ps[4] = rotate(ps[2]);              // 逆时针旋转90°*2
                ps[5] = reflect(ps[4]);
                ps[6] = rotate(ps[4]);              // 逆时针旋转90°*3
                ps[7] = reflect(ps[6]);

                for (int k = 0; k &lt; symmetry; k++)
                {
                    long ind = index(ps[k]);
                    if (weights.ContainsKey(ind))
                    {
                        weights[ind]++;
                    }
                    else
                    {
                        weights.Add(ind, 1);
                        ordering.Add(ind);
                    }
                }
            }
        }

        // 对输入的图片以 N*N 窗口进行采样时，共包含几种情况
        // 小于等于N*N的C次方
        _T = weights.Count;

        _ground = (ground + _T) % _T;

        // 对输入图片进行采样后的结果：
        // _patterns: 图片中使用的所有 N*N 的 pattern
        // _weights: 图片中每种 pattern 出现的次数
        _patterns = new byte[_T][];
        _weights = new double[_T];

        int counter = 0;
        foreach (long w in ordering)
        {
            _patterns[counter] = patternFromIndex(w);
            _weights[counter] = weights[w];
            counter++;
        }

        bool agrees(byte[] p1, byte[] p2, int dx, int dy)
        {
            int xmin = dx &lt; 0 ? 0 : dx, xmax = dx &lt; 0 ? dx + N : N, ymin = dy &lt; 0 ? 0 : dy, ymax = dy &lt; 0 ? dy + N : N;
            for (int y = ymin; y &lt; ymax; y++)
            {
                for (int x = xmin; x &lt; xmax; x++)
                {
                    if (p1[x + N * y] != p2[x - dx + N * (y - dy)])
                    {
                        return false;
                    }
                }
            }

            return true;
        };


        // 计算采样出来的 _patterns 中，两两之间是否兼容
        _propagator = new int[4][][];// 上、下、左、右
        for (int d = 0; d &lt; 4; d++)
        {
            _propagator[d] = new int[_T][];
            for (int t = 0; t &lt; _T; t++)
            {
                List&lt;int&gt; list = new List&lt;int&gt;();
                for (int t2 = 0; t2 &lt; _T; t2++)
                {
                    if (agrees(_patterns[t], _patterns[t2], _DX[d], _DY[d]))
                    {
                        list.Add(t2);
                    }
                }

                _propagator[d][t] = new int[list.Count];
                for (int c = 0; c &lt; list.Count; c++)
                {
                    _propagator[d][t][c] = list[c];
                }
            }
        }
    }

    #endregion

    #region 重写

    protected override bool OnBoundary(int x, int y) =&gt; !_periodic &amp;&amp; (x + _N &gt; _FMX || y + _N &gt; _FMY || x &lt; 0 || y &lt; 0);

    public override Bitmap Graphics()
    {
        Bitmap result = new Bitmap(_FMX, _FMY);
        int[] bitmapData = new int[result.Height * result.Width];

        if (_observed != null)
        {
            for (int y = 0; y &lt; _FMY; y++)
            {
                int dy = y &lt; _FMY - _N + 1 ? 0 : _N - 1;
                for (int x = 0; x &lt; _FMX; x++)
                {
                    int dx = x &lt; _FMX - _N + 1 ? 0 : _N - 1;
                    Color c = _colors[_patterns[_observed[x - dx + (y - dy) * _FMX]][dx + dy * _N]];
                    bitmapData[x + y * _FMX] = unchecked((int)0xff000000 | (c.R &lt;&lt; 16) | (c.G &lt;&lt; 8) | c.B);
                }
            }
        }
        else
        {
            for (int i = 0; i &lt; _wave.Length; i++)
            {
                int contributors = 0, r = 0, g = 0, b = 0;
                int x = i % _FMX, y = i / _FMX;

                for (int dy = 0; dy &lt; _N; dy++)
                {
                    for (int dx = 0; dx &lt; _N; dx++)
                    {
                        int sx = x - dx;
                        if (sx &lt; 0)
                        {
                            sx += _FMX;
                        }

                        int sy = y - dy;
                        if (sy &lt; 0)
                        {
                            sy += _FMY;
                        }

                        int s = sx + sy * _FMX;
                        if (OnBoundary(sx, sy))
                        {
                            continue;
                        }

                        for (int t = 0; t &lt; _T; t++)
                        {
                            if (_wave[s][t])
                            {
                                contributors++;
                                Color color = _colors[_patterns[t][dx + dy * _N]];
                                r += color.R;
                                g += color.G;
                                b += color.B;
                            }
                        }
                    }
                }

                bitmapData[i] = unchecked((int)0xff000000 | ((r / contributors) &lt;&lt; 16) | ((g / contributors) &lt;&lt; 8) | b / contributors);
            }
        }

        BitmapData bits = result.LockBits(new Rectangle(0, 0, result.Width, result.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
        System.Runtime.InteropServices.Marshal.Copy(bitmapData, 0, bits.Scan0, bitmapData.Length);
        result.UnlockBits(bits);

        return result;
    }

    protected override void Clear()
    {
        base.Clear();

        if (_ground != 0)
        {
            for (int x = 0; x &lt; _FMX; x++)
            {
                for (int t = 0; t &lt; _T; t++)
                {
                    if (t != _ground)
                    {
                        Ban(x + (_FMY - 1) * _FMX, t);
                    }
                }

                for (int y = 0; y &lt; _FMY - 1; y++)
                {
                    Ban(x + y * _FMX, _ground);
                }
            }

            Propagate();
        }
    }

    #endregion
}
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="merkle-tree">
<h3>Merkle Tree - 默克尔树<a class="headerlink" href="#merkle-tree" title="永久链接至标题">¶</a></h3>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Vocabulary.html" class="btn btn-neutral float-right" title="Vocabulary" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="NSIS.html" class="btn btn-neutral float-left" title="nullsoft scriptable install system 3.0.4" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, horizonshd.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>