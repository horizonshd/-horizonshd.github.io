=========
Algorithm
=========

.. :
    
     = - ` : ' " ~ ^ _ * + # < >

    ====================
    --------------------
    ~~~~~~~~~~~~~~~~~~~~
    ********************
    ####################


基础
========

排序
------

冒泡排序
~~~~~~~~

说明：

    冒泡排序是在给定序列中将无序区间的数据通过不断交换将目标（无序区间的最小
    或最大）数据移至有序区间。

特点：

    -   {无序区，有序区}

思路：

    1.  在给定序列 *Sn* 中，从第一个元素开始两两比较（最大或最小）交换数据，
        最后一个元素变成有序的（最大或最小）；
    2.  再对无序的子序列 *Sn-1* 进行步骤 1 操作，直至全部数据都为有序的。

实现：

    .. code-block:: c++
        :linenos:
        :caption: BubbleSort.cpp
        
        #include<iostream>

        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";;
        }

        template<typename T>
        void swap(T array[], int aIndex, int bIndex)
        {
            int temp = array[aIndex];
            array[aIndex] = array[bIndex];
            array[bIndex] = temp;
        }

        template<typename T, int N >
        int BubbleSort(T array[])
        {
            int count = 0;
            for (int i = 0; i < N - 1; i++)
            {
                for (int j = 0; j < N - 1 - i; j++)
                {
                    count++;
                    if (array[j] > array[j + 1])
                    {
                        swap<T>(array, j, j + 1);
                    }
                }
            }
            return count;
        }

        int main() {
            int data[] = { 2,1,4,5,6 };
            int count = BubbleSort<int, 5>(data);

            Print<int, 5>(data);
            std::cout << "Compare " << count << " times.\n";

            return 0;
        }
    
    可以做如下优化，当左侧区间已经有序时不再进行无效的遍历：
    
    .. code-block:: c++
        :linenos:
        :emphasize-lines: 5,6,8,14

        template<typename T, int N >
        int BubbleSort(T array[])
        {
            int count = 0;
            bool ordered = false;
            for (int i = 0; i < N - 1 && !ordered; i++)
            {
                ordered = true;
                for (int j = 0; j < N - 1 - i; j++)
                {
                    count++;
                    if (array[j] > array[j + 1])
                    {
                        ordered = false;
                        swap<T>(array, j, j + 1);
                    }
                }
            }
            return count;
        }

选择排序
~~~~~~~~

说明：

    选择排序是在给定序列中将无序区间的数据中选择最小（或最大）放到有序区，直
    到数据全部有序。

特点：

    -   {有序区，无序区}
    -   比较多，交换少

思路：

    1.  在给定序列 *Sn* 中，选择最小（或最大）的数据放到有序区末尾；
    2.  再对无序的子序列 *Sn-1* 进行步骤 1 操作，直至全部数据都为有序的。

实现：

    .. code-block:: c++
        :linenos:
        :caption: SelectionSort.cpp

        #include<iostream>

        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";;
        }

        template<typename T>
        void swap(T array[], int aIndex, int bIndex)
        {
            int temp = array[aIndex];
            array[aIndex] = array[bIndex];
            array[bIndex] = temp;
        }

        template<typename T, int N >
        int SelectionSort(T array[])
        {
            int count = 0;
            for (int i = 0; i < N - 1; i++)
            {
                int minIndex = i;
                for (int j = i + 1; j < N; j++)
                {
                    count++;
                    if (array[j] < array[minIndex])
                    {
                        minIndex = j;
                    }
                }
                if (minIndex != i)
                {
                    swap<T>(array, minIndex, i);
                }
            }

            return count;
        }

        int main() {
            int data[] = { 2,1,4,5,6 };
            int count = SelectionSort<int, 5>(data);

            Print<int, 5>(data);
            std::cout << "Compare " << count << " times.\n";

            return 0;
        }

插入排序
~~~~~~~~

说明：

    插入排序是在给定序列中将无序区间的第一个数据插入到有序区的合适位置，直到
    全部数据有序。

特点：

    -   {有序区，无序区}
    -   比较多，交换少

思路：

    1.  在给定序列 *Sn* 中，选择最小（或最大）的数据放到有序区的合适位置；
    2.  再对无序的子序列 *Sn-1* 进行步骤 1 操作，直至全部数据都为有序的。

实现：

    .. code-block:: c++
        :linenos:
        :caption: InsertSort.cpp

        #include<iostream>

        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";;
        }

        template<typename T>
        void swap(T array[], int aIndex, int bIndex)
        {
            int temp = array[aIndex];
            array[aIndex] = array[bIndex];
            array[bIndex] = temp;
        }

        template<typename T, int N >
        int InsertSort(T array[])
        {
            int count = 0;

            for (int i = 1; i < N; i++)
            {
                for (int j = i - 1; j >= 0; j--)
                {
                    count++;
                    if (array[j + 1] < array[j])
                    {
                        swap<T>(array, j + 1, j);
                    }
                }
            }

            return count;
        }

        int main() {
            int data[] = { 4,2,5,1,6 };
            int count = InsertSort<int, 5>(data);

            Print<int, 5>(data);
            std::cout << "Compare " << count << " times.\n";

            return 0;
        }

快速排序
~~~~~~~~~

说明：

    快速排序是在给定的序列中随机选择一个基数，然后将该序列中小于(或小于等于)
    这个基数的数据放到该基数的左测，将大于等于（或大于）这个基数的数据放到该
    基数的右侧，然后再分别对左右两侧的数据做同样的操作，直至待排序区间的数据
    只有一个为止。

特点：

    -   {小数，基数，大数}

思路：
    
    1.  在给定序列  *s* 中将第一个数作为本次处理的基数 *n* ；
    2.  将 *s* 中小于 *n* 的数据放到该基数的左侧 *sl* ，将大于等于 *n* 的
        数据放到该基数的右侧 *sr* ；
    3.  分别对 *sl* 和 *sr* 两个子序列的数据进行步骤 1 2 的操作，直至某次序
        列中的数据只有一个为止。

实现：

    .. code-block:: c++
        :linenos:
        :caption: QuickSort.cpp

        #include<iostream>
        
        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";;
        }

        template<typename T>
        void swap(T array[], int aIndex, int bIndex)
        {
            int temp = array[aIndex];
            array[aIndex] = array[bIndex];
            array[bIndex] = temp;
        }

        template<typename T >
        int QuickSort(T array[], int startIndex, int endIndex)
        {
            int count = 0;
            if (startIndex < endIndex)
            {
                int baseIndex = startIndex;
                const int baseValue = array[startIndex];

                for (int i = startIndex + 1; i <= endIndex; i++)
                {
                    count++;
                    if (array[i] < baseValue)
                    {
                        // 将 [baseIndex, i) 的数据右移一个索引
                        // 将移动前的 array[i] 移到 baseIndex
                        for (int j = i; j > baseIndex; j--)
                        {
                            swap<T>(array, j, j - 1);
                        }
                        baseIndex++;
                    }
                }

                count += QuickSort<int>(array, startIndex, baseIndex - 1);
                count += QuickSort<int>(array, baseIndex + 1, endIndex);
            }
            return count;
        }

        int main() {
            int data[] = { 4,2,5,1,6 };
            int count = QuickSort<int>(data, 0, 4);

            Print<int, 5>(data);
            std::cout << "Compare " << count << " times.\n";

            return 0;
        }

堆排序
~~~~~~~

说明：

    堆排序是把给定序列的数据以二叉树的形式来处理，存储在数组中，每个节点 `i`
    的子节点为 `2i+1` 和 `2i+2` ， 父节点为 `(i-1)/2` 。
    
    如果整棵二叉树中每个父节点的值都大于其（一个或两个）子节点的值，则是 ``最大堆`` ；
    如果每个父节点的值都小于其（一个或两个）子节点的值，则是 ``最小堆`` 。
    
    排序过程则是先将给定序列的数据处理成最大堆（或最小堆），将堆顶元素（值最大或最小）
    与最后一个无序的节点交换，有序区得到扩大。然后再对无序区中的序列做最大堆
    处理，交换堆顶元素和无序区最后一个元素。不断迭代，直至所有数据均有序。

特点：


思路：
    
    1.  从最后一个父子节点开始做最大堆处理，一直到对第一个父子节点完成最大堆
        的处理，此时整个序列中的数据已经成为最大堆的状态；
    2.  交换堆顶元素和最后一个元素，交换后最后一个元素成为有序状态；
    3.  对第一个父子节点和无序区中的其他数据做最大堆调整；
    4.  重复步骤 2 和 3，直至无序区元素的数量只有一个为止。

实现：

    .. code-block:: c++
        :linenos:
        :caption: HeapSort.cpp

        #include<iostream>

        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";
        }

        template<typename T>
        void swap(T array[], int aIndex, int bIndex)
        {
            int temp = array[aIndex];
            array[aIndex] = array[bIndex];
            array[bIndex] = temp;
        }

        template<typename T>
        void MaxHeapify(T data[], int start, int end)
        {
            int dad = start;
            int son = 2 * dad + 1;
            while (son <= end)
            {
                if (son + 1 <= end && data[son] < data[son + 1])
                    ++son;
                if (data[dad] >= data[son])
                    break;
                else
                {
                    swap<T>(data, dad, son);
                    dad = son;
                    son = 2 * son + 1;
                }
            }
        }

        template<typename T>
        void HeapSort(T data[], int n)
        {
            // ******************
            //
            // 建立最大堆
            //
            for (int i = (n - 1 - 1) / 2; i >= 0; --i)
            {
                MaxHeapify<T>(data, i, n - 1);
            }

            // ******************
            //
            // 堆排序（最大堆调整）
            //
            swap<T>(data, n - 1, 0);
            for (int i = n - 2; i > 0; --i)
            {
                MaxHeapify<T>(data, 0, i);
                swap<T>(data, i, 0);
            }
        }

        int main() {
            int data[] = { 100,5,3,11,33,6,8,7 };

            HeapSort<int>(data, 8);
            Print<int, 8>(data);

            return 0;
        };

归并排序
~~~~~~~~~~

说明：

    归并排序是将给定序列分成两部分，以递归的方式分别将两部分数据排好序，然后
    从这两部分数据的头部逐一比较将其放至最终的输出数据中。

特点：

    -   需要额外的空间存储过程中的已排序数据

思路：
    
    1.  将给定序列  *s* 分成两段 *sl* 和 *sr* ；
    2.  将子序列 *sl* 和 *sr* 按步骤 1 递归操作，直至子序列中只有一个数据
        （默认为已排序）；
    3.  对通过递归操作已排好序的两部分子序列 *sl* 和 *sr* 进行合并。

实现：

    .. code-block:: c++
        :caption: MergeSort.cpp
        :linenos:
        :emphasize-lines: 29,38,59

        #include<iostream>

        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";
        }

        template<typename T>
        void swap(T array[], int aIndex, int bIndex)
        {
            int temp = array[aIndex];
            array[aIndex] = array[bIndex];
            array[bIndex] = temp;
        }

        template<typename T >
        int MergeSort(T array[], int start, int end)
        {
            int count = 0;

            if (start < end)
            {
                int len = end - start;
                int mid = (len >> 1) + start;
                int start1 = start;
                int end1 = mid;
                int start2 = mid + 1;
                int end2 = end;
                count += MergeSort<T>(array, start1, end1);
                count += MergeSort<T>(array, start2, end2);

                T* temp = new T[len + 1];
                int p = 0;

                while (start1 <= end1 && start2 <= end2)
                {
                    count++;
                    temp[p++] = array[start1] < array[start2] ? array[start1++] : array[start2++];
                }

                while (start1 <= end1)
                {
                    count++;
                    temp[p++] = array[start1++];
                }

                while (start2 <= end2)
                {
                    count++;
                    temp[p++] = array[start2++];
                }

                memcpy(array + start, temp, (len + 1) * sizeof(T));
                delete[] temp;
            }

            return count;
        }

        int main() {
            int data[] = { 4,2,5,1,6 };
            int count = MergeSort<int>(data, 0, 4);

            Print<int, 5>(data);
            std::cout << "Compare " << count << " times.\n";

            return 0;
        }

希尔排序
~~~~~~~~~

说明：

    希尔排序主要是通过将给定序列中的数据按照一定的步进 `step` 进行分组再单独
    对每个组内的元素进行排序（通常使用 :ref:`src/Algorithm:插入排序` ），
    使每个组内的元素各自有序；再通过不断减小 `step` 继续对重新分组后的组内元
    素进行排序使其组内的元素有序；最终当 `step` 等于 `1` 时，整个序列中的数
    据将成为一个组，对其中的元素排序后将使整个序列中的元素达到有序的状态。

特点：

思路：

    1.  设置初始步进 `int step = N /2` ，其中 `N` 为给定序列元素的数量；
    2.  将序列中间隔为 `step` 的元素进行排序，通常使用 :ref:`src/Algorithm:插入排序` ；
    3.  调整 `step = step /2` ，重复步骤 2 ；
    4.  当 `step` 的值为 `1` 时，再进行一次排序操作后所有数据均成为有序的。

实现：

    .. code-block:: c++
        :caption: ShellSort.cpp
        :linenos:

        #include<iostream>

        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";
        }

        template<typename T>
        void swap(T array[], int aIndex, int bIndex)
        {
            int temp = array[aIndex];
            array[aIndex] = array[bIndex];
            array[bIndex] = temp;
        }

        template<typename T, int N>
        int ShellSort(T array[])
        {
            int count = 0;
            int step = N;
            while ((step /= 2) > 0)
            {
                for (int i = step; i < N; i++)
                {
                    ++count;
                    int j = i;

                    // 每个分组内部进行插入排序
                    while (j - step >= 0 && array[j - step] > array[j])
                    {
                        swap<T>(array, j - step, j);
                        j -= step;
                    }
                }
            }

            return count;
        }

        int main() {
            int data[] = { 4,2,5,1,6 };

            int count = ShellSort<int, 5>(data);
            Print<int, 5>(data);

            std::cout << "Compare " << count << " times.\n";

            return 0;
        }

计数排序
~~~~~~~~~

说明：

    计数排序主要是通过统计给定数据（ int 型 ）中每一个数字出现的次数，然后再
    根据这个统计信息按照一定方式将这些数据变成有序状态。

特点：

    -   需要额外的空间开销存储辅助数据
    -   出于算法的原因只能对 int 型的数据进行排序

思路：

    1.  找出待排序的数组中最大（ `maxValue` ）和最小（ `minValue` ）的元素；
    2.  统计数组中每个值为 `value` 的元素出现的次数，存入数组 `countArray` 
        的第 `value - minValue` 项；
    3.  对所有的计数累加（从 `countArray` 中的第一个元素开始，每一项和前一项相加）；
    4.  反向填充目标数组 `sorted` 中，稍微有些复杂。

实现：

    .. code-block:: c++
        :caption: CountSort.cpp
        :linenos:
        
        #include<iostream>

        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";
        }

        template<int N>
        void CountSort(int array[])
        {
            int minValue = array[0];
            int maxValue = array[0];
            for (int i = 1; i < N; ++i)
            {
                if (array[i] < minValue)
                    minValue = array[i];
                else if (array[i] > maxValue)
                    maxValue = array[i];
            }

            // *****************
            // 1. 对数据进行统计
            //
            int tempSize = maxValue - minValue + 1;
            int* countArray = new int[tempSize]();
            for (int i = 0; i < N; ++i)
            {
                countArray[array[i] - minValue] ++; // 这里就要求 array 数组必须是 int 型时索引 array[i] - minValue 才是合法的
            }

            // *****************
            // 2. 对数据排序
            //
            //// 方式一
            //int index = 0;
            //for (int i = 0; i < tempSize; ++i)
            //{
            //    while (countArray[i]--)
            //    {
            //        array[index++] = i + minValue;
            //    }
            //}

            // 方式二
            for (int i = 1; i < tempSize; ++i)
            {
                countArray[i] += countArray[i - 1]; // 使 countArray[i] 记录待排序数组中第 i 大（0 based）的元素在最终已排序数组中的开始索引
            }
            int* sorted = new int[N]();

            for (int i = N; i > 0; --i)
            {
                // 通过数据的至计算出其在待输出有序数组中的索引
                int targetValue = array[i - 1];
                int targetIndex = array[i - 1] - minValue;
                int finalIndex = --countArray[targetIndex];

                sorted[finalIndex] = targetValue;
            }
            memcpy(array, sorted, N * sizeof(int));

            delete countArray;
            delete sorted;
        }

        int main() {
            int data[] = { 4,2,5,1,6 };
            CountSort<5>(data);
            Print<int, 5>(data);
            return 0;
        }

桶排序
~~~~~~~~~~~~

说明：

    桶排序将给定序列的数据 `Sn` 按照一定的规则分散到 `BUCKET_NUM` 个桶中，
    数据需要按照 *一定的顺序* 入桶，全部数据入桶后再将数据从桶中倒出（两两一
    起）排序。

特点：

思路：

    1.  可以使用 `std::vector` 来实现桶的逻辑；
    2.  将给定序列中的数据按照一定规则（比如可以将序列中元素的索引值对桶的数
        量取模确定元素放到哪个桶中）分散到各个桶中，入桶时就可以做排序；
    3.  再将每两个桶中的数据取出并排序，直至所有桶中的数据取完即可。

实现：

    .. code-block:: c++
        :caption: BucketSort.cpp
        :linenos:

        #include<iostream>
        #include<vector>

        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";
        }

        template<typename T>
        void swap(T array[], int aIndex, int bIndex)
        {
            int temp = array[aIndex];
            array[aIndex] = array[bIndex];
            array[bIndex] = temp;
        }

        template<typename T>
        struct ListNode
        {
        public:
            T data;
            ListNode* next;
            explicit ListNode() :data(0), next(nullptr) {}
            explicit ListNode(T data) :data(data), next(nullptr) {}
            explicit ListNode(T data, ListNode<T>* next) :data(data), next(next) {}
        };

        template<typename T>
        ListNode<T>* Insert(ListNode<T>* listNodes, T data)
        {
            ListNode<T> dummyNode(0, listNodes);

            ListNode<T>* prePtr = &dummyNode;
            ListNode<T>* curPtr = listNodes;

            while (curPtr != nullptr && curPtr->data < data)
            {
                prePtr = curPtr;
                curPtr = curPtr->next;
            }
            prePtr->next = new ListNode<T>(data, curPtr);
            return dummyNode.next;
        }

        /// <summary>
        /// 要求两个链表均已排好序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="listA"></param>
        /// <param name="listB"></param>
        template<typename T>
        ListNode<T>* Merge(ListNode<T>* listA, ListNode<T>* listB)
        {
            ListNode<T> dummyNode;
            ListNode<T>* dummyNodePtr = &dummyNode;
            while (listA != nullptr && listB != nullptr)
            {
                if (listA->data < listB->data)
                {
                    dummyNodePtr->next = listA;
                    listA = listA->next;
                }
                else
                {
                    dummyNodePtr->next = listB;
                    listB = listB->next;
                }
                dummyNodePtr = dummyNodePtr->next;
            }

            while (listA != nullptr)
            {
                dummyNodePtr->next = listA;
                listA = listA->next;
                dummyNodePtr = dummyNodePtr->next;
            }
            while (listB != nullptr)
            {
                dummyNodePtr->next = listB;
                listB = listB->next;
                dummyNodePtr = dummyNodePtr->next;
            }

            return dummyNode.next;
        }

        template<typename T, int N>
        void BucketSort(T array[], int bucketNum)
        {
            std::vector<ListNode<T>*> buckets(bucketNum, nullptr);

            for (int i = 0; i < N; i++)
            {
                int index = i % bucketNum;
                buckets.at(index) = Insert<T>(buckets.at(index), array[i]);
            }

            ListNode<T>* head = buckets.at(0);

            for (int i = 1; i < bucketNum; ++i)
            {
                head = Merge<T>(head, buckets.at(i));
            }

            for (int i = 0; i < N; i++)
            {
                array[i] = head->data;
                head = head->next;
            }
        }

        const int BUCKET_NUM = 2;   // 可以根据待排序数据的数量进行一定的优化
        int main() {
            int data[] = { 4,2,5,1,6 };

            BucketSort<int, 5>(data, BUCKET_NUM);
            Print<int, 5>(data);

            return 0;
        }

基数排序
~~~~~~~~~

说明：

    基数排序将给定序列中的数据按照每一位上的数字进行逐一比较（个位、十位...），
    基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most 
    significant digital）。LSD 的排序方式由键值的最右边开始，而MSD则相反，
    由键值的最左边开始。

特点：

    -   需要与待排序数据一样大的空间来存储过程中的部分排序后的数组。
    -   需要额外的空间存储统计信息，通常只需进制位的大小即可（比如 10 * sizeof(int) ）。
    -   只能对 int 类型的数据进行排序。

思路：

    1.  遍历给定序列 `Sn` 中的数据获取最大值 `max` 并计算 `max` 中的位数 `bits`
        （比如 `22` -> 2位，`456` -> 3位）；
    2.  对 `Sn` 中的数据以 LSD 或 MSD 的方式进行 `bits` 次排序。

实现：

    .. code-block:: c++
        :caption: RadixSortLSD.cpp
        :linenos:
        
        #include<iostream>

        template<typename T, int N>
        void Print(const T data[])
        {
            for (int i = 0; i < N; i++)
            {
                std::cout << data[i] << " ";
            }

            std::cout << "\n";
        }

        const int ConterSize = 10; // 进制

        int MaxValue(int data[], int n)
        {
            int max = data[0];

            for (int i = 0; i < n; ++i)
            {
                if (data[i] > max)
                    max = data[i];
            }

            return max;
        }

        int MaxBit(int data[], int n)
        {
            int max = MaxValue(data, n);

            int ret = 1;
            while (max /= ConterSize)
            {
                ++ret;
            }
            return ret;
        }

        void RadixSortLSD(int data[], int n)
        {
            int bits = MaxBit(data, n);

            int* sortedArray = new int[n]();                        // 用于存储根据某一进制位排序后的原始数据
            int* counterArray = new int[ConterSize]();              // 用于存储根据某一进制位排序后的统计信息

            int radix = 1;                                          // 表示个位、十位...
            for (int i = 0; i < bits; ++i)                          // 从低（右侧）到高位（左侧）遍历排序
            {
                memset(counterArray, 0, ConterSize * sizeof(int));

                // *************************
                //
                // 遍历待排序数据 data 获取统计信息
                //
                for (int j = 0; j < n; ++j)
                {
                    int index = data[j] / radix % ConterSize;       // 计算 data[j] 在 radix 对应的进制位上的数字
                    ++counterArray[index];
                }
                for (int i = 1; i < ConterSize; i++)
                {
                    counterArray[i] += counterArray[i - 1];
                }

                // *************************
                //
                // 遍历待排序数据 data 结合统计信息
                // 获得本次排序后的数据放到 sortedArray 中
                //
                for (int j = n - 1; j >= 0; --j)
                {
                    int targetValue = data[j];
                    int counterIndex = targetValue / radix % ConterSize;
                    int targetIndex = --counterArray[counterIndex];

                    sortedArray[targetIndex] = targetValue;
                }

                memcpy(data, sortedArray, n * sizeof(int));
                radix *= ConterSize;
            }

            delete[] sortedArray;
            delete[] counterArray;
        }

        int main() {
            int data[] = { 4,2,5,1,6 };

            RadixSortLSD(data, 5);
            Print<int, 5>(data);

            return 0;
        };

查找
------

顺序查找
~~~~~~~~~~~~~

说明：


特点：


思路：


实现：

    .. code-block:: c++
        :caption: SequentialSearch.cpp
        :linenos:

        #include<iostream>

        template<typename T, int N>
        int SequentialSearch(T data[], T target)
        {
            for (int i = 0; i < N; ++i)
            {
                if (data[i] == target)
                    return i;
            }
            return  -1;
        }

        int main()
        {
            int data[] = { 1,2,3,4,5,6 };
            int r = SequentialSearch<int, 6>(data, 7);

            std::cout << r << std::endl;
            std::cin.get();
        }

二分查找
~~~~~~~~~

说明：


特点：

    -   要求给出的数据序列是有序的


思路：


实现：

    .. code-block:: c++
        :caption: BinarySearch.cpp
        :linenos:

        #include<iostream>

        template<typename T, int N>
        int BinarySearch(T data[], T targetValue)
        {
            int lowIndex = 0;
            int highIndex = N - 1;

            while (lowIndex <= highIndex)
            {
                int midIndex = (lowIndex + highIndex) / 2;

                if (data[midIndex] == targetValue)
                {
                    return midIndex;
                }
                else if (data[midIndex] > targetValue)
                {
                    highIndex = midIndex - 1;
                }
                else
                {
                    lowIndex = midIndex + 1;
                }
            }
            return  -1;
        }

        int main()
        {
            int data[] = { 1,2,3,4,5,6 };
            int r = BinarySearch<int, 6>(data, 4);

            std::cout << r << std::endl;
            std::cin.get();
        }

插值查找
~~~~~~~~~

说明：


特点：

    -   要求给出的数据序列是有序的
    -   序列中数据的分布是均匀的
    -   是 :ref:`src/Algorithm:二分查找` 的扩展


思路：

    1.  整体思路和 :ref:`src/Algorithm:二分查找` 一样，只是每次计算中间索引
    `midIndex` 的时候不再是使用 `(lowIndex + highIndex) / 2` 这样的方式来
    计算，而是根据目标值的特点来计算。


实现：

    .. code-block:: c++
        :caption: InterpolationSearch.cpp
        :linenos:
        :emphasize-lines: 11,13,14,15,16

        #include<iostream>

        template<typename T, int N>
        int InterpolationSearch(T data[], T targetValue)
        {
            int lowIndex = 0;
            int highIndex = N - 1;

            while (lowIndex <= highIndex)
            {
                int midIndex = lowIndex + int((targetValue - data[lowIndex]) * 1.0f / (data[highIndex] - data[lowIndex]) * (highIndex - lowIndex));

                if (midIndex<lowIndex || midIndex> highIndex)
                {
                    return -1;
                }

                if (data[midIndex] == targetValue)
                {
                    return midIndex;
                }
                else if (data[midIndex] > targetValue)
                {
                    highIndex = midIndex - 1;
                }
                else
                {
                    lowIndex = midIndex + 1;
                }
            }
            return  -1;
        }

        int main()
        {
            int data[] = { 1,2,3,4,5,6 };
            int r = InterpolationSearch<int, 6>(data, 4);

            std::cout << r << std::endl;
            std::cin.get();
        }

二叉树查找
~~~~~~~~~~

说明：


特点：


思路：


实现：

    .. code-block:: c++
        :caption: BinaryTreeSearch.cpp
        :linenos:

        #include<iostream>

        void* operator new(size_t size)
        {
            std::cout << "Allocating " << size << " bytes!\n";
            return malloc(size);
        }

        void operator delete(void* object, size_t size)
        {
            std::cout << "Freeing " << size << " bytes!\n";
            free(object);
        }

        struct BinaryTreeNode
        {
            int Data;
            BinaryTreeNode* LChild;
            BinaryTreeNode* RChild;

            BinaryTreeNode()
                : Data(0), LChild(nullptr), RChild(nullptr)
            {
            }

            BinaryTreeNode(int data)
                : Data(data), LChild(nullptr), RChild(nullptr)
            {
            }
        };

        void InsertNode(BinaryTreeNode** root, int data)
        {
            if (*root == nullptr)
                return;

            BinaryTreeNode** ptr = root;
            while (*ptr)
            {
                if (data > ((*ptr)->Data))
                {
                    ptr = &((*ptr)->RChild);
                }
                else
                {
                    ptr = &((*ptr)->LChild);
                }
            }
            *ptr = new BinaryTreeNode(data);
        }

        BinaryTreeNode* CreateBinatyTree(int data[], int n)
        {
            if (n <= 0)
                return nullptr;

            BinaryTreeNode* root = new BinaryTreeNode(data[0]);

            for (int i = 1; i < n; ++i)
            {
                InsertNode(&root, data[i]);
            }
            return root;
        }
        void FreeBinaryTree(BinaryTreeNode* node)
        {
            if (node)
            {
                FreeBinaryTree(node->LChild);
                FreeBinaryTree(node->RChild);
                delete node;
            }
        }

        bool BinaryTreeSearch(int data[], int n, int targetValue)
        {
            bool ret = false;

            BinaryTreeNode* root = CreateBinatyTree(data, n);
            BinaryTreeNode* ptr = root;

            while (ptr)
            {
                if (ptr->Data == targetValue)
                {
                    ret = true;
                    break;
                }
                else if (ptr->Data > targetValue)
                {
                    ptr = ptr->LChild;
                }
                else
                {
                    ptr = ptr->RChild;
                }
            }
            FreeBinaryTree(root);

            return ret;
        }

        int main()
        {
            int data[] = { 5,2,6,4,3,1,7,8 };
            bool found = BinaryTreeSearch(data, sizeof(data) / sizeof(int), 7);
            if (found)
            {
                std::cout << "Found!\n";
            }
            else
            {
                std::cout << "Not found!\n";
            }
            return 0;
        }

拓展
------

`Graph coloring <https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/graph_coloring.cpp>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++
    :linenos:
    
    /**
     * @file
     * @brief prints the assigned colors
     * using [Graph Coloring](https://en.wikipedia.org/wiki/Graph_coloring) algorithm
     *
     * @details
     * In graph theory, graph coloring is a special case of graph labeling;
     * it is an assignment of labels traditionally called "colors" to elements of a graph subject to certain constraints.
     * In its simplest form, it is a way of coloring the vertices of a graph such that no two adjacent vertices are of the same color;
     * this is called a vertex coloring. Similarly, an edge coloring assigns
     * a color to each edge so that no two adjacent edges are of the same color,
     * and a face coloring of a planar graph assigns a color to each face or
     * region so that no two faces that share a boundary have the same color.
     *
     * @author [Anup Kumar Panwar](https://github.com/AnupKumarPanwar)
     * @author [David Leal](https://github.com/Panquesito7)
     */
    #include <iostream>
    #include <array>
    #include <vector>

     /**
      * @namespace
      * @brief Backtracking algorithms
      */
    namespace backtracking {
        /** A utility function to print solution
         * @tparam V number of vertices in the graph
         * @param color array of colors assigned to the nodes
         */
        template <size_t V>
        void printSolution(const std::array <int, V>& color) {
            std::cout << "Following are the assigned colors\n";
            for (auto& col : color) {
                std::cout << col;
            }
            std::cout << "\n";
        }

        /** A utility function to check if the current color assignment is safe for
         * vertex v
         * @tparam V number of vertices in the graph
         * @param v index of graph vertex to check
         * @param graph matrix of graph nonnectivity
         * @param color vector of colors assigned to the graph nodes/vertices
         * @param c color value to check for the node `v`
         * @returns `true` if the color is safe to be assigned to the node
         * @returns `false` if the color is not safe to be assigned to the node
         */
        template <size_t V>
        bool isSafe(int v, const std::array<std::array <int, V>, V>& graph, const std::array <int, V>& color, int c) {
            for (int i = 0; i < V; i++) {
                if (graph[v][i] && c == color[i]) {
                    return false;
                }
            }
            return true;
        }

        /** A recursive utility function to solve m coloring problem
         * @tparam V number of vertices in the graph
         * @param graph matrix of graph nonnectivity
         * @param m number of colors
         * @param [in,out] color description // used in,out to notify in documentation
         * that this parameter gets modified by the function
         * @param v index of graph vertex to check
         */
        template <size_t V>
        void graphColoring(const std::array<std::array <int, V>, V>& graph, int m, std::array <int, V> color, int v) {
            // base case:
            // If all vertices are assigned a color then return true
            if (v == V) {
                backtracking::printSolution<V>(color);
                return;
            }

            // Consider this vertex v and try different colors
            for (int c = 1; c <= m; c++) {
                // Check if assignment of color c to v is fine
                if (backtracking::isSafe<V>(v, graph, color, c)) {
                    color[v] = c;

                    // recur to assign colors to rest of the vertices
                    backtracking::graphColoring<V>(graph, m, color, v + 1);

                    // If assigning color c doesn't lead to a solution then remove it
                    color[v] = 0;
                }
            }
        }
    }  // namespace backtracking

    /**
     * Main function
     */
    int main() {
        // Create following graph and test whether it is 3 colorable
        // (3)---(2)
        // |   / |
        // |  /  |
        // | /   |
        // (0)---(1)

        const int V = 4;  // number of vertices in the graph
        std::array <std::array <int, V>, V> graph = {
            std::array <int, V>({0, 1, 1, 1}),
            std::array <int, V>({1, 0, 1, 0}),
            std::array <int, V>({1, 1, 0, 1}),
            std::array <int, V>({1, 0, 1, 0})
        };

        int m = 3;  // Number of colors
        std::array <int, V> color{};

        backtracking::graphColoring<V>(graph, m, color, 0);
        std::cin.get();
        return 0;
    }
    
输出： ::

    Following are the assigned colors
    1232
    Following are the assigned colors
    1323
    Following are the assigned colors
    2131
    Following are the assigned colors
    2313
    Following are the assigned colors
    3121
    Following are the assigned colors
    3212
    
`Knight's tour <https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/knight_tour.cpp>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++
    :linenos:
    :emphasize-lines: 17,102,103,104

    /**
     * @file
     * @brief [Knight's tour](https://en.wikipedia.org/wiki/Knight%27s_tour) algorithm
     *
     * @details
     * A knight's tour is a sequence of moves of a knight on a chessboard
     * such that the knight visits every square only once. If the knight
     * ends on a square that is one knight's move from the beginning
     * square (so that it could tour the board again immediately, following
     * the same path, the tour is closed; otherwise, it is open.
     *
     * @author [Nikhil Arora](https://github.com/nikhilarora068)
     * @author [David Leal](https://github.com/Panquesito7)
     */
    #include <iostream>
    #include <array>
    #include <iomanip>

     /**
      * @namespace backtracking
      * @brief Backtracking algorithms
      */
    namespace backtracking {
        /**
         * A utility function to check if i,j are valid indexes for N*N chessboard
         * @tparam V number of vertices in array
         * @param x current index in rows
         * @param y current index in columns
         * @param sol matrix where numbers are saved
         * @returns `true` if ....
         * @returns `false` if ....
         */
        template <size_t V>
        bool issafe(int x, int y, const std::array <std::array <int, V>, V>& sol) {
            return (x < V&& x >= 0 && y < V&& y >= 0 && sol[x][y] == -1);
        }

        /**
         * Knight's tour algorithm
         * @tparam V number of vertices in array
         * @param x current index in rows
         * @param y current index in columns
         * @param mov movement to be done
         * @param sol matrix where numbers are saved
         * @param xmov next move of knight (x coordinate)
         * @param ymov next move of knight (y coordinate)
         * @returns `true` if solution exists
         * @returns `false` if solution does not exist
         */
        template <size_t V>
        bool solve(int x, int y, int mov, std::array <std::array <int, V>, V>& sol,
            const std::array <int, V>& xmov, const std::array <int, V>& ymov) {
            int k, xnext, ynext;

            if (mov == V * V) {
                return true;
            }

            for (k = 0; k < V; k++) {
                xnext = x + xmov[k];
                ynext = y + ymov[k];

                if (backtracking::issafe<V>(xnext, ynext, sol)) {
                    sol[xnext][ynext] = mov;

                    if (backtracking::solve<V>(xnext, ynext, mov + 1, sol, xmov, ymov) == true) {
                        return true;
                    }
                    else {
                        sol[xnext][ynext] = -1;
                    }
                }
            }
            return false;
        }
    } // namespace backtracking

    /**
     * Main function
     */
    int main() {
        const int n = 8;
        std::array <std::array <int, n>, n> sol = { 0 };

        int i, j;
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) { sol[i][j] = -1; }
        }

        std::array <int, n> xmov = { 2, 1, -1, -2, -2, -1, 1, 2 };
        std::array <int, n> ymov = { 1, 2, 2, 1, -1, -2, -2, -1 };

        sol[0][0] = 0;

        bool flag = backtracking::solve<n>(0, 0, 1, sol, xmov, ymov);
        if (flag == false) {
            std::cout << "Error: Solution does not exist\n";
        }
        else {
            for (i = 0; i < n; i++) {
                for (j = 0; j < n; j++) {
                    //std::cout << sol[i][j] << "  ";
                    std::cout.flags(std::ios::left);
                    std::cout << std::setw(4) << sol[i][j];
                }
                std::cout << "\n";
            }
        }
        return 0;
    }

输出： ::

    0   59  38  33  30  17  8   63
    37  34  31  60  9   62  29  16
    58  1   36  39  32  27  18  7
    35  48  41  26  61  10  15  28
    42  57  2   49  40  23  6   19
    47  50  45  54  25  20  11  14
    56  43  52  3   22  13  24  5
    51  46  55  44  53  4   21  12
    
`Minimax <https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/minimax.cpp>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++
    :linenos:
    :emphasize-lines: 57,58,59,60,62,63,64,65
    
    /**
     * @file
     * @brief returns which is the longest/shortest number
     * using [minimax](https://en.wikipedia.org/wiki/Minimax) algorithm
     *
     * @details
     * Minimax (sometimes MinMax, MM or saddle point) is a decision rule used in
     * artificial intelligence, decision theory, game theory, statistics,
     * and philosophy for minimizing the possible loss for a worst case (maximum loss) scenario.
     * When dealing with gains, it is referred to as "maximin"—to maximize the minimum gain.
     * Originally formulated for two-player zero-sum game theory, covering both the cases where players take
     * alternate moves and those where they make simultaneous moves, it has also been extended to more
     * complex games and to general decision-making in the presence of uncertainty.
     *
     * @author [Gleison Batista](https://github.com/gleisonbs)
     * @author [David Leal](https://github.com/Panquesito7)
     */
    #include <algorithm>
    #include <cmath>
    #include <iostream>
    #include <array>

     /**
      * @namespace backtracking
      * @brief Backtracking algorithms
      */
    namespace backtracking {
        /**
         * Check which number is the maximum/minimum in the array
         * @param depth current depth in game tree
         * @param node_index current index in array
         * @param is_max if current index is the longest number
         * @param scores saved numbers in array
         * @param height maximum height for game tree
         * @return maximum or minimum number
         */
        template <size_t T>
        int minimax(int depth, int node_index, bool is_max,
            const std::array<int, T>& scores, double height) {
            if (depth == height) {
                return scores[node_index];
            }

            int v1 = minimax(depth + 1, node_index * 2, !is_max, scores, height);
            int v2 = minimax(depth + 1, node_index * 2 + 1, !is_max, scores, height);

            return is_max ? std::max(v1, v2) : std::min(v1, v2);
        }
    } // namespace backtracking

    /**
     * Main function
     */
    int main() {
        std::array<int, 8> scores = { 90, 23, 6, 33, 21, 65, 123, 34423 };

        // max   65 (anser)
        // min   33             65
        // max   90      33     65      34423
        // min   90, 23, 6, 33, 21, 65, 123, 34423

        // min   23 (anser)
        // max   23             123
        // min   23      6      21      123
        // max   90, 23, 6, 33, 21, 65, 123, 34423

        double height = log2(scores.size());

        std::cout << "Optimal value: " << backtracking::minimax(0, 0, true, scores, height) << std::endl;
        std::cout << "Optimal value: " << backtracking::minimax(0, 0, false, scores, height) << std::endl;
        return 0;
    }
    
输出： ::

    Optimal value: 65
    Optimal value: 23


`Rat maze <https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/rat_maze.cpp>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++
    :linenos:

    /**
     * @file
     * @brief Implements [Rat in a
     * Maze](https://www.codesdope.com/blog/article/backtracking-to-
     * solve-a-rat-in-a-maze-c-java-pytho/) algorithm
     *
     * @details
     * A Maze is given as N*N binary matrix of blocks where source block is the
     * upper left most block i.e., maze[0][0] and destination block is lower
     * rightmost block i.e., maze[N-1][N-1]. A rat starts from source and has to
     * reach destination. The rat can move only in two directions: forward and down.
     * In the maze matrix, 0 means the block is dead end and 1 means the block can
     * be used in the path from source to destination.
     *
     * @author [Vaibhav Thakkar](https://github.com/vaithak)
     * @author [David Leal](https://github.com/Panquesito7)
     */

    #include <array>
    #include <iostream>
    #include <cassert>

     /**
      * @namespace backtracking
      * @brief Backtracking algorithms
      */
    namespace backtracking {
        /**
         * @namespace rat_maze
         * @brief Functions for [Rat in a
         * Maze](https://www.codesdope.com/blog/article/backtracking-to-
         * solve-a-rat-in-a-maze-c-java-pytho/) algorithm
         */
        namespace rat_maze {
            /**
             * @brief Solve rat maze problem
             * @tparam size number of matrix size
             * @param currposrow current position in rows
             * @param currposcol current position in columns
             * @param maze matrix where numbers are saved
             * @param soln matrix to problem solution
             * @returns 0 on end
             */
            template <size_t size>
            bool solveMaze(int currposrow, int currposcol,
                const std::array<std::array<int, size>, size>& maze,
                std::array<std::array<int, size>, size> soln) {
                if ((currposrow == size - 1) && (currposcol == size - 1)) {
                    soln[currposrow][currposcol] = 1;
                    for (int i = 0; i < size; ++i) {
                        for (int j = 0; j < size; ++j) {
                            std::cout << soln[i][j] << " ";
                        }
                        std::cout << std::endl;
                    }
                    return true;
                }
                else {
                    soln[currposrow][currposcol] = 1;

                    // if there exist a solution by moving one step ahead in a column
                    if ((currposcol < size - 1) && maze[currposrow][currposcol + 1] == 1 &&
                        solveMaze(currposrow, currposcol + 1, maze, soln)) {
                        return true;
                    }

                    // if there exists a solution by moving one step ahead in a row
                    if ((currposrow < size - 1) && maze[currposrow + 1][currposcol] == 1 &&
                        solveMaze(currposrow + 1, currposcol, maze, soln)) {
                        return true;
                    }

                    // the backtracking part
                    soln[currposrow][currposcol] = 0;
                    return false;
                }
            }
        }  // namespace rat_maze
    }  // namespace backtracking

    /**
     * @brief Test implementations
     * @returns void
     */
    static void test() {
        const int size = 4;
        std::array<std::array<int, size>, size> maze = {
            std::array<int, size>{1, 0, 1, 0},
            std::array<int, size>{1, 0, 1, 1},
            std::array<int, size>{1, 0, 0, 1},
            std::array<int, size>{1, 1, 1, 1}
        };

        std::array<std::array<int, size>, size> soln{};

        // Backtracking: setup matrix solution to zero
        for (int i = 0; i < size; ++i) {
            for (int j = 0; j < size; ++j) {
                soln[i][j] = 0;
            }
        }

        int currposrow = 0;  // Current position in rows
        int currposcol = 0;  // Current position in columns

        assert(backtracking::rat_maze::solveMaze<size>(currposrow, currposcol, maze,
            soln) == 1);
    }

    /**
     * @brief Main function
     * @returns 0 on exit
     */
    int main() {
        test(); // run the tests
        return 0;
    }

输出： ::

    1 0 0 0
    1 0 0 0
    1 0 0 0
    1 1 1 1

`Hamming distance <https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/bit_manipulation/hamming_distance.cpp>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++
    :linenos:
    
    /**
     * @file
     * @brief Returns the [Hamming
     * distance](https://en.wikipedia.org/wiki/Hamming_distance) between two
     * integers
     *
     * @details
     * To find hamming distance between two integers, we take their xor, which will
     * have a set bit iff those bits differ in the two numbers.
     * Hence, we return the number of such set bits.
     *
     * @author [Ravishankar Joshi](https://github.com/ravibitsgoa)
     */

    #include <cassert>   /// for assert
    #include <iostream>  /// for io operations

     /**
      * @namespace bit_manipulation
      * @brief Bit Manipulation algorithms
      */
    namespace bit_manipulation {
        /**
         * @namespace hamming_distance
         * @brief Functions for [Hamming
         * distance](https://en.wikipedia.org/wiki/Hamming_distance) implementation
         */
        namespace hamming_distance {
            /**
             * This function returns the number of set bits in the given number.
             * @param value the number of which we want to count the number of set bits.
             * @returns the number of set bits in the given number.
             */
            uint64_t bitCount(uint64_t value) {
                uint64_t count = 0;
                while (value) {       // until all bits are zero
                    if (value & 1) {  // check lower bit
                        count++;
                    }
                    value >>= 1;  // shift bits, removing lower bit
                }
                return count;
            }

            /**
             * This function returns the hamming distance between two integers.
             * @param a the first number
             * @param b the second number
             * @returns the number of bits differing between the two integers.
             */
            uint64_t hamming_distance(uint64_t a, uint64_t b) { return bitCount(a ^ b); }

            /**
             * This function returns the hamming distance between two strings.
             * @param a the first string
             * @param b the second string
             * @returns the number of characters differing between the two strings.
             */
            uint64_t hamming_distance(const std::string& a, const std::string& b) {
                assert(a.size() == b.size());
                size_t n = a.size();
                uint64_t count = 0;
                for (size_t i = 0; i < n; i++) {
                    count += (b[i] != a[i]);
                }
                return count;
            }
        }  // namespace hamming_distance
    }  // namespace bit_manipulation

    /**
     * @brief Function to the test hamming distance.
     * @returns void
     */
    static void test() {
        assert(bit_manipulation::hamming_distance::hamming_distance(11, 2) == 2);
        assert(bit_manipulation::hamming_distance::hamming_distance(2, 0) == 1);
        assert(bit_manipulation::hamming_distance::hamming_distance(11, 0) == 3);

        assert(bit_manipulation::hamming_distance::hamming_distance("1101",
            "1111") == 1);
        assert(bit_manipulation::hamming_distance::hamming_distance("1111",
            "1111") == 0);
        assert(bit_manipulation::hamming_distance::hamming_distance("0000",
            "1111") == 4);

        assert(bit_manipulation::hamming_distance::hamming_distance("alpha",
            "alphb") == 1);
        assert(bit_manipulation::hamming_distance::hamming_distance("abcd",
            "abcd") == 0);
        assert(bit_manipulation::hamming_distance::hamming_distance("dcba",
            "abcd") == 4);
    }

    /**
     * @brief Main function
     * @returns 0 on exit
     */
    int main() {
        test();           // execute the tests
        uint64_t a = 11;  // 1011 in binary
        uint64_t b = 2;   // 0010 in binary

        std::cout << "Hamming distance between " << a << " and " << b << " is "
            << bit_manipulation::hamming_distance::hamming_distance(a, b)
            << std::endl;
    }
    
输出： ::

    Hamming distance between 11 and 2 is 2

进阶
========



`Wave Function Collapse - 波函数坍缩 <https://github.com/mxgmn/WaveFunctionCollapse>`_
-----------------------------------------------------------------------------------------

.. code-block:: csharp
    :linenos:
    :caption: OverlappingModel.cs
    
    /*
    The MIT License(MIT)
    Copyright(c) mxgmn 2016.
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    The software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.
    */

    using System;
    using System.Collections.Generic;
    using System.Drawing;
    using System.Drawing.Imaging;

    internal class OverlappingModel : Model
    {
        #region 字段

        private readonly int _N;
        private readonly byte[][] _patterns;
        private readonly List<Color> _colors;
        private readonly int _ground;

        #endregion

        #region 构造函数

        /// <summary>
        /// 
        /// </summary>
        /// <param name="name">图片名称</param>
        /// <param name="N">滤波窗口大小</param>
        /// <param name="width">原图宽度</param>
        /// <param name="height">原图高度</param>
        /// <param name="periodicInput"></param>
        /// <param name="periodic"></param>
        /// <param name="symmetry"></param>
        /// <param name="ground"></param>
        public OverlappingModel(string name, int N, int width, int height, bool periodicInput, bool periodic, int symmetry, int ground) : base(width, height)
        {
            _N = N;
            _periodic = periodic;

            Bitmap bitmap = new Bitmap($"samples/{name}.png");
            int SMX = bitmap.Width, SMY = bitmap.Height;
            byte[,] sample = new byte[SMX, SMY]; // 记录原始图片中每个像素（x,y） 的颜色映射到 colors 列表中的 index
            _colors = new List<Color>(); // 记录原始图片中的颜色列表

            for (int y = 0; y < SMY; y++)
            {
                for (int x = 0; x < SMX; x++)
                {
                    Color color = bitmap.GetPixel(x, y);

                    int i = 0;
                    foreach (Color c in _colors)
                    {
                        if (c == color)
                        {
                            break;
                        }
                        i++;
                    }
                    if (i == _colors.Count)
                    {
                        _colors.Add(color);
                    }
                    sample[x, y] = (byte)i;
                }
            }

            // 输入图片中的颜色数量
            int C = _colors.Count;
            // 滤波窗口（N*N）有多少种颜色组成的可能
            long W = C.ToPower(N * N);

            byte[] pattern(Func<int, int, byte> f)
            {
                byte[] result = new byte[N * N];
                for (int y = 0; y < N; y++)
                {
                    for (int x = 0; x < N; x++)
                    {
                        result[x + y * N] = f(x, y);
                    }
                }

                return result;
            };

            // 使用滤波窗口（N*N）在原图片(SMX*SMY)中采样
            // 返回数组大小：N*N
            byte[] patternFromSample(int x, int y)
            {
                return pattern((dx, dy) => sample[(x + dx) % SMX, (y + dy) % SMY]);
            }

            // 0,1
            // 2,3
            // To
            // 1,3
            // 0,2
            // 逆时针旋转90°
            // 输入 p 的 size : N*N
            byte[] rotate(byte[] p)
            {
                return pattern((x, y) => p[N - 1 - y + x * N]);
            }

            // 0,1
            // 2,3
            // To
            // 1,0
            // 3,2
            // 左右翻转
            // 输入 p 的 size : N*N
            byte[] reflect(byte[] p)
            {
                return pattern((x, y) => p[N - 1 - x + y * N]);
            }

            // 在 N*N 的窗口中使用 C 种颜色填充共 N*N的C次方种组合
            // 输入 p 的 size : N*N
            // 返回 给定的 数据 p (N*N) 是所有可能组合中的第几个
            long index(byte[] p)
            {
                long result = 0, power = 1;
                for (int i = 0; i < p.Length; i++)
                {
                    result += p[p.Length - 1 - i] * power;
                    power *= C;
                }
                return result;
            };

            // 在 N*N 的窗口中使用 C 种颜色填充共 N*N的C次方种组合
            // 输入 ind 为 index ,即从 N*N的C次方种组合中选择第ind中输出
            // 返回 N*N
            byte[] patternFromIndex(long ind)
            {
                long residue = ind, power = W;
                byte[] result = new byte[N * N];

                for (int i = 0; i < result.Length; i++)
                {
                    power /= C;
                    int count = 0;

                    while (residue >= power)
                    {
                        residue -= power;
                        count++;
                    }

                    result[i] = (byte)count;
                }

                return result;
            };
            // 输入图片中存在的 N*N 索引列表对应出现的次数
            // key： index
            // value: count
            Dictionary<long, int> weights = new Dictionary<long, int>();
            // 输入图片中存在的 N*N 索引列表
            List<long> ordering = new List<long>();

            for (int y = 0; y < (periodicInput ? SMY : SMY - N + 1); y++)
            {
                for (int x = 0; x < (periodicInput ? SMX : SMX - N + 1); x++)
                {

                    // 对采样数据（N*N）进行处理后的8种可能情况（旋转4*翻转2）
                    byte[][] ps = new byte[8][];

                    ps[0] = patternFromSample(x, y);    // 滤波窗口采样数据
                    ps[1] = reflect(ps[0]);
                    ps[2] = rotate(ps[0]);              // 逆时针旋转90°
                    ps[3] = reflect(ps[2]);
                    ps[4] = rotate(ps[2]);              // 逆时针旋转90°*2
                    ps[5] = reflect(ps[4]);
                    ps[6] = rotate(ps[4]);              // 逆时针旋转90°*3
                    ps[7] = reflect(ps[6]);

                    for (int k = 0; k < symmetry; k++)
                    {
                        long ind = index(ps[k]);
                        if (weights.ContainsKey(ind))
                        {
                            weights[ind]++;
                        }
                        else
                        {
                            weights.Add(ind, 1);
                            ordering.Add(ind);
                        }
                    }
                }
            }

            // 对输入的图片以 N*N 窗口进行采样时，共包含几种情况
            // 小于等于N*N的C次方
            _T = weights.Count;

            _ground = (ground + _T) % _T;

            // 对输入图片进行采样后的结果：
            // _patterns: 图片中使用的所有 N*N 的 pattern
            // _weights: 图片中每种 pattern 出现的次数
            _patterns = new byte[_T][];
            _weights = new double[_T];

            int counter = 0;
            foreach (long w in ordering)
            {
                _patterns[counter] = patternFromIndex(w);
                _weights[counter] = weights[w];
                counter++;
            }

            bool agrees(byte[] p1, byte[] p2, int dx, int dy)
            {
                int xmin = dx < 0 ? 0 : dx, xmax = dx < 0 ? dx + N : N, ymin = dy < 0 ? 0 : dy, ymax = dy < 0 ? dy + N : N;
                for (int y = ymin; y < ymax; y++)
                {
                    for (int x = xmin; x < xmax; x++)
                    {
                        if (p1[x + N * y] != p2[x - dx + N * (y - dy)])
                        {
                            return false;
                        }
                    }
                }

                return true;
            };


            // 计算采样出来的 _patterns 中，两两之间是否兼容
            _propagator = new int[4][][];// 上、下、左、右
            for (int d = 0; d < 4; d++)
            {
                _propagator[d] = new int[_T][];
                for (int t = 0; t < _T; t++)
                {
                    List<int> list = new List<int>();
                    for (int t2 = 0; t2 < _T; t2++)
                    {
                        if (agrees(_patterns[t], _patterns[t2], _DX[d], _DY[d]))
                        {
                            list.Add(t2);
                        }
                    }

                    _propagator[d][t] = new int[list.Count];
                    for (int c = 0; c < list.Count; c++)
                    {
                        _propagator[d][t][c] = list[c];
                    }
                }
            }
        }

        #endregion

        #region 重写

        protected override bool OnBoundary(int x, int y) => !_periodic && (x + _N > _FMX || y + _N > _FMY || x < 0 || y < 0);

        public override Bitmap Graphics()
        {
            Bitmap result = new Bitmap(_FMX, _FMY);
            int[] bitmapData = new int[result.Height * result.Width];

            if (_observed != null)
            {
                for (int y = 0; y < _FMY; y++)
                {
                    int dy = y < _FMY - _N + 1 ? 0 : _N - 1;
                    for (int x = 0; x < _FMX; x++)
                    {
                        int dx = x < _FMX - _N + 1 ? 0 : _N - 1;
                        Color c = _colors[_patterns[_observed[x - dx + (y - dy) * _FMX]][dx + dy * _N]];
                        bitmapData[x + y * _FMX] = unchecked((int)0xff000000 | (c.R << 16) | (c.G << 8) | c.B);
                    }
                }
            }
            else
            {
                for (int i = 0; i < _wave.Length; i++)
                {
                    int contributors = 0, r = 0, g = 0, b = 0;
                    int x = i % _FMX, y = i / _FMX;

                    for (int dy = 0; dy < _N; dy++)
                    {
                        for (int dx = 0; dx < _N; dx++)
                        {
                            int sx = x - dx;
                            if (sx < 0)
                            {
                                sx += _FMX;
                            }

                            int sy = y - dy;
                            if (sy < 0)
                            {
                                sy += _FMY;
                            }

                            int s = sx + sy * _FMX;
                            if (OnBoundary(sx, sy))
                            {
                                continue;
                            }

                            for (int t = 0; t < _T; t++)
                            {
                                if (_wave[s][t])
                                {
                                    contributors++;
                                    Color color = _colors[_patterns[t][dx + dy * _N]];
                                    r += color.R;
                                    g += color.G;
                                    b += color.B;
                                }
                            }
                        }
                    }

                    bitmapData[i] = unchecked((int)0xff000000 | ((r / contributors) << 16) | ((g / contributors) << 8) | b / contributors);
                }
            }

            BitmapData bits = result.LockBits(new Rectangle(0, 0, result.Width, result.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
            System.Runtime.InteropServices.Marshal.Copy(bitmapData, 0, bits.Scan0, bitmapData.Length);
            result.UnlockBits(bits);

            return result;
        }

        protected override void Clear()
        {
            base.Clear();

            if (_ground != 0)
            {
                for (int x = 0; x < _FMX; x++)
                {
                    for (int t = 0; t < _T; t++)
                    {
                        if (t != _ground)
                        {
                            Ban(x + (_FMY - 1) * _FMX, t);
                        }
                    }

                    for (int y = 0; y < _FMY - 1; y++)
                    {
                        Ban(x + y * _FMX, _ground);
                    }
                }

                Propagate();
            }
        }

        #endregion
    }


Merkle Tree - 默克尔树
----------------------