================================================================================
C++
================================================================================

.. :

    = - ` : ' " ~ ^ _ * + # < >

    ====================
    --------------------
    ~~~~~~~~~~~~~~~~~~~~
    ********************
    ####################
    ++++++++++++++++++++

`C++ reference <https://en.cppreference.com/w/>`_
================================================================================

1 语言
--------------------------------------------------------------------------------

1.1 基本概念
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.2 关键字
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.3 预处理器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.4 表达式
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.5 声明
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.6 初始化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.7 函数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.8 语句
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.9 类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.10 重载
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.11 模板
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.12 异常
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.13 杂项
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.14 惯用手法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2 功能特性测试宏（C++20）
--------------------------------------------------------------------------------

3 语言支持库
--------------------------------------------------------------------------------

4 诊断库
--------------------------------------------------------------------------------

5 通用工具库
--------------------------------------------------------------------------------

6 字符串库
--------------------------------------------------------------------------------

C++ 字符串库支持三种通用字符串类型：

-   std::basic_string —— 为操作任何字符类型的字符串设计的模板类。
-   std::basic_string_view（C++17）—— 对于字符串子序列的轻量无所有权的只读视图。
-   空终止字符串 —— 以特殊的空字符终止的字符数组。

6.1 std::basic_string
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. graphviz::
    :caption: 标准提供 std::basic_string 对常用类型的数种特化
    :align: center

    digraph test{
        abc [shape = none, margin = 0, label = <
            <TABLE BORDER = '1' CELLBORDER = '0' CELLSPACING = '0' CELLPADDING = '8'>
            <TR><TD BGCOLOR = 'lightgray'>类型</TD><TD BGCOLOR = 'lightgray'>定义</TD></TR>
            
            <TR><TD>std::string</TD><TD>std::basic_string&lt;char&gt;</TD></TR>
            <TR><TD>std::wstring</TD><TD>std::basic_string&lt;wchar_t&gt;</TD></TR>
            <TR><TD>std::u8string（C++20 起）</TD><TD>std::basic_string&lt;char8_t&gt;</TD></TR>
            <TR><TD>std::u16string（C++11 起）</TD><TD>std::basic_string&lt;char16_t&gt;</TD></TR>
            <TR><TD>std::u32string（C++11 起）</TD><TD>std::basic_string&lt;char32_t&gt;</TD></TR>
            </TABLE>>];
    }

6.2 std::basic_string_view（C++17）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

6.3 空终止字符串
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

7 容器库
--------------------------------------------------------------------------------

7.1 顺序容器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  array
#.  vector
#.  deque
#.  forward_list（C++11 起）
#.  list

7.2 关联容器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  set
#.  map
#.  multiset
#.  multimap

7.3 无序关联容器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  unordered_set（C++11 起）
#.  unordered_map（C++11 起）
#.  unordered_multiset（C++11 起）
#.  unordered_multimap（C++11 起）

7.4 容器适配器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  stack
#.  queue
#.  priority_queue
#.  span（C++20）

8 迭代器库
--------------------------------------------------------------------------------

9 范围库（C++20）
--------------------------------------------------------------------------------

10 算法库
--------------------------------------------------------------------------------

10.1 不修改序列的操作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.2 修改序列的操作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.3 划分操作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.4 排序操作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.5 二分搜索操作（在已排序范围上）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.6 其它已排序范围上的操作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.7 集合操作（在已排序范围上）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.8 堆操作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.9 最小、最大操作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.10 比较操作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.11 排列操作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.12 数值运算
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

10.13 未初始化内存上的操做
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

11 数值库
--------------------------------------------------------------------------------

11.1 数学函数与类型
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

11.1.1 常用数学函数
********************************************************************************

11.1.2 数学特殊函数（C++17 起）
********************************************************************************

11.1.3 数学常数（C++20 起）
********************************************************************************

11.1.4 复数运算
********************************************************************************

11.1.5 数值数组
********************************************************************************

11.2 数值算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

11.2.1 因数运算
********************************************************************************

11.2.2 插值运算
********************************************************************************

11.2.3 数值运算
********************************************************************************

11.3 杂项
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

11.3.1 伪随机数生成
********************************************************************************

11.3.2 编译时有理数算术（C++11 起）
********************************************************************************

11.3.3 浮点环境（C++11 起）
********************************************************************************

11.3.4 位操纵（C++20 起）
********************************************************************************

12 输入输出库
--------------------------------------------------------------------------------

.. graphviz::
    :caption: 继承图
    :align: center

    digraph test{
        bgcolor = "transparent"
        rankdir = TB;
        node [shape="record"];
        edge [dir="back" arrowtail="empty"];
        
        subgraph cluster_0 {
            l1 [label = "ios_base"];
            
            l2 [label = "basic_ios\n\<CharT, Traits\>"];
            
            l31 [label = "basic_ostream\n\<CharT, Traits\>"];
            l32 [label = "basic_istream\n\<CharT, Traits\>"];
            
            l4 [label = "basic_iostream\n\<CharT, Traits\>"];
            
            l51 [label = "basic_ostringstream\n\<CharT, Traits\>"];
            l52 [label = "basic_stringstream\n\<CharT, Traits\>"];
            l53 [label = "basic_istringstream\n\<CharT, Traits\>"];
            
            l61 [label = "basic_oftringstream\n\<CharT, Traits\>"];
            l62 [label = "basic_fstream\n\<CharT, Traits\>"];
            l63 [label = "basic_ifstream\n\<CharT, Traits\>"];

            l1->l2;
            l2->{l31 l32};
            {l31 l32}->l4;
            
            l31->l51;
            l31->l61:ne;
            
            l4->l52;
            l4->l62:ne;
            
            l32->{l53 l63};
            
            l4 -> l51 [color = "transparent"];
            l4 -> l53 [color = "transparent"];
            
            l51 -> l61 [color = "transparent"];
            l52 -> l62 [color = "transparent"];
            l53 -> l63 [color = "transparent"];
        }
    }

13 文件系统库
--------------------------------------------------------------------------------

14 本地化库
--------------------------------------------------------------------------------

15 正则表达式库（C++11）
--------------------------------------------------------------------------------

16 原子操作库（C++11）
--------------------------------------------------------------------------------

17 线程支持库（C++11）
--------------------------------------------------------------------------------

C++ Primer, Fifth Edition
================================================================================

C++ 11 的新特性
--------------------------------------------------------------------------------

-   long long 类型
-   列表初始化
-   nullptr 常量
-   constexpr 变量
-   类型别名声明
-   auto 类型指示符
-   decltype 类型指示符
-   类内初始化
-   使用 auto 或 decltype 缩写类型
-   范围 for 语句
-   定义 vector 对象的vector
-   vector 对象的列表初始化
-   容器的 cbegin 和 cend 函数
-   标准库的 begin 和 end 函数
-   使用 auto 和 decltype 简化声明
-   除法的舍入规则
-   用大括号包围的值列表赋值
-   将 sizeof 用于类成员
-   范围 for 语句
-   标准库 initializer_list 类
-   列表初始化返回值
-   定义尾置返回类型
-   使用 decltype 简化返回类型定义
-   constexpr 函数
-   用 string 对象处理文件名
-   array 和 forward_list 容器
-   容器的 cbegin 和 cend 函数
-   容器的列表初始化
-   容器的非成员函数 swap
-   容器 insert 成员的返回类型
-   容器的 emplace 成员
-   shrink_to_fit
-   string 的数值转换函数
-   lambda 表达式
-   lambda 表达式中的尾置返回类型
-   标准库 bind 函数
-   关联容器的列表初始化
-   列表初始化 pair 的返回类型
-   pair 的列表初始化
-   无序容器
-   智能指针
-   shared_ptr 类
-   动态分配对象的列表初始化
-   auto 和动态分配
-   unique_ptr 类
-   weak_ptr 类
-   范围 for 语句不能应用于动态分配数组
-   动态分配数组的列表初始化
-   auto 不能用于分配数组
-   allocator::construct 可使用任意构造函数
-   将=default 用于拷贝控制成员
-   使用=delete 阻止拷贝类对象
-   用移动类对象代替拷贝类对象
-   右值引用
-   标准库 move 函数
-   移动构造函数和移动赋值
-   移动构造函数通常应该是 noexcept
-   移动迭代器
-   引用限定成员函数
-   function 类模板
-   explicit 类型转换运算符
-   虚函数的 override 指示符
-   通过定义类为 final 来阻止继承
-   虚函数的 override 和 final 指示符
-   删除的拷贝控制和继承
-   继承的构造函数
-   声明模板类型形参为友元
-   模板类型别名
-   模板函数的默认模板参数
-   实例化的显示控制
-   模板函数与尾置返回类型
-   引用折叠规则
-   用 static_cast 将左值转换为右值
-   标准库 forward 函数
-   可变参数模板
-   sizeof...运算符
-   可变参数模板与转发
-   标准库 tuple 类模板
-   新的 bitset 运算
-   正则表达式库
-   随机数库
-   浮点数格式控制
-   noexcept 异常指示符
-   noexcept 运算符
-   内联命名空间
-   继承的构造函数与多重继承
-   有作用域的 enum
-   说明类型用于保存 enum 对象
-   enum 的前置声明
-   标准库 eme_fn 类模板
-   类类型的 union 成员


第Ⅰ部分 C++基础
--------------------------------------------------------------------------------

第2章 变量和基本类型
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.1 基本内置类型
********************************************************************************

C++ 定义了一套包括 **算术类型** 和 **空类型（void）** 在内的基本数据类型。其中，
算术类型包含了布尔值（布尔类型）、整型数（整型）、字符（整型）和浮点数（浮点型）。
空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时
使用空类型作为返回类型。

2.1.1 算术类型
################################################################################

算术类型分为两类： **整型** 和 **浮点型**。

算术类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别。下表列出了
C++ 标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。

.. graphviz::
    :caption: C++ 算术类型
    :align: center

    digraph test{
        abc [shape = none, margin = 0, label = <
            <TABLE BORDER = '1' CELLBORDER = '0' CELLSPACING = '0' CELLPADDING = '8'>
            <TR><TD BGCOLOR = 'lightgray'>类型</TD><TD BGCOLOR = 'lightgray'>含义</TD><TD BGCOLOR = 'lightgray'>最小尺寸</TD></TR>
            
            <TR><TD>bool</TD><TD>布尔类型 [整型]</TD><TD>未定义</TD></TR>

            <TR><TD>char</TD><TD>字符 [整型] [有无符号的]</TD><TD>8 位</TD></TR>
            <TR><TD>wchar_t</TD><TD>宽字符 [整型]</TD><TD>16 位</TD></TR>
            <TR><TD>char16_t</TD><TD>Unicode 字符 [整型]</TD><TD>16 位</TD></TR>
            <TR><TD>char32_t</TD><TD>Unicode 字符 [整型]</TD><TD>32 位</TD></TR>

            <TR><TD>short</TD><TD>短整型 [整型] [有无符号的]</TD><TD>16 位</TD></TR>
            <TR><TD>int</TD><TD>整型 [整型] [有无符号的]</TD><TD>16 位</TD></TR>
            <TR><TD>long</TD><TD>长整型 [整型] [有无符号的]</TD><TD>32 位</TD></TR>
            <TR><TD>long long</TD><TD>长整型 [整型] [有无符号的]（C++11）</TD><TD>64 位</TD></TR>

            <TR><TD>float</TD><TD>单精度浮点数 [浮点型]</TD><TD>6 位有效数字</TD></TR>
            <TR><TD>double</TD><TD>双精度浮点数 [浮点型]</TD><TD>10 位有效数字</TD></TR>
            <TR><TD>long double</TD><TD>扩展精度浮点数 [浮点型]</TD><TD>10 位有效数字</TD></TR>
            </TABLE>>];
    }

-   布尔类型的取值是真（true）或者假（false）。
-   基本的字符类型 char ，一个 char 的空间应确保可以存放机器基本字符集中任意字符
    对应的数字值。也就是说，一个 char 的大小和一个机器字节一样。
-   其他字符类型用于扩展字符集：
    
        -   wchar_t：用于确保可以存放机器最大扩展字符集中的任意一个字符。
        -   char16_t 和 char32_t：为 Unicode 字符集服务（ Unicode 是用于表示所有
            自然语言中字符的标准）。

-   除字符和布尔类型之外，其他整型用于表示（可能）不同尺寸的整数。C++ 语言规定一
    个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个
    long long 至少和一个 long 一样大（long long >= long >= int >= int >= short）。

.. Note::

    计算机以比特序列存储数据，大多数计算机以2的整数次幂个比特作为块来处理内存，可
    寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由
    几个字节组成。

    大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。

.. Note::

    C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。
    通常，float 以 1 个字（32 比特）来表示，double 以 2 个字（64 比特）来表示，
    long double 以 3 或 4 个字（96 或 128 比特）来表示。

    一般来说，float 和 double 分别有 7 和 16 个有效位；类型 long double 的具体实
    现不同，精度也各不相同。

带符号类型和无符号类型
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

除去布尔类型和扩展的字符型之外，其他整型可以划分为 **带符号的（signed）** 和
**无符号的（unsigned）** 两种。带符号的类型可以表示正数、负数或 0，无符号类型则
仅能表示大于等于 0 的值。

类型 short、int、long 和 long long 都是带符号的，通过在这些类型名前添加 unsigned
就可以得到无符号的类型。类型 unsigned int 可以缩写为 unsigned 。

与其他整型不同，字符型被划分为了三种：char、signed char 和 unsigned char。尽管字
符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型 char 实际上会
表现为上述两种形式中的一种，具体是哪种由编译器决定。

2.1.2 类型转换
################################################################################

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就
是将对象从一种给定的类型 **转换（convert）** 为另一种相关类型。

.. code-block:: c++

    bool b = 42;            // b 为真
    int i = b;              // i 的值为 1
    i = 3.14;               // i 的值为 3
    double pi = i;          // pi 的值为 3.0
    unsigned char c = -1;   // 假设 c 占 8 比特，c 的值为 255 —— (-1) % 256 = 255
    char c2 = 256;          // 假设 c 占 8 比特，c2 的值是未定义的 —— 赋给带符号
                            // 类型一个超出它表示范围的值时，结果是未定义的（undefined）。

.. Warning::

    赋给带符号类型一个超出它表示范围的值时，结果是 **未定义的（undefined）** 。

含有无符号类型的表达式
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

当一个算术表达式中既有无符号数又有 int 时，那个 int 值就会转换成无符号数。把 int 
转换成无符号数的过程和把 int 直接赋给无符号变量一样。

.. code-block:: c++

    unsigned  u = 10;
    int i = -42;
    std::cout << i + i << std::endl;    // 输出 -84
    std::cout << u + i << std::endl;    // 如果 int 占 32 位，输出 4294967264 —— (-32) % (2^32)

    unsigned u1 = 42, u2 = 10;
    std::cout << u1 - u2 << std::endl;  // 正确，输出 32
    std::cout << u2 - u1 << std::endl;  // 正确，不过结果是取模后的值 4294967264 —— (-32) % (2^32)

2.1.3 字面值常量
################################################################################

一个形如 42 的值被称作 **字面值常量（literal）** 。每个字面值常量都对应一种数据
类型，字面值常量的 **形式** 和 **值** 决定了它的 **数据类型** 。

整型和浮点型字面值
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

.. code-block:: c++

    int i1 = 20;        // 使用十进制来表示十进制数 20
    int i2 = 024;       // 使用八进制（以 0 开头）来表示十进制数 20
    int i3 = 0x14;      // 使用十六进制（以 0x 或 0X 开头）来表示十进制数 20

-   整型字面值具体的数据类型由它的 **值** 和 **符号** 决定。

    -   默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也
        可能是无符号的。
    
            #.  十进制字面值的类型是 int 、 long 和 long long 中尺寸最小的那个，前提
                是这种类型要能容纳下当前的值。
            #.  八进制和十六进制字面值的类型是能容纳其数值的 int 、 unsigned int 、 
                long 、 unsigned long 、 long long 和 unsigned long long 中尺寸最小者。

    -   如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。
    -   类型 short 没有对应的字面值。
    
    .. Note::

        尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是
        负数。如果我们使用了一个形如 -42 的负十进制字面值，那个符号并不在字面值
        之内，它的作用仅仅是对字面值取负而已。

-   浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 E 或 e 标识：
    
        -   3.14159
        -   3.14159E0
        -   0.
        -   0e0
        -   .001

    默认的，浮点型字面值是一个 double 数据类型。
    

字符和字符串字面值
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

.. code-block:: c++

    'a'             // 字符字面值
    "Hello World!"  // 字符串字面值

.. Warning::

    字符串此面值的类型实际上是由常量字符构成的数组（array）。编译器在每个字符串
    的结尾处添加一个 **空字符（'\\0'）** ，因此，字符串字面值的实际长度要比它的内
    容多 1 。
    
.. Note::
    
    如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个
    整体。
    
    .. code-block:: c++

        // 分多行书写的字符串字面值
        std::cout << "a really, really long string literal "
                     "that spans two lines";

转义序列
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

有两类字符程序员不能直接使用：

    #.  **不可打印（nonprintable）** 的字符，如退格或其他控制字符。
    #.  在 C++ 语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。

在这些情况下需要用到  **转义序列（escape sequence）** ，转义序列均以反斜线作为开
始，C++ 语言规定的转义序列包括：

    -   换行符 ``\n``
    -   横向制表符 ``\t``
    -   报警（响铃）符 ``\a``
    -   纵向制表符 ``\v``
    -   退格符 ``\b``
    -   双引号 ``\"``
    -   反斜线 ``\\``
    -   问号 ``\?``
    -   单引号 ``\'``
    -   回车符 ``\r``
    -   进纸符 ``\f``

.. Note::
    
    在程序中，上述转义序列被当作一个字符使用。

我们也可以使用 **泛化的转义序列** ，其形式是 ``\x`` 后紧跟 1 个或多个十六进制数
字，或者 ``\`` 后紧跟 1 个、2 个或 3 个八进制数字， *其中数字部分表示的是字符对应
的数值。*

假设使用的是 Latin-1 字符集，以下是一些示例：

    -   ``\7`` （响铃）
    -   ``\12`` （换行符）
    -   ``\40`` （空格）
    -   ``\0`` （空字符）
    -   ``\115`` （字符 M）
    -   ``\x4d`` （字符 M）

.. Warning::

    如果反斜线 ``\`` 后面跟着的八进制数字超过 3 个，只有前 3 个数字与 ``\`` 构成
    转义序列。

    相反， ``\x`` 要用到后面跟着的所有数字。例如， ``\xx1234`` 表示一个 16 位的
    字符，该字符由这 4 个十六进制数所对应的比特唯一确定。因为大多数机器的 char 
    型数据占 8 位，所以上面这个例子可能会报错。一般来说，超过 8 位的十六进制字符
    都与某个扩展字符集一起使用的。
    

指定字面值的类型
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

.. graphviz::
    :caption: 指定字面值的类型 - 字符和字符串字面值
    :align: center

    digraph test{
        abc [shape = none, margin = 0, label = <
            <TABLE BORDER = '1' CELLBORDER = '0' CELLSPACING = '0' CELLPADDING = '8'>
            <TR><TD BGCOLOR = 'lightgray'>前缀</TD><TD BGCOLOR = 'lightgray'>含义</TD><TD BGCOLOR = 'lightgray'>类型</TD></TR>
            
            <TR><TD>u</TD><TD>Unicode 16 字符</TD><TD>char_16</TD></TR>
            <TR><TD>U</TD><TD>Unicode 32 字符</TD><TD>char_32</TD></TR>
            <TR><TD>L</TD><TD>宽字符</TD><TD>wchar_16</TD></TR>
            <TR><TD>u8</TD><TD>UTF-8（仅用于字符串字面常量）</TD><TD>char</TD></TR>
            </TABLE>>];
    }


.. graphviz::
    :caption: 指定字面值的类型 - 整型字面值
    :align: center

    digraph test{
        abc [shape = none, margin = 0, label = <
            <TABLE BORDER = '1' CELLBORDER = '0' CELLSPACING = '0' CELLPADDING = '8'>
            <TR><TD BGCOLOR = 'lightgray'>后缀</TD><TD BGCOLOR = 'lightgray'>最小匹配类型</TD></TR>
            
            <TR><TD>u or U</TD><TD>unsigned</TD></TR>
            <TR><TD>l or L</TD><TD>long</TD></TR>
            <TR><TD>ll or LL</TD><TD>long long</TD></TR>
            </TABLE>>];
    }

.. graphviz::
    :caption: 指定字面值的类型 - 浮点型字面值
    :align: center

    digraph test{
        abc [shape = none, margin = 0, label = <
            <TABLE BORDER = '1' CELLBORDER = '0' CELLSPACING = '0' CELLPADDING = '8'>
            <TR><TD BGCOLOR = 'lightgray'>后缀</TD><TD BGCOLOR = 'lightgray'>类型</TD></TR>
            
            <TR><TD>f or F</TD><TD>float</TD></TR>
            <TR><TD>l or L</TD><TD>long double</TD></TR>
            </TABLE>>];
    }

通过上面表中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

.. code-block:: c++

    L'a'        // 宽字符型字面值，类型是 wchar_t
    u8"hi"      // utf-8 字符串字面值（utf-8 用 8 位编码一个 unicode 字符）
    42ULL       // 无符号整型字面值，类型是 unsigned long long
    1E-3F       // 单精度浮点型字面值，类型是 float
    3.14159L    // 扩展精度浮点型字面值，类型是 long double

布尔字面值和指针字面值
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

true 和 false 是布尔类型字面值，nullptr 是指针字面值。
 
2.2 变量
********************************************************************************


2.2.1 变量定义
################################################################################


变量定义的基本形式是：首先是 **类型说明符（type specifier）**，随后紧跟一个或多
个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。

当对象在创建时获得了一个特定的值，我们说这个对象被 **初始化（initialized）** 了。

.. Warning::

    初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对
    象的当前值擦除，而以一个新值来替代。

用花括号来初始化变量的形式称为 **列表初始化（list initialization）** 。

如果定义变量时没有指定初始值，则变量被 **默认初始化（default initialized）** ，
此时变量被赋予了 “默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置对
此也会由影响。

    -   定义在函数体之外的未被显示初始化的内置类型变量，被初始化为 0 。
    -   定义在函数体之内的未被显示初始化的内置类型变量，将不被初始化（uninitialized） 。
        一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问
        此类值将引发错误。
    -   每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由
        类自己决定。

.. Note::
    
    定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有
    被显示的初始化，则其值由类确定。

2.2.2 变量声明和定义的关系
################################################################################

**声明（declaration）** 使得名字为程序所知，一个文件如果想使用别处定义的名字则必
须包含对那个名字的声明。

**定义（definition）** 负责创建与名字关联的试体。

变量声明规定了变量的类型和名字，定义在此之外还申请存储空间，也可能为变量赋一个初
始值。

.. code-block:: c++

    extern int i;   // 声明 i 而非定义 i
    int j;          // 声明并定义 j
    extern double pi = 3.1416;          // 定义，抵消了 extern 的作用

.. Warning::

    在函数体内部，如果试图初始化一个由 extern 关键字标记的变量，将引发错误。

    变量能且只能被定义一次，但是可以被多次声明。

2.2.3 标识符
################################################################################

2.2.4 名字的作用域
################################################################################

**作用域（scope）** 是程序的一部分，在其中名字有其特定的含义。C++ 语言中大多数作
用域都已花括号分隔。

名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

函数 main 和其它大多数定义在函数体之外的名字一样拥有 **全局作用域（global scope）**.

函数体之内定义的变量拥有 **块作用域（block scope）** 。

使用 ``::variableName`` 访问全局作用域的变量。

2.3 复合类型
********************************************************************************

**复合类型（compound type）** 是指基于其他类型定义的类型。C++ 语言有几种复合类型，
本章将介绍其中的两种：引用和指针。

关于变量声明更通用的描述应该是：一条声明语句由一个 **基本数据类型（base type）**
和紧随其后的一个 **声明符（declarator）** 列表组成。每个声明符命名了一个变量并指
定该变量为与基本数据类型有关的某种类型。

2.3.1 引用
################################################################################

.. Note::
    
    C++ 11 中新增了一种引用——右值引用（rvalue reference），严格来说，当我们使用
    术语“引用（reference）”时，指的其实是“左值引用（lvalue reference）”。

**引用（reference）** 给对象起了另外一个名字，引用类型引用（refers to）另外一种
类型。通过将 **声明符** 写成 &d 的形式来定义引用类型，其中 d 是声明的变量名。

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它
的初始值 **绑定（bind）** 在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用
将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用
必须初始化。

.. Note::
    
    引用并非对象，相反，它只是为一个已存在的对象所起的另外一个名字。

    因为引用本身不是一个对象，所以不能定义引用的引用。


除以下 **两种** 情况外，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引
用只能绑定到 **对象** 上，而不能与 **字面值** 或某个 **表达式的计算结果** 绑定在
一起：

    #.  在初始化 **常量引用** 时允许用 **任意表达式** 作为初始值，只要该表达式的
        结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定 **非常量的对象** 、
        **字面值** ，甚至是个 **一般表达式** ：

            .. code-block:: c++

                int i = 42;
                const int &r1 =  i;         //  允许将 const int& 绑定到一个普通 int 对象上
                const int &r2 =  42;        //  正确：r2 是一个常量引用
                const int &r3 =  r1 * 2;    //  正确：r3 是一个常量引用
                int &r4 =  r1 * 2;          //  错误：r4 是一个普通的非常量引用

    #.  待阅读

2.3.2 指针
################################################################################

**指针（pointer）** 是“指向（point to）”另外一种类型的复合类型。与引用类似，指针
也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。

    #.  指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以
        先后指向几个不同的对象。
    #.  指针无须在定义时赋值。和其他内置类型一样，在块作用域内定义的指针如果没有
        被初始化，也将拥有一个不确定的值。

定义指针类型的方法是将声明符写成 *d 的形式，其中 d 是变量名。

指针存放某个对象的地址，使用 **取地址符（操作符 &）** 获取该地址。

引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除以下了 **两种** 情况外，其他所有指针的类型都要和它所指向的对象严格匹配：

    #.  允许一个指向常量的指针指向非常量：

            .. code-block:: c++

                double dval = 3.14;
                const double *cptr = &dval;

    #.  待阅读

如果指针指向了一个对象，则允许使用 **解引用符（操作符 *）** 来访问该对象。

**空指针（null pointer）** 不指向任何对象，在试图使用一个指针之前代码可以首先检
查它是否为空。以下为生成空指针的方法：

    .. code-block:: c++

        int *p1 = nullptr;          // 等价于 int *p1 = 0;
        int *p2 = 0;                // 直接将 p2 初始化为字面常量 0
        // 需要 #include<cstdlib>
        int *p3 = NULL;             // 等价于 int *p3 = 0;

.. Warning::

    把 int 变量直接赋给指针是错误的操作，即使 int 变量的值恰好等于 0 也不行：

    .. code-block:: c++

        int zero = 0;
        int* p = zero;              // 错误：不能把 int 变量直接赋给指针

任何非 0 指针对应的条件值都是 true 。

**void*** 是一种特殊的指针类型，可用于存放任意对象的地址。

2.3.3 理解符合类型的声明
################################################################################

.. code-block:: c++

    // i 是一个 int 型的数，p 是一个 int 型指针，r 是一个 int 型引用
    int i = 1024, *p = &i, &r = i;

**表示指向指针的指针，***表示指向指针的指针的指针。

引用本身不是对象，因此不存在指向引用的指针。但是指针是对象，所以存在指向指针的引
用：

.. code-block:: c++

    int i = 42;
    int *p;         // p 是一个指向 int 的指针
    int *&r = p;    // r 是一个对指针 p 的引用

    r = &i;         // r 引用了一个指针，因此给 r 赋值 &i 就是令 p 指向 i
    *r = 0;         // 解引用 r 得到 i，也就是 p 指向的对象，将 i 的值改为 0

2.4 const 限定符
********************************************************************************

因为 const 对象一旦创建后其值就不能在改变，所以 const 对象必须初始化：

    .. code-block:: c++

        const int i = get_size();       // 正确：运行时初始化
        const int j = 42;               // 正确：编译时初始化
        const int k;                    // 错误：k 是一个为经初始化的常量

对象的类型决定了其上的操作，与非 const 类型所能参与的操作相比，const 类型的对象
能完成其中大部分，但也不是所有的操作都合适。主要的限制就是只能在 const 类型的对
象上执行 **不改变其内容** 的操作。

在不改变 const 对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对
象，则它们是不是 const 都无关紧要：

        .. code-block:: c++

            int i = 42;
            const int ci = i;       // 正确：i 的值被拷贝给了 ci
            int j = ci;             // 正确：ci 的值被拷贝给了 j


**默认状态下，const 对象仅在文件内有效。**

.. Note::
    
    如果想在多个文件之间共享 cosnt 对象，必须在变量的定义之前添加 extern 关键字。

2.4.1 const 的引用
################################################################################

.. code-block:: c++

    double dval = 3.14;
    const int& ri = dval;

为了让 ri 绑定到一个整数，编译器把上述代码变成了如下形式：

.. code-block:: c++

    double dval = 3.14;
    const int temp = dval;  // 由双精度浮点数生成一个临时的整型常量
    const int& ri = temp;   // 让 ri 绑定到这个临时量

在这种情况下，ri 绑定了一个 **临时量（tempory）** 对象。所谓临时量对象，就是当编
译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。

常量引用仅对引用 **可参与的操作** 做出了限定，对于引用的对象本身是不是一个常量未
作限定。

2.4.2 指针和 const
################################################################################

**指向常量的指针（pointer to const）** 不能用于改变其所指对象的值。

允许令一个指向常量的指针指向一个非常量对象。

const 指针
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。 **常量
指针（const pointer）** 必须初始化，而且一旦初始化，则它的值（也就是存放在指针中
那个地址）就不能再改变了。

把 **\*** 放在 const 关键字之前用以说明指针是一个常量。


2.4.3 顶层 const
################################################################################

顶层 const 可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、
指针等。

底层 const 则与指针和引用等复合类型的基本类型部分有关。

2.4.4 constexpr 和常量表达式
################################################################################

**常量表达式** 是指 **值不会改变** 并且 **在编译过程** 就能得到计算结果的表达式。

-   字面值属于常量表达式。
-   用常量表达式初始化的 const 对象也是常量表达式。

.. Note::
    
    一个对象（或表达式）是不是常量表达式由它的 **数据类型** 和 **初始值** 共同决
    定。

constexpr 变量
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

由于在一个复杂的系统中，很难（几乎肯定不能）分辨一个初始值是不是常量表达式。尽管
可以定义一个 const 变量并把它的初始值设为 **我们认为的某个常量表达式** ，但在实
际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。

C++ 11 新标准规定，允许将变量声明为 **constexpr** 类型以便由编译器来验证变量的值
是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达
式初始化。

尽管不能使用普通函数作为 constexpr 变量的初始值，但是新标准允许定义一种特殊的
**constexpr 函数** 。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能
使用 constexpr 函数去初始化 constexpr 变量了。

.. Note::

    一般来说，如果你认定变量是一个常量表达式，那就把它声明成 constexpr 类型。

2.5 处理类型
********************************************************************************

2.5.1 类型别名
################################################################################

**类型别名（type alias）** 是一个名字，它是某种类型的同义词。

定义类型别名的两种方式：

    -   使用关键字 **typedef**：

        .. code-block:: c++

            typedef double wages;       // wages 是 double 的同义词
            typedef wages base, *p;     // base 是 double 的同义词，p 是 double* 的同义词

        其中，关键字 typedef 作为声明语句中的基本数据类型的一部分出现。
        
        含有 typedef 的声明语句定义的不再是变量而是类型别名。

        这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。

    -   使用 **别名声明（alias declaration）**

        .. code-block:: c++

            using SI = Sales_item;      // SI 是 Sales_item 的同义词

        使用关键字 using 作为声明的开始，其作用是把等号左侧的名字规定成等号右侧
        的类型的别名。

        类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。

指针、常量和类型别名
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

如果某个类型别名指代的是 **复合类型** 或 **常量** ，那么把它们用到声明语句里就会
产生意想不到的后果。

    .. code-block:: c++

        typedef char *pstring;
        const pstring cstr = 0;     // cstr 是指向 char 的常量指针
        const pstring *ps;          //  ps 是一个指针，它的对象是指向 char 的常量指针

上述两条声明语句的基本数据类型都是 const pstring ， 和过去一样， **const 是对给
定类型的修饰** 。pstring 实际上是指向 char 的指针，因此，const pstring 就是指向
char 的常量指针，而非指向常量字符的指针。

    .. code-block:: c++

        const char *cstr = 0;   // 是对 const pstring cstr 的错误理解

声明语句中用到 pstring 时，其基本数据类型是指针。可是用 char * 重写了声明语句后，
数据类型就变成了 char ，* 成了声明符的一部分。这样改写的结果是，const char 成了
基本数据类型。前后两种声明含义截然不同，前者声明了一个指向 char 的常量指针，改写
后的形式则声明了一个指向 const char 的指针。

2.5.2 auto 类型说明符
################################################################################

C++ 11 新标准引入了 **auto** 类型说明符，auto 让编译器通过初始值来推算变量的类型。
显然， auto 定义的变量必须有初始值。

使用 auto 也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，
所以该语句中的所有变量的初始基本数据类型都必须一样。

复合类型、常量和 auto
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

编译器推断出来的 auto 类型有时候和初始值的类型并不完全一样，编译器会适当地改变结
果类型使其更符合初始化规则。


2.5.3 decltype 类型指示符
################################################################################

2.6 自定义数据结构
********************************************************************************

第3章 字符串、向量和数组
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第4章 表达式 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第5章 语句 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第6章 函数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第7章 类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第Ⅱ部分 C++标准库
--------------------------------------------------------------------------------

第8章 IO库
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第9章 顺序容器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第10章 泛型算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第11章 关联容器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第12章 动态内存
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第Ⅲ部分 类设计者的工具
--------------------------------------------------------------------------------

第13章 拷贝控制
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第14章 重载运算与类型转换
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第15章 面向对象程序设计
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第16章 模板与泛型编程
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第Ⅳ部分 高级主题
--------------------------------------------------------------------------------

第17章 标准库特殊设施
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第18章 用于大型程序的工具
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第19章 特殊工具与技术
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`C++ Tutorial <http://www.cplusplus.com/doc/tutorial/>`_
================================================================================

个人总结
================================================================================

预处理器（preprocessor）
--------------------------------------------------------------------------------

1. 预处理器指令（ `Preprocessor directives <https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives?view=msvc-160>`_ ）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

预处理器指令，如 ``#define`` 和 ``#ifdef`` ，通常用于使源程序易于更改和易于在不同的执
行环境中编译。源文件中的指令告诉预处理器采取特定的操作。例如，预处理器可以替换文本中的标
记，将其他文件的内容插入到源文件中，或者通过删除部分文本来跳过该部分文件的编译。识别并执
行预处理器行发生在宏展开之前。因此，如果一个宏展开成类似预处理器命令的东西，预处理器将不
会识别它。

预处理语句使用与源文件语句相同的字符集，但不支持转义序列。预处理语句中使用的字符集与执行
字符集相同。预处理程序还能识别负的字符值。

预处理器识别以下指令:

    #.  :ref:`#define <src/C++:1.1 #define>`
    #.  :ref:`#error <src/C++:1.2 #error>`
    #.  :ref:`#import <src/C++:1.3 #import>`
    #.  :ref:`#pragma <src/C++:1.4 #pragma>`
    #.  :ref:`#elif <src/C++:1.5 #elif>`
    #.  :ref:`#if <src/C++:1.6 #if>`
    #.  :ref:`#include <src/C++:1.7 #include>`
    #.  :ref:`#undef <src/C++:1.8 #undef>`
    #.  :ref:`#else <src/C++:1.9 #else>`
    #.  :ref:`#ifdef <src/C++:1.10 #ifdef>`
    #.  :ref:`#line <src/C++:1.11 #line>`
    #.  :ref:`#using <src/C++:1.12 #using>`
    #.  :ref:`#endif <src/C++:1.13 #endif>`
    #.  :ref:`#ifndef <src/C++:1.14 #ifndef>`
   
数字符号（ ``#`` ）必须是包含指令的行上的第一个非空格字符。空格字符可以出现在指令的数字
符号和第一个字母之间。某些指令包含参数或值。指令后面的任何文本（作为指令一部分的参数或值
除外）必须被注释起来（以单行注释分隔符 ``//`` 开头，或用注释分隔符 ``/**/`` 括起来）。
包含预处理器指令的行可以通过在行尾标记前面加反斜杠（ ``\`` ）来继续。

*预处理器指令可以出现在源文件的任何地方，但它们只在源文件中其出现以后的代码中生效。*

1.1 #define
********************************************************************************

``#define`` 创建宏，宏是 **标识符** (或参数化标识符)与 **标记字符串** （token string）
的关联。定义宏后，编译器可以用 **标记字符串** 替换源文件中 **标识符** 的每次出现。


语法：

.. code-block:: c++

    #define identifier token-string_opt
    #define identifier ( identifier_opt, ... , identifier_opt ) token-string_opt


没有标记字符串的 ``#define`` 将从源文件中删除出现的标识符。该标识符仍然是已定义的，可以
使用 ``#if defined`` 和 ``#ifdef`` 指令进行测试。

1.2 #error
********************************************************************************

``#error`` 指令在编译时发出用户指定的错误消息，然后终止编译。

此指令发出的错误消息包含标记字符串参数。标记字符串参数 *不会进行宏展开* 。此指令在预处
理期间最有用，用于通知开发人员程序不一致或违反约束。以下示例演示预处理期间的错误处理：

.. code-block:: c++

    #if !defined(__cplusplus)
    #error C++ compiler required.
    #endif

1.3 #import
********************************************************************************

1.4 #pragma
********************************************************************************

Pragma指令指定特定于机器或特定于操作系统的编译器特性。 ``__pragma`` 关键字是特定
于Microsoft编译器的，它允许你在宏定义中编写pragma指令。C99中引入了标准的
``_Pragma`` 预处理操作符，并被 C++ 11采用。

语法：

.. code-block:: c++

    #pragma token-string
    __pragma( token-string )    // two leading underscores - Microsoft specific extension
    _Pragma( string-literal )   // C99

C和C++的每个实现都支持其主机或操作系统特有的一些特性。例如，有些程序必须精确控制
数据在内存中的位置，或控制某些函数接收参数的方式。 ``#pragma`` 指令支持让每个编
译器提供特定于机器和操作系统的特性，同时保持与C和c++语言的整体兼容性。

根据定义，Pragma指令是特定于机器或特定于操作系统的，并且对于每个编译器通常是不同
的。Pragma可以用在条件指令中，以提供新的预处理器功能。或者，使用一个来向编译器提
供实现定义的信息。

标记字符串（ *token-string* ）用于表示特定于编译器的指令和参数(如果有的话)的一系
列字符。数字符号( ``#`` )必须是包含pragma指令的行中的第一个非空白字符。空白字符
可以分隔数字符号和单词“pragma”。在 ``#pragma`` 之后，编写可以被翻译程序当作预处
理标记（preprocessing tokens）进行解析的任何文本。 ``#pragma`` 指令的参数受宏扩
展的影响。

*string-literal* 是 ``_Pragma`` 的输入。删除外部引号和前/后空格。 ``\"`` 被替换
为 ``"`` ， ``\\`` 被替换为 ``\`` 。

当编译器发现无法识别的 pragma 时，会发出警告，并继续编译。

The Microsoft C and C++ compilers recognize the following pragma directives:

    #.  alloc_text
    #.  detect_mismatch
    #.  intrinsic
    #.  pop_macro
    #.  auto_inline
    #.  endregion
    #.  loop
    #.  push_macro
    #.  bss_seg
    #.  fenv_access
    #.  make_public
    #.  region
    #.  check_stack
    #.  float_control
    #.  managed
    #.  runtime_checks
    #.  code_seg
    #.  fp_contract
    #.  message
    #.  section
    #.  comment
    #.  function
    #.  omp
    #.  setlocale
    #.  component
    #.  hdrstop
    #.  once
    #.  strict_gs_check
    #.  conform
    #.  include_alias
    #.  optimize
    #.  unmanaged
    #.  const_seg
    #.  init_seg
    #.  pack
    #.  vtordisp
    #.  data_seg
    #.  inline_depth
    #.  pointers_to_members
    #.  warning
    #.  deprecated
    #.  line_recursion

Pragma指令和编译器选项
################################################################################

一些 pragma 指令提供与编译器选项相同的功能。当在源代码中到达一个 pragma 时，它将
覆盖编译器选项指定的行为。例如，如果在编译器选项中指定了 */Zp8* ，你可以用
*pack* 覆盖特定代码段的编译器设置:

.. code-block:: bat

    cl /Zp8 some_file.cpp

.. code-block:: c++

    // some_file.cpp - packing is 8
    // ...
    #pragma pack(push, 1) - packing is now 1
    // ...
    #pragma pack(pop) - packing is 8 again
    // ...

__pragma() 关键字
################################################################################

编译器还支持特定于Microsoft的 ``__pragma`` 关键字，该关键字的功能与 ``#pragma`` 
指令相同。不同的是， ``__pragma`` 关键字可以在宏定义中内联使用。 ``#pragma`` 指
令在宏定义中不可用，因为编译器将指令中的数字符号字符（ *#* ）解释为 `Stringizing operator (#) <https://docs.microsoft.com/en-us/cpp/preprocessor/stringizing-operator-hash?view=msvc-160>`_ 。

下面的代码示例演示了如何在宏中使用 ``__pragma`` 关键字。这段代码摘自
"Compiler COM Support Samples"中的ACDUAL示例中的 *mfcdul .h* 头文件:

    .. code-block:: c++

        #define CATCH_ALL_DUAL \
        CATCH(COleException, e) \
        { \
        _hr = e->m_sc; \
        } \
        AND_CATCH_ALL(e) \
        { \
        __pragma(warning(push)) \
        __pragma(warning(disable:6246)) /*disable _ctlState prefast warning*/ \
        AFX_MANAGE_STATE(pThis->m_pModuleState); \
        __pragma(warning(pop)) \
        _hr = DualHandleException(_riidSource, e); \
        } \
        END_CATCH_ALL \
        return _hr; \

_Pragma 预处理运算符（C99, C++11）
################################################################################

``_Pragma`` 类似于Microsoft特定的 ``__pragma`` 关键字，只是它是标准的一部分。
它是在C99中为C语言引入的。对于C++，它是在 C++ 11中引入的。

它允许您将 pragma 指令放入宏定义中。它有一个前导下划线，并且第一个字母是大写的。

字符串字面量应该是你放在 ``#pragma`` 语句后面的内容。例如:

    .. code-block:: c

        #pragma message("the #pragma way")
        _Pragma ("message( \"the _Pragma way\")")

引号和反斜杠应该被转义，如上所示。未被识别的 pragma 字符串将被忽略。

下面的代码示例演示了如何在条件表达式碰巧是常量时，当您不想得到警告时，在类似断言
的宏中使用 ``_Pragma`` 关键字。

The macro definition uses the do-while(0) idiom for multi-statement macros so 
that it can be used as though it were one statement. See `C multi-line macro <https://stackoverflow.com/questions/1067226/c-multi-line-macro-do-while0-vs-scope-block>`_ 
on Stack Overflow for more info. The _Pragma statement only applies to the line of code that follows it.

.. code-block:: c

    // Compile with /W4

    #include <stdio.h>
    #include <stdlib.h>

    #define MY_ASSERT(BOOL_EXPRESSION) \
        do { \
            _Pragma("warning(suppress: 4127)") /* C4127 conditional expression is constant */  \
            if (!(BOOL_EXPRESSION)) {   \
                printf("MY_ASSERT FAILED: \"" #BOOL_EXPRESSION "\" on %s(%d)", __FILE__, __LINE__); \
                exit(-1); \
            } \
        } while (0)

    int main()
    {
        MY_ASSERT(0 && "Note that there is no warning: C4127 conditional expression is constant");

        return 0;
    }

1.5 #elif
********************************************************************************

1.6 #if
********************************************************************************

1.7 #include
********************************************************************************

1.8 #undef
********************************************************************************

删除(取消定义)先前用 ``#define`` 创建的名称。

语法：

.. code-block:: c++

    #undef identifier

``#unde`` 指令删除标识符的当前定义。因此，标识符的后续出现被预处理器忽略。要使用
``#undef`` 删除宏定义，请仅提供宏标识符，而不是参数列表。

您也可以将 ``#undef`` 指令应用于没有先前定义的标识符。这确保标识符是未定义的。宏替换不
会在 ``#undef`` 语句中执行。

``#unde`` 指令通常与 ``#define`` 指令配对，以在源程序中创建一个标识符具有特殊含义的区
域。例如，源程序的特定函数可以使用manifest常量来定义不影响程序其余部分的特定于环境的值。
``#unde`` 指令还与 ``#if`` 指令一起工作，以控制源程序的条件编译。

在下面的例子中， ``#undef`` 指令删除了符号常量和宏的定义。注意，只给出了宏的标识符。

.. code-block:: c++

    #define WIDTH 80
    #define ADD( X, Y ) ((X) + (Y))
    .
    .
    .
    #undef WIDTH
    #undef ADD

1.9 #else
********************************************************************************

1.10 #ifdef
********************************************************************************

1.11 #line
********************************************************************************

``#line`` 指令告诉预处理器将编译器报告的行号和文件名值设置为给定的行号和文件名。

语法：

.. code-block:: c++

    #line digit-sequence ["filename"]

编译器使用行号和可选文件名来指示编译期间发现的错误。行号通常指当前输入行，文件名指当前输
入文件。行号在处理每一行后递增。

*digit-sequence* 可以是任何整数常量。宏替换可以用于预处理标记，但结果必须符合正确的语
法。文件名可以是任意字符组合，并且必须用双引号（" "）括起来。如果省略文件名，则前一个文件
名保持不变。

您可以通过编写 ``#line`` 指令来更改源行号和文件名。 ``#line`` 指令设置源文件中紧跟该指
令的行的值。转换器使用行号和文件名来确定预定义宏 ``__FILE__`` 和 ``__LINE__`` 的值。
可以使用这些宏在程序文本中插入自描述性错误消息。

``__FILE__`` 宏展开为一个字符串，其内容是由双引号(" ")括起来的文件名。

如果您更改了行号和文件名，编译器将忽略以前的值，并继续处理新的值。 ``#line`` 指令通常用
于程序生成器。它用于指示原始源文件中产生错误消息的地方，而不是用于生成的程序。

.. code-block:: c++

    // line_directive.cpp
    // Compile by using: cl /W4 /EHsc line_directive.cpp
    #include <stdio.h>

    int main()
    {
        printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
    #line 10
        printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
    #line 20 "hello.cpp"
        printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
        printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
    }

输出： ::

    This code is on line 7, in file line_directive.cpp
    This code is on line 10, in file line_directive.cpp
    This code is on line 20, in file hello.cpp
    This code is on line 21, in file hello.cpp

.. code-block:: c++

    #define ASSERT(cond) if( !(cond) )\
    {printf( "assertion error line %d, file(%s)\n", \
    __LINE__, __FILE__ );}


1.12 #using
********************************************************************************

1.13 #endif
********************************************************************************

1.14 #ifndef
********************************************************************************

2. 预处理器运算符（ `Preprocessor operators <https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-operators?view=msvc-160>`_ ）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3. 预定义的宏（ `Predefined macros <https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-160>`_ ）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4. 编译指示（ `Pragmas <https://docs.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=msvc-160>`_ ）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

宏的使用
--------------------------------------------------------------------------------

Visual Studio 中注意相关配置的设置：

    -   `/Zc (Conformance) <https://docs.microsoft.com/en-us/cpp/build/reference/zc-conformance?view=msvc-160>`_
    -   Project Properties -> Configurarion Properties -> C/C++ -> Preprocessor -> Use Standsrd Conforming Preprocessor : Yes (/Zc:preprocessor)
        或 `/Zc:preprocessor (Enable preprocessor conformance mode) <https://docs.microsoft.com/en-us/cpp/build/reference/zc-preprocessor?view=msvc-160>`_

1. 如何调试
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

很多人因为 “宏编程” 无法调试，而直接 “从入门到放弃” —— 不经意的符号拼写错误、参数个数错
误，导致文本不能正确替换，从而带来满屏的编译错误，最后难以定位问题所在。

由于宏代码会在编译前全部展开，我们可以：

-   让编译器 仅输出预处理结果；
-   gcc -E 让编译器 在预处理结束后停止，不进行编译、链接；
-   gcc -P 屏蔽编译器 输出预处理结果的 行标记 (linemarker)，减少干扰；
-   屏蔽无关的头文件；
-   临时删掉不影响宏展开的 #include 行；
-   避免多余的引用展开，导致实际关注的宏代码 “被淹没”；
-   Visual Studio 中右键 .cpp 文件，Properties -> Configuration Properties -> C/C++ -> Preprocessor -> Preprocess to a File: Yes (/P) 


2. 特殊符号
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

和模板元编程不一样，宏编程没有类型的概念，输入和输出都是符号 —— 不涉及编译时的 C++ 语法，
只进行编译前的文本替换：

    -   一个 **宏参数** 是一个任意的符号序列(token sequence)，不同宏参数之间用逗号分隔；
    -   每个参数可以是空序列，且空白字符会被忽略（例如 a + 1 和 a+1 相同）；
    -   在一个参数内，不能出现逗号或不配对的括号（例如 ``FOO(bool, std::pair<int, int>)``
        被认为是 FOO() 有三个参数： ``bool``  ``std::pair<int`` ``int>`` ）：

        如何让 ``FOO(bool, std::pair<int, int>)`` 成为一个参数？
            
            #.  使用类型别名，避免参数中出现逗号：
            
                .. code-block:: c++
                
                    #define FOO(A, B) int foo(A x, B y)

                    int main()
                    {
                        using intPair = std::pair<int, int>;
                        FOO(bool, intPair);
                    }
                
                展开后为：
                
                .. code-block:: c++
                
                    int main()
                    {
                        using intPair = std::pair<int, int>;
                        int foo(bool x, intPair y);
                    }

            #.  使用括号对封装每个参数（ **元组** ），并在最终展开式移
                除括号（ **元组解包** ）：

                .. code-block:: c++

                    #define PP_REMOVE_PARENS(T) PP_REMOVE_PARENS_IMPL T
                    #define PP_REMOVE_PARENS_IMPL(...) __VA_ARGS__

                    #define FOO(A, B) int foo(A x, B y)
                    #define BAR(A, B) FOO(PP_REMOVE_PARENS(A), PP_REMOVE_PARENS(B))

                    int main()
                    {
                        BAR((bool), (std::pair<int, int>));
                    }
                
                说明：

                    -   ``PP_REMOVE_PARENS(T)`` 展开为 ``PP_REMOVE_PARENS_IMPL T``
                        的形式
                    -   如果参数 ``T`` 是一个 **括号对** ，那么展开结果会变成
                        **调用宏函数** ``PP_REMOVE_PARENS_IMPL (...)`` 的形式
                    -   接着 ``PP_REMOVE_PARENS_IMPL(...)`` 再展开为参数本身
                        ``__VA_ARGS__`` （ 见下文中的 :ref:`变长参数 <src/C++:9. 变长参数>` ），
                        即元组 ``T`` 的内容

                展开后为：
                
                .. code-block:: c++
                
                    int main()
                    {
                        int foo(bool x, std::pair<int, int> y);
                    }
                




另外，常用宏函数代替特殊符号，用于下文中的 :ref:`惰性求值 <src/C++:8. 惰性求值>` :

..  code-block:: c++

    #define PP_COMMA() ,
    #define PP_LPAREN() (
    #define PP_RPAREN() )
    #define PP_EMPTY()

3. 符号拼接
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在宏编程中， 通过 ``##`` 可以获取宏函数的参数的字面量或将其拼接成其它符号，再进一步展开
为目标结果，是宏编程的实现基础。

下文中出现的 **符号拼接** 等同于 **获取宏函数的参数的字面量或将其拼接成其它符号** 。

注意事项：

    -   如果一个宏参数用于符号拼接，那么它不会被展开：
    
        .. code-block:: c++
        
            #define FOO(SYMBOL) foo_ ## SYMBOL
            #define BAR() bar

            int main()
            {
                FOO(BAR());
            }

        展开后为：

        .. code-block:: c++
        
            int main()
            {
                foo_BAR();
            }

    -   延迟拼接操作（即在宏参数用于符号拼接之前，先对其进行展开 -- 调用一个非符号拼接操
        作的宏函数）：

        .. code-block:: c++

            #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
            #define PP_CONCAT_IMPL(A, B) A##B

            #define FOO(N) PP_CONCAT(foo_, N)
            #define BAR() bar

            int main()
            {
                FOO(BAR());
            }

        或简单一点的：
        
        .. code-block:: c++

            #define FOO(SYMBOL) FOO_IMPL(SYMBOL)
            #define FOO_IMPL(SYMBOL) foo_ ## SYMBOL
            #define BAR() bar

            int main()
            {
                FOO(BAR());
            }

        展开后均为：

        .. code-block:: c++
        
            int main()
            {
                foo_bar;
            }

总结：

    -   在进入宏函数前，会对所有宏参数进行一次预扫描（prescan），把不是用于符号拼接的所
        有参数完全展开；
    -   在宏函数展开时，用前面预扫描展开后的参数展开目标里面的同名符号；
    -   在宏函数展开后，替换后的文本会进行二次扫描（scan twice），继续对里面出现的宏进
        行展开;
    -   在预扫描前后，宏函数都要求参数个数必须匹配，否则无法展开（ **需要注意有的编译器
        并不会报错** ）：

        .. code-block:: c++
        
            #define TwoArgsMacro(x,y) x + y
            #define PP_COMMA() ,

            int main()
            {
                TwoArgsMacro(x PP_COMMA() y);   // 预扫描前，只有一个参数 "x PP_COMMA() y"
                TwoArgsMacro(x, PP_COMMA());    // 预扫描后，有三个参数 "x,,"
            }

4. 自增自减
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

借助 ``PP_CONCAT()`` ，我们可以实现 非负整数增减（即 *INC(N) = N + 1 / DEC(N) = N - 1* ）：

.. code-block:: c++

    #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
    #define PP_CONCAT_IMPL(A, B) A##B

    #define PP_INC(N) PP_CONCAT(PP_INC_, N)
    #define PP_INC_0 1
    #define PP_INC_1 2
    // ...
    #define PP_INC_254 255
    #define PP_INC_255 256

    #define PP_DEC(N) PP_CONCAT(PP_DEC_, N)
    #define PP_DEC_256 255
    #define PP_DEC_255 254
    // ...
    #define PP_DEC_2 1
    #define PP_DEC_1 0

    int main()
    {
        PP_INC(1);    // -> 2
        PP_DEC(2);    // -> 1
        PP_INC(256);  // -> PP_INC_256 (overflow)
        PP_DEC(0);    // -> PP_DEC_0  (underflow)
    }

说明：

    -   ``PP_INC(N)`` / ``PP_DEC(N)`` 先展开为 ``PP_INC_N`` / ``PP_DEC_N`` ，再经
        过二次扫描展开为对应数值 ``N + 1`` / ``N - 1`` 的符号；
    -   但上述操作有上限，若超出则无法继续展开（例如 `BOOST_PP 数值操作的上限是 256 <https://www.boost.org/doc/libs/master/libs/preprocessor/doc/ref/limit_mag.html>`_ ）。

5. 逻辑运算
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

借助 ``PP_CONCAT()`` ，我们可以实现 布尔类型（0 和 1）的 逻辑运算（与/或/非/异或/同或）：

.. code-block:: c++

    #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
    #define PP_CONCAT_IMPL(A, B) A##B

    #define PP_NOT(N) PP_CONCAT(PP_NOT_, N)
    #define PP_NOT_0 1
    #define PP_NOT_1 0

    #define PP_AND(A, B) PP_CONCAT(PP_AND_, PP_CONCAT(A, B))
    #define PP_AND_00 0
    #define PP_AND_01 0
    #define PP_AND_10 0
    #define PP_AND_11 1

    int main()
    {
        PP_AND(PP_NOT(0), 1); // -> 1
        PP_AND(PP_NOT(2), 0); // -> PP_AND_PP_NOT_20
    }

说明：

    -   原理和 ``PP_INC()`` / ``PP_DEC()`` 类似（符号拼接 + 二次展开）；
    -   但上述操作不支持 非负整数 的通用逻辑运算（仅支持 0 和 1）；
    -   如果通过定义 ``PP_NOT_2`` 来支持 ``PP_NOT(2)`` ，宏代码会急剧膨胀。一元运算
        ``PP_NOT()`` 需要考虑 *N* 种组合，二元运算 ``PP_AND()`` 则要考虑 *N^2* 种组
        合。

6. 布尔转换
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了支持更通用的非负整数的逻辑运算，可以先将整数转换成布尔类型，而不是扩展布尔类型的逻辑
运算：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 14,15,16,17,18

    #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
    #define PP_CONCAT_IMPL(A, B) A##B

    #define PP_NOT(N) PP_CONCAT(PP_NOT_, N)
    #define PP_NOT_0 1
    #define PP_NOT_1 0

    #define PP_AND(A, B) PP_CONCAT(PP_AND_, PP_CONCAT(A, B))
    #define PP_AND_00 0
    #define PP_AND_01 0
    #define PP_AND_10 0
    #define PP_AND_11 1

    #define PP_BOOL(N) PP_CONCAT(PP_BOOL_, N)
    #define PP_BOOL_0 0
    #define PP_BOOL_1 1
    #define PP_BOOL_2 1
    // ...

    int main()
    {
        PP_AND(PP_NOT(PP_BOOL(2)), PP_BOOL(0));  // -> 0
        PP_NOT(PP_BOOL(1000));                   // -> PP_NOT_PP_BOOL_1000
    }

说明：

    -   原理和 ``PP_INC()`` / ``PP_DEC()`` 类似（符号拼接 + 二次展开）；
    -   同理，上述操作也有上限，若超出则无法继续展开。

7. 条件选择
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

借助 ``PP_CONCAT()`` 和 ``PP_BOOL()`` ，我们可以实现通用的条件选择表达式
``(PRED ? THEN : ELSE)`` ，其中 PRED 可以是 任意非负整数）：

.. code-block:: c++

    #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
    #define PP_CONCAT_IMPL(A, B) A##B

    #define PP_DEC(N) PP_CONCAT(PP_DEC_, N)
    #define PP_DEC_256 255
    #define PP_DEC_255 254
    // ...
    #define PP_DEC_2 1
    #define PP_DEC_1 0

    #define PP_BOOL(N) PP_CONCAT(PP_BOOL_, N)
    #define PP_BOOL_0 0
    #define PP_BOOL_1 1
    #define PP_BOOL_2 1
    // ...

    #define PP_IF(PRED, THEN, ELSE) PP_CONCAT(PP_IF_, PP_BOOL(PRED))(THEN, ELSE)
    #define PP_IF_1(THEN, ELSE) THEN
    #define PP_IF_0(THEN, ELSE) ELSE

    #define DEC_SAFE(N) PP_IF(N, PP_DEC(N), 0)

    int main()
    {
        DEC_SAFE(2);    // -> 1
        DEC_SAFE(1);    // -> 0
        DEC_SAFE(0);    // -> 0
    }

说明：

    -   ``PP_IF()`` 先会根据转换后的条件 ``PP_BOOL(PRED)`` 选择 ``PP_IF_1`` 或
        ``PP_IF_0`` 符号
    -   ``PP_IF_1()`` / ``PP_IF_0()`` 接受相同的参数，但分别展开为 ``THEN`` 或
        ``ELSE`` 参数


8. 惰性求值
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

需要注意 ``PP_IF()`` 的参数会在预扫描阶段被完全展开，例如 ``PP_COMMA()`` 会被立即展开
为逗号，从而导致参数个数错误（ Visual Studio 2019 中并未产生错误）：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 21,22,23,24,26
    
    #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
    #define PP_CONCAT_IMPL(A, B) A##B

    #define PP_DEC(N) PP_CONCAT(PP_DEC_, N)
    #define PP_DEC_256 255
    #define PP_DEC_255 254
    // ...
    #define PP_DEC_2 1
    #define PP_DEC_1 0

    #define PP_BOOL(N) PP_CONCAT(PP_BOOL_, N)
    #define PP_BOOL_0 0
    #define PP_BOOL_1 1
    #define PP_BOOL_2 1
    // ...

    #define PP_IF(PRED, THEN, ELSE) PP_CONCAT(PP_IF_, PP_BOOL(PRED))(THEN, ELSE)
    #define PP_IF_1(THEN, ELSE) THEN
    #define PP_IF_0(THEN, ELSE) ELSE

    #define PP_COMMA() ,
    #define PP_LPAREN() (
    #define PP_RPAREN() )
    #define PP_EMPTY()

    #define PP_COMMA_IF(N) PP_IF(N, PP_COMMA(), PP_EMPTY())

    int main()
    {
        PP_COMMA_IF(1);
    }

常用的技巧是惰性求值 (lazy evaluation)，即条件选择先返回宏函数，再传递参数延迟调用：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 26,28,29,30,38,39,40

    #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
    #define PP_CONCAT_IMPL(A, B) A##B

    #define PP_DEC(N) PP_CONCAT(PP_DEC_, N)
    #define PP_DEC_256 255
    #define PP_DEC_255 254
    // ...
    #define PP_DEC_2 1
    #define PP_DEC_1 0

    #define PP_BOOL(N) PP_CONCAT(PP_BOOL_, N)
    #define PP_BOOL_0 0
    #define PP_BOOL_1 1
    #define PP_BOOL_2 1
    // ...

    #define PP_IF(PRED, THEN, ELSE) PP_CONCAT(PP_IF_, PP_BOOL(PRED))(THEN, ELSE)
    #define PP_IF_1(THEN, ELSE) THEN
    #define PP_IF_0(THEN, ELSE) ELSE

    #define PP_COMMA() ,
    #define PP_LPAREN() (
    #define PP_RPAREN() )
    #define PP_EMPTY()

    #define PP_COMMA_IF(N) PP_IF(N, PP_COMMA, PP_EMPTY)()

    #define SURROUND(N) PP_IF(N, PP_LPAREN, [PP_EMPTY)() \
                        N                                 \
                        PP_IF(N, PP_RPAREN, ] PP_EMPTY)()

    int main()
    {
        PP_COMMA_IF(0);  // (empty)
        PP_COMMA_IF(1);  // -> ,
        PP_COMMA_IF(2);  // -> ,
        
        SURROUND(0);    // -> [0]
        SURROUND(1);    // -> (1)
        SURROUND(2);    // -> (2)
    }
    
说明：

    -   ``PP_COMMA_IF()`` 先借助 ``PP_IF()`` 返回 ``PP_COMMA`` 或 ``PP_EMPTY`` 符
        号；
    -   ``PP_COMMA`` / ``PP_EMPTY`` 和后边的括号对组成 ``PP_COMMA()`` /
        ``PP_EMPTY()`` ，再继续展开为逗号或空；
    -   如果需要展开为其他符号 ``SYMBOL`` ，可以使用 ``SYMBOL`` ``PP_EMPTY`` 作为参
        数，和后边的括号对组成 ``PP_EMPTY()`` （例如 ``SURROUND()`` 使用的 ``[`` 和
        ``]`` ）。


9. 变长参数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

从 C++ 11 开始，宏函数支持了变长参数 ``...`` ，接受任意个宏参数（用逗号分隔）：

    -   传入的变长参数可以用 ``__VA_ARGS__`` 获取（也可以通过 ``#__VA_ARGS__`` 获取
        逗号+空格分隔的参数字面量）；
    -   另外，允许传递空参数，即 ``__VA_ARGS__`` 替换为空。

对于空参数，展开时需要处理多余逗号的问题（Visual Studio 2019 中测试时并未有产生该错误，
可通过对编译器进行相关的设置 `/Zc:preprocessor <https://docs.microsoft.com/en-us/cpp/preprocessor/variadic-macros?view=msvc-160>`_）：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 6,7

        #define log(format, ...) printf(format, __VA_ARGS__)

        int main()
        {
            log("%d%f", 1,.2);      // -> printf("%d%f", 1, .2);
            log("hello world");     // -> printf("hello world", );
            log("hello world", );   // -> printf("hello world", );
        }

    -   后两种调用 分别对应 不传变长参数、变长参数为空 的情况
    -   展开结果会 多出一个逗号，导致 C/C++ 编译错误（而不是 宏展开错误）

    以下是在 Visual Studio 2019 中的没有错误的输出：

    .. code-block:: c++
        :emphasize-lines: 4,5

        int main()
        {
            printf("%d%f", 1,.2);      
            printf("hello world"  );     
            printf("hello world"  );   
        }

为了解决这个问题，一些编译器（例如 gcc/clang）扩展了 , ``## __VA_ARGS__`` 的用法 —— 
如果 **不传变长参数** ，则省略前面的逗号：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 6,7

        #define log(format, ...) printf(format, ##__VA_ARGS__)

        int main()
        {
            log("%d%f", 1, .2);    // -> printf("%d%f", 1, .2);
            log("hello world");    // -> printf("hello world");
            log("hello world", );  // -> printf("hello world", );
        }

    以下是在 Visual Studio 2019 中的没有错误的输出：

    .. code-block:: c++
        :emphasize-lines: 4,5

        int main()
        {
            printf("%d%f",1, .2);    
            printf("hello world" );    
            printf("hello world" );  
        }

为了进一步处理 **变长参数为空** 的情况，C++ 20 引入了 ``__VA_OPT__`` 标识符 —— 如果变
长参数是空参数，不展开该符号（不仅限于逗号）：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 6,7
        
        #define log(format, ...) printfformat __VA_OPT__(,) __VA_ARGS__)
        
        int main()
        {
            log("%d%f", 1, .2);    // -> printf("%d%f", 1, .2);
            log("hello world");    // -> printf("hello world");
            log("hello world", );  // -> printf("hello world");
        }

下文将借助 :ref:`长度判空 <src/c++:11. 长度判空>` 和 :ref:`遍历访问 <src/c++:13. 遍历访问>`，
实现 __VA_OPT__(,) 的功能。

10. 下标访问
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
借助 PP_CONCAT()，我们可以通过 下标访问 变长参数的 特定元素：

    .. code-block:: c++

        #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
        #define PP_CONCAT_IMPL(A, B) A##B

        #define PP_GET_N(N, ...) PP_CONCAT(PP_GET_N_, N)(__VA_ARGS__)
        #define PP_GET_N_0(_0, ...) _0
        #define PP_GET_N_1(_0, _1, ...) _1
        #define PP_GET_N_2(_0, _1, _2, ...) _2
        // ...
        #define PP_GET_N_8(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) _8

        int main()
        {
            PP_GET_N(0, foo);       // -> foo
            PP_GET_N(1, foo, bar);  // -> bar
        }

注意以下代码：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 22

        #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
        #define PP_CONCAT_IMPL(A, B) A##B

        #define PP_GET_N(N, ...) PP_CONCAT(PP_GET_N_, N)(__VA_ARGS__)
        #define PP_GET_N_0(_0, ...) _0
        #define PP_GET_N_1(_0, _1, ...) _1
        #define PP_GET_N_2(_0, _1, _2, ...) _2
        // ...
        #define PP_GET_N_8(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) _8

        int main()
        {
            #define PP_BOOL(N) PP_CONCAT(PP_BOOL_, N)
            #define PP_BOOL_0 0
            #define PP_BOOL_1 1
           // ...

            #define PP_IF(PRED, THEN, ELSE) PP_CONCAT(PP_IF_, PP_BOOL(PRED))(THEN, ELSE)
            #define PP_IF_1(THEN, ELSE) THEN
            #define PP_IF_0(THEN, ELSE) ELSE

            #define FOO(P, ...) PP_IF(P, PP_GET_N(1,__VA_ARGS__), PP_GET_N(0, __VA_ARGS__))

            FOO(0, foo);
        }

    第 22 行展开时，虽然目标是对 ``PP_GET_N(0, __VA_ARGS__)`` 这部分进行处理，但是注
    意此时这里的 ``PP_GET_N(1,__VA_ARGS__)`` 仍然会进行展开，因此在调用 ``FOO(0, foo)``
    时会因为参数过少而展开失败： ::
    
        error C4003: not enough arguments for function-like macro invocation 'PP_GET_N_1'
    
    可以通过上文中提到的 :ref:`惰性求值 <src/c++:8. 惰性求值>` 来解决该问题：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 22

        #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
        #define PP_CONCAT_IMPL(A, B) A##B

        #define PP_GET_N(N, ...) PP_CONCAT(PP_GET_N_, N)(__VA_ARGS__)
        #define PP_GET_N_0(_0, ...) _0
        #define PP_GET_N_1(_0, _1, ...) _1
        #define PP_GET_N_2(_0, _1, _2, ...) _2
        // ...
        #define PP_GET_N_8(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) _8

        int main()
        {
            #define PP_BOOL(N) PP_CONCAT(PP_BOOL_, N)
            #define PP_BOOL_0 0
            #define PP_BOOL_1 1
           // ...

            #define PP_IF(PRED, THEN, ELSE) PP_CONCAT(PP_IF_, PP_BOOL(PRED))(THEN, ELSE)
            #define PP_IF_1(THEN, ELSE) THEN
            #define PP_IF_0(THEN, ELSE) ELSE

            #define FOO(P, ...) PP_IF(P, PP_CONCAT(PP_GET_N_,1),PP_CONCAT(PP_GET_N_,0))(__VA_ARGS__)

            FOO(0, foo);    // -> foo
        }

实现下标访问的另外一个版本：

    .. code-block:: c++
        :emphasize-lines: 17
    
        #define metamacro_concat_(A, B) A ## B

        /**
         * Returns A and B concatenated after full macro expansion.
         */
        #define metamacro_concat(A, B) \
                metamacro_concat_(A, B)

         /**
          * Returns the Nth variadic argument (starting from zero). At least
          * N + 1 variadic arguments must be given. N must be between zero and twenty,
          * inclusive.
          */
        #define metamacro_at(N, ...) \
                metamacro_concat(metamacro_at, N)(__VA_ARGS__)

        #define metamacro_head(...) metamacro_head_(__VA_ARGS__, 0)
        #define metamacro_head_(FIRST, ...) FIRST

          // metamacro_at expansions
        #define metamacro_at0(...) metamacro_head(__VA_ARGS__)
        #define metamacro_at1(_0, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at2(_0, _1, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at3(_0, _1, _2, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at4(_0, _1, _2, _3, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at5(_0, _1, _2, _3, _4, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at6(_0, _1, _2, _3, _4, _5, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at7(_0, _1, _2, _3, _4, _5, _6, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at8(_0, _1, _2, _3, _4, _5, _6, _7, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at9(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at11(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at12(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at13(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at14(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at15(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at17(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at19(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, ...) metamacro_head(__VA_ARGS__)
        #define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)

        /**
         * Returns the number of arguments (up to twenty) provided to the macro. At
         * least one argument must be provided.
         *
         * Inspired by P99: http://p99.gforge.inria.fr
         */
        #define metamacro_argcount(...) \
                metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

        int main()
        {
            metamacro_at(0, foo, bar);      // -> foo
            metamacro_at(1, foo, bar);      // -> bar

            metamacro_argcount(a, b);       // -> 2
            metamacro_argcount(a, b, c);    // -> 3
        }

11. 长度判空
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

借助 PP_GET_N()，我们可以检查 变长参数是否为空：

    .. code-block:: c++
        
        #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
        #define PP_CONCAT_IMPL(A, B) A##B

        #define PP_NOT(N) PP_CONCAT(PP_NOT_, N)
        #define PP_NOT_0 1
        #define PP_NOT_1 0

        #define PP_AND(A, B) PP_CONCAT(PP_AND_, PP_CONCAT(A, B))
        #define PP_AND_00 0
        #define PP_AND_01 0
        #define PP_AND_10 0
        #define PP_AND_11 1

        #define PP_GET_N(N, ...) PP_CONCAT(PP_GET_N_, N)(__VA_ARGS__)
        #define PP_GET_N_0(_0, ...) _0
        #define PP_GET_N_1(_0, _1, ...) _1
        #define PP_GET_N_2(_0, _1, _2, ...) _2
        // ...
        #define PP_GET_N_8(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) _8

        int main()
        {
            #define PP_COMMA_V(...) ,
            #define PP_HAS_COMMA(...) PP_GET_N_8(__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 0, 0)

            #define PP_IS_EMPTY(...)                                      \
              PP_AND(PP_AND(PP_NOT(PP_HAS_COMMA(__VA_ARGS__)),            \
                            PP_NOT(PP_HAS_COMMA(__VA_ARGS__()))),         \
                     PP_AND(PP_NOT(PP_HAS_COMMA(PP_COMMA_V __VA_ARGS__)), \
                            PP_HAS_COMMA(PP_COMMA_V __VA_ARGS__())))

            #define PP_COMMA() ,
            #define PP_LPAREN() (
            #define PP_RPAREN() )
            #define PP_EMPTY()



            PP_IS_EMPTY();          // -> 1
            PP_IS_EMPTY(foo);       // -> 0
            PP_IS_EMPTY(foo());     // -> 0
            PP_IS_EMPTY(());        // -> 0
            PP_IS_EMPTY(()foo);     // -> 0
            PP_IS_EMPTY(PP_EMPTY);  // -> 0
            PP_IS_EMPTY(PP_COMMA);  // -> 0
            PP_IS_EMPTY(, );        // -> 0
            PP_IS_EMPTY(foo, bar);  // -> 0
            PP_IS_EMPTY(, , , );    // -> 0
        }

说明：

    先定义两个辅助宏：
    
        -   ``PP_HAS_COMMA()`` 用于检查变长参数里 有没有逗号；
        -   ``PP_COMMA_V()`` 用于吃掉(eat) 变长参数，并返回一个逗号。

    如果变长参数为空，需要满足以下条件：

        -   ``PP_COMMA_V __VA_ARGS__()`` 展开为逗号，即构成 PP_COMMA_V() 的形式；
        -   ``__VA_ARGS__`` 、 ``__VA_ARGS__()`` 和 ``PP_COMMA_V __VA_ARGS__`` 
            展开结果里 没有逗号，排除对上一个条件的干扰。


12. 长度计算
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

13. 遍历访问
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

14. 符号匹配
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

16. 递归重入
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

17. 条件循环
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

18. 延迟展开
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

19. 数值运算
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

20. 数值比较
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

21. 结合模板
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一、 #define 的基本用法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.1 #define 命令解析
********************************************************************************

1.1.1 #define 的概念
################################################################################

**#define** 命令是C语言中的一个宏定义命令，它用来将一个 **标识符** 定义为一个 
**字符串** ，该标识符被称为 **宏名** ，被定义的字符串称为 **替换文本** 。

该命令有两种格式：简单的宏定义和带参数的宏定义。

#.  简单的宏定义

    格式： ``#define <宏名> <替换文本>``

    .. code-block:: c++

        #define PI 3.1415926

#.  带参数的宏定义

    格式： ``#define <宏名>(<参数列表>) <替换文本>``

    .. code-block:: c++

        #define A(x) x
    
    注意事项：
    
        #.  一个宏参数是一个任意的符号序列（token sequence），不同宏参数之
            间用逗号分隔；
        #.  一个宏参数可以是空序列；
        #.  一个宏参数内不能出现逗号或不匹配的括号。
        
            例如： ``FOO(bool, std::pair<int, int>)`` 被认为是 FOO() 有三个参
            数： ``bool`` ``std::pair<int`` ``int``
            
            如何让 ``FOO(bool, std::pair<int, int>)`` 成为一个参数？
            
                #.  使用类型别名，避免参数中出现逗号：
                
                    .. code-block:: c++
                    
                        #define FOO(A, B) int foo(A x, B y)

                        int main()
                        {
                            using intPair = std::pair<int, int>;
                            FOO(bool, intPair);
                        }
                    
                    展开后为：
                    
                    .. code-block:: c++
                    
                        int main()
                        {
                            using intPair = std::pair<int, int>;
                            int foo(bool x, intPair y);
                        }

                #.  使用括号对封装每个参数（ **元组** ），并在最终展开式移
                    除括号（ **元组解包** ）：

                    .. code-block:: c++

                        #define PP_REMOVE_PARENS(T) PP_REMOVE_PARENS_IMPL T
                        #define PP_REMOVE_PARENS_IMPL(...) __VA_ARGS__

                        #define FOO(A, B) int foo(A x, B y)
                        #define BAR(A, B) FOO(PP_REMOVE_PARENS(A), PP_REMOVE_PARENS(B))

                        int main()
                        {
                            BAR((bool), (std::pair<int, int>));
                        }
                    
                    说明：

                        -   ``PP_REMOVE_PARENS(T)`` 展开为 ``PP_REMOVE_PARENS_IMPL T``
                            的形式
                        -   如果参数 ``T`` 是一个 **括号对** ，那么展开结
                            果会变成 **调用宏函数** ``PP_REMOVE_PARENS_IMPL (...)`` 的形式
                        -   接着 ``PP_REMOVE_PARENS_IMPL(...)`` 再展开
                            为参数本身 ``__VA_ARGS__`` （ **变长参数** ），
                            即元组 ``T`` 的内容

                    展开后为：
                    
                    .. code-block:: c++
                    
                        int main()
                        {
                            int foo(bool x, std::pair<int, int> y);
                        }
                    

一个标识符被宏定义后，该标识符便是一个宏名。这时，在程序中出现的是宏名，在该程序
被编译前，先将宏名用被定义的字符串替换，这称为 **宏替换** ，替换后才进行编译，宏
替换是简单的替换

1.1.2 宏替换发生的时机
################################################################################

在 build 一份 C++ 源代码时，主要经过了预处理、编译、汇编和链接几个过程。

1.2 #define 使用中的常见问题解析
********************************************************************************

1.2.1 简单宏定义使用中出现的问题
################################################################################

1.2.2 带参数宏定义使用中出现的问题
################################################################################

1.3 宏定义的优点
********************************************************************************

1.4 结语
********************************************************************************

二、 #define 中的三个特殊符号： #，##，#@
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.1 x##y
********************************************************************************

将参数x展开后的文本和参数y展开后的文本直接拼接在一起。

    .. code-block:: c++

        #define A(x,y) x##y     // A(123, 456)  ->  123456

2.2 #@x
********************************************************************************

使用单引号将x参数展开后的内文本包围起来。

    .. code-block:: c++

        #define B(x) #@x     // B(123)  ->  '123'

2.3 #x
********************************************************************************

使用双引号将x参数展开后的文本包围起来。

    .. code-block:: c++

        #define C(x) #x     // C(123)  ->  "123"


三、 常用的一些宏定义
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  防止一个头文件被重复 include

    .. code-block:: c++
        :linenos:

        #ifndef SAMPLE_H
        #define SAMPLE_H

        // header file content

        #endif

#.  得到指定地址上的一个字节或字
#.  得到一个 field 在结构体（struct）中的偏移量
#.  得到一个结构体中 field 所占用的字节数
#.  得到一个变量的地址（word宽度）
#.  将一个字母转换为大写
#.  判断字符是否是十进制的数字
#.  判断字符是否是十六进制的数字
#.  防止溢出的方法
#.  返回数组元素的个数
#.  使用一些宏跟踪调试


const or constexpr
--------------------------------------------------------------------------------

Effective C++
================================================================================

    #.  视 *C++* 为一个语言联邦（ *C* 、 *Object-Oriented C++* 、
        *Template C++* 、*STL* ）
    #.  宁可以编译器替换预处理器（ 尽量以 **const** 、**enum** 、**inline**
        替换 **#define** ）
    #.  尽可能使用 **const**
    #.  确定对象被使用前已先被初始化 —— 构造时赋值（copy 构造函数）比 default 
        构造后赋值（copy assignment）效率高
    #.  了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default
        构造函数、copy 构造函数、copy assignment 操作符、析构函数）
    #.  若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数
        声明为 private，并且不予实现）
    #.  为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，
        它就应该拥有一个 virtual 析构函数
    #.  别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不
        是吐出异常；如果要处理异常应该在非析构的普通函数处理）
    #.  绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至
        derived class）
    #.  令 **operator=** 返回一个 *reference to *this* （用于连锁赋值）
    #.  在 **operator=** 中处理 “自我赋值”
    #.  赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成
        分”（调用基类复制构造函数）
    #.  以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，
        资源取得时机便是初始化时机（Resource Acquisition Is Initialization，
        RAII））
    #.  在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：
        抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 **auto_ptr** ））
    #.  在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访
        问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客
        户比较方便）
    #.  成对使用 **new** 和 **delete** 时要采取相同形式（new 中使用 [] 则
        delete []，new 中不使用 [] 则 delete）
    #.  以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会
        因为编译器优化，导致难以察觉的资源泄漏）
    #.  让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、
        内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，
        约束对象值、消除客户的资源管理责任）
    #.  设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值
        传递、合法值、继承关系、转换、一般化等等。
    #.  宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更
        高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代
        器、函数对象）
    #.  必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference
        指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated
        对象，或返回 pointer 或 reference 指向一个 local static 对象而有
        可能同时需要多个这样的对象。）
    #.  将成员变量声明为 *private* （为了封装、一致性、对其读写精确控制等）
    #.  宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹
        弹性（packaging flexibility）、机能扩充性）
    #.  若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此
        采用 non-member 函数
    #.  考虑写一个不抛异常的 swap 函数
    #.  尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）
    #.  尽量少做转型动作
        
        旧式： **(T)expression** 、**T(expression)** ；

        新式： **const_cast<T>(expression)** 、 **dynamic_cast<T>(expression)** 、
        **reinterpret_cast<T>(expression)** 、 **static_cast<T>(expression)** ；
        
        尽量避免转型、注重效率避免 **dynamic_casts** 、尽量设计成无需转型、
        可把转型封装成函数、宁可用新式转型

    #.  避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装
        性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling
        handles，如悬空指针等）的可能性）
    #.  为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）
        即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：
        基本型、强列型、不抛异常型）
    #.  透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期
        的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝
        太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数
        的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的
        代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）
    #.  将文件间的编译依存关系降至最低（如果使用 object references 或
        object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以
        class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）
    #.  确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes
        身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived
        class 对象也都是一个 base class 对象）
    #.  避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding
        functions）来让被遮掩的名字再见天日）
    #.  区分接口继承和实现继承（在 public 继承之下，derived classes 总是
        继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯
        impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函
        数具体指定接口继承以及强制性实现继承）
    #.  考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的
        non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针
        成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系
        内的 virtual 函数替换为另一个继承体系内的 virtual 函数）
    #.  绝不重新定义继承而来的 non-virtual 函数
    #.  绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically
        bound），而 virtual 函数却是动态绑定（dynamically bound）
    #.  通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application
        domain），复合意味 has-a（有一个）；在实现域（implementation domain），
        复合意味着 is-implemented-in-terms-of（根据某物实现出））
    #.  明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of
        （根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected
        base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需
        要 empty base 最优化时，才使用 private 继承）
    #.  明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，
        以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个
        interface class” 和 “private 继承某个协助实现的 class”；virtual
        继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及
        赋值的复杂度等等成本）
    #.  了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）
        和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），
        多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效
        表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载
        解析（function overloading resolution）发生于编译期）
    #.  了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class
        和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型
        名称，但不得在基类列（base class lists）或成员初值列（member
        initialization list）内以它作为 base class 修饰符）
    #.  学习处理模板化基类内的名称（可在 derived class templates 内通过
        this-> 指涉 base class templates 内的成员名称，或藉由一个明白写出
        的 “base class 资格修饰符” 完成）
    #.  将与参数无关的代码抽离 templates（因类型模板参数（non-type template
        parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换
        template 参数来消除；因类型参数（type parameters）而造成的代码膨胀
        往往可以通过让带有完全相同二进制表述（binary representations）的实
        现类型（instantiation types）共享实现码）
    #.  运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function
        templates）生成 “可接受所有兼容类型” 的函数；声明 member templates
        用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的
        copy 构造函数和 copy assignment 操作符）
    #.  需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，
        而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换”
        时，请将那些函数定义为 “class template 内部的 friend 函数”）
    #.  请使用 traits classes 表现类型信息（traits classes 通过 templates
        和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术
        （overloading）实现在编译期对类型执行 if...else 测试）
    #.  认识 template 元编程（模板元编程（TMP，template metaprogramming）
        可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；
        TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy
        choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代
        码）
    #.  了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分
        配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因
        为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛
        出异常）
    #.  了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内
        存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额
        外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统
        的行为）
    #.  编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，
        并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，
        它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正
        确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时
        不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申
        请”）
    #.  写了 placement new 也要写 placement delete（当你写一个 placement
        operator new，请确定也写出了对应的 placement operator delete，否
        则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和
        placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）
    #.  不要轻忽编译器的警告
    #.  让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，
        C++11 标准的草稿文件）
    #.  让自己熟悉 Boost（准标准库）

More Effective c++
================================================================================

    #.  仔细区别 *pointers* 和 *references* （当你知道你需要指向某个东西，
        而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由
        pointers 达成，你就应该选择 references；任何其他时候，请采用
        pointers）
    #.  最好使用 C++ 转型操作符（ **static_cast** 、 **const_cast** 、
        **dynamic_cast** 、 **reinterpret_cast** ）
    #.  绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）
        和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和
        多态不要混用）
    #.  非必要不提供 default constructor（避免对象中的字段被无意义地初始化）
    #.  对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易
        法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；
        隐式类型转换操作符可改为显式的 member function 来避免非预期行为）
    #.  区别 increment/decrement 操作符的前置（prefix）和后置（postfix）
        形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回
        一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；
        后置式的实现应以其前置式兄弟为基础）
    #.  千万不要重载 &&，|| 和 , 操作符（&& 与 || 的重载会用 “函数调用语义”
        取代 “骤死式语义”；, 的重载导致不能保证左侧表达式一定比右侧表达式更
        早被评估）
    #.  了解各种不同意义的 new 和 delete（new operator、operator new、
        placement new、operator new[]；delete operator、operator delete、
        destructor、operator delete[]）
    #.  利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常
        时的资源泄漏）
    #.  在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，
        因此在构造函数可以使用 try...catch 或者 auto_ptr（以及与之相似的 
        classes） 处理异常时资源泄露问题）
    #.  禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在
        exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协
        助确保 destructors 完成其应该完成的所有事情）
    #.  了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之
        间的差异（第一，exception objects 总是会被复制（by pointer 除外），
        如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不
        一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转
        换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源
        代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个
        虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）
    #.  以 by reference 方式捕获 exceptions（可避免对象删除问题、exception
        objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception
        object 需要复制的次数）
    #.  明智运用 exception specifications（exception specifications 对 
        “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，
        包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上
        层的 exception 处理函数处理未预期的 exceptions）
    #.  了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀
        5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception
        specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才
        抛出 exceptions）
    #.  谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部
        分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）
    #.  考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting
        （引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来
        做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、
        Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算
        动作）
    #.  分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，
        或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可
        以改善程序效率）

The Cherno
================================================================================

1. 在 Windows 系统中设置 C++ 开发环境
--------------------------------------------------------------------------------
.. graphviz::
    :caption: pipline
    :align: center
    
    digraph example0{
        bgcolor = "transparent"
        rankdir = LR;

        a->b;
        c->a [dir = "back"];
    }

.. graphviz::
    :caption: pipline2
    :align: center

    digraph test{
        bgcolor = "transparent"
        rankdir = LR;
        node [shape="record"];
        edge [style="dashed"];
        a [label = "\<memory\>"];
        b [label = "\<stl_construct.h\>"];
        c [label = "\<stl_aloc.h\>"];
        d [label = "\<stl_uninitialized.h\>"];

        a:e->b:w;
        a:e->c:w;
        a:e->d:w;
    }

2. C++ 是如何工作的
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :caption: Main.cpp

    #include<iostream>

    int main()
    {
        std::cout << "Hello World!" << std::endl;
        std::cin.get();
    }
    
第1行代码中以 ``#`` 开头的是 `预处理语句` ,预处理语句将会在编译之前进行评估（be evaluated）。
这里的 ``include`` 表示将 ``iostream`` 这个 `头文件` 中的内容拷贝到当前源
代码文件中。

第3行是 `mian` 函数，通常 `main` 函数是程序的入口（entry point）, ``int``
表示该函数返回的类型是整型。 `main` 函数中如果没有显示使用 `return someIntValue;`
编译器会假设为 `return 0;` ，只有 `main` 函数是这样的个例。

每一个 `.cpp` 源文件都会被编译，头文件不会被编译，只能使用 ``include`` 预处
理指令被包含到 `.cpp` 文件中进行编译。经过预处理后对每个 `.cpp` 文件进行 **单独** 
地编译，每个 `.cpp` 文件编译后输出一个对应的 `.obj` 文件。最后通过链接器将
这些 `.obj` 文件链接成一个 `.exe` 可执行文件。

.. graphviz::
    :caption: pipline
    :align: center
    
    digraph example {
        bgcolor = "transparent"
        rankdir = LR;
    
        a1 [label="a1.cpp"];
        a2 [label="a2.cpp"];
        an [label="an.cpp"];
        b1 [label="b1.obj"];
        b2 [label="b2.obj"];
        bn [label="bn.obj"];
        c [label="output.exe"];
        a1 -> b1;
        a2 -> b2;
        an -> bn;
        b1 -> c;
        b2 -> c;
        bn -> c;
    }
    


Visual Studio 中 ``Ctrl + F7`` 进行编译（compile）。

下面看一下存在多个 `.cpp` 源文件时 C++ 是如何工作的：

.. code-block:: c++
    :linenos:
    :caption: Log.cpp

    #include<iostream>

    void Log(const char* message)
    {
        std::cout << message << std::endl;
    }

.. code-block:: c++
    :linenos:
    :emphasize-lines: 3
    :caption: Main.cpp
    
    #include<iostream>

    void Log(const char* message);

    int main()
    {
        Log("Hello World!");
        std::cin.get();
    }
    
在上面的代码中，如果移除 `Main.cpp` 中的第3行，build 整个解决方案将会出现以
下错误： ::

    error C3861: 'Log': identifier not found

此时如果我们加上第3行代码，就算没有 `Log.cpp` 文件，单独编译 `Main.cpp` 文
件也不会报错。这是因为这个第3行代码是一个 `声明` （表示某个 symbol 或 function 是
存在的），告诉编译器存在一个这样签名的 `Log` 函数（像是一个承诺，而编译器总
是选择相信我们）。

当我们再次 build 整个解决方案时，编译阶段没有错误，然后链接器开始工作，主要
就是 resolve symbol。如果在 `Log.cpp` 中没有 `Log` 函数的定义，将会出现以
下链接错误： ::

    1>Main.obj : error LNK2019: unresolved external symbol "void __cdecl Log(char const *)" (?Log@@YAXPBD@Z) referenced in function _main
    1>C:\dev\CppTemp\Debug\Main.exe : fatal error LNK1120: 1 unresolved externals

3. C++ 编译器是如何工作的
--------------------------------------------------------------------------------

阶段：

    1. 预处理
        
        evaluate 每条预处理指令；
        
        ==========================      ========================================
        预处理指令                       说明
        ==========================      ========================================
        #include <iostream>             拷贝头文件中的内容到使用该指令的地方
                                        
                                        Visual Studio 中在 

                                        Properties -> Configuration Properties -> C/C++ -> Preprocessor:

                                        Preprocess to a File: No/Yes 

                                        修改该选项为 Yes 可输出预处理后的文件
        #define INTEGER int             将后续代码中出现的 INTEGER 替换为 int
        #if #elif #else #endif          根据条件确定是否使用代码
        ==========================      ========================================

    2. 语法分析
    3. 转换成机器语言指令

编译后的 `.obj` 文件是二进制的机器码，没有可读性，为了可以简单查看编译后的内容，
可以在 Visual Studio 中的 Properties -> Configuration Properties -> C/C++ -> Output Files:
Assemler Output: Assembly-Only Listing (/FA) 这样设置。

4. C++ 链接器是如何工作的
--------------------------------------------------------------------------------

必须要有一个 entry point ，否则会产生一个链接错误。

可以在 Visual Studio 中的 Properties -> Configuration Properties -> Linker -> Advanced:
Entry Point: 这里修改程序的入口。

**LINK-ERROR: 未解决的符号**

-   代码一：

    .. code-block:: c++
        :linenos:
        :caption: Log.cpp

        #include<iostream>

        void Log(const char* message)
        {
            std::cout << message << std::endl;
        }

    .. code-block:: c++
        :linenos:
        :caption: Main.cpp

        #include<iostream>

        void Log(const char* message);

        int Multiply(int a,int b)
        {
            Log("Multiply");
            return a * b;
        }

        int main()
        {
            std::cout << Multiply(5, 8) << std::endl;
            std::cin.get();
        }

    输出： ::

        Multiply
        40

-   代码二：

    .. code-block:: c++
        :linenos:
        :caption: Log.cpp
        :emphasize-lines: 3

        #include<iostream>

        void Logr(const char* message)
        {
            std::cout << message << std::endl;
        }

    .. code-block:: c++
        :linenos:
        :caption: Main.cpp

        #include<iostream>

        void Log(const char* message);

        int Multiply(int a,int b)
        {
            Log("Multiply");
            return a * b;
        }

        int main()
        {
            std::cout << Multiply(5, 8) << std::endl;
            std::cin.get();
        }

    build 时将会出现以下错误信息： ::

        1>Main.obj : error LNK2019: unresolved external symbol "void __cdecl Log(char const *)" (?Log@@YAXPBD@Z) referenced in function "int __cdecl Multiply(int,int)" (?Multiply@@YAHHH@Z)
        1>C:\dev\C++\C++Temp\Debug\C++Temp.exe : fatal error LNK1120: 1 unresolved externals

    错误产生是由于链接时链接器找不到与 `Main.cpp` 中 ``Log`` 函数声明那样匹配的定义。

    此时如果注释掉 `Main.cpp` 中的：

    .. code-block:: c++
            :linenos:
            :lineno-start: 7
            :caption: Main.cpp

            //Log("Multiply");
    
    这时再 build 将会通过，这是因为代码中没有调用 ``Log`` 函数，因此也就不会进行链接，
    也就避免了链接错误的产生。

-   代码三：

    .. code-block:: c++
        :linenos:
        :caption: Log.cpp
        :emphasize-lines: 3

        #include<iostream>

        void Logr(const char* message)
        {
            std::cout << message << std::endl;
        }

    .. code-block:: c++
        :linenos:
        :caption: Main.cpp
        :emphasize-lines: 13

        #include<iostream>

        void Log(const char* message);

        int Multiply(int a,int b)
        {
            Log("Multiply");
            return a * b;
        }

        int main()
        {
            //std::cout << Multiply(5, 8) << std::endl;
            std::cin.get();
        }
    
    build 时会出现以下错误信息： ::

        1>Main.obj : error LNK2019: unresolved external symbol "void __cdecl Log(char const *)" (?Log@@YAXPBD@Z) referenced in function "int __cdecl Multiply(int,int)" (?Multiply@@YAHHH@Z)
        1>C:\dev\C++\C++Temp\Debug\C++Temp.exe : fatal error LNK1120: 1 unresolved externals
    
    这是由于链接器链接时找不到与 `Main.cpp` 中 ``Log`` 函数声明那样匹配的定义。在 `Main.cpp` 
    中虽然没有直接（ Log("something") ）或间接（Multiply(someInt,someInt)）调用
    该 ``Log`` 函数的地方，但是不能保证不会有其他的文件会调用 `Main.cpp` 中的 ``Multiply`` 函数，
    因此链接器会对其进行链接操作，进而生产这个链接错误。

    然而，如果我们告诉链接器 `Main.cpp` 中的这个 ``Multiply`` 不会被其他文件调用，
    又由于在 ``Main.cpp`` 没有直接或间接对 ``Log`` 函数的使用，因此链接时不会对
    其进行链接操作，也就不会导致这个链接错误的产生：

    .. code-block:: c++
        :linenos:
        :lineno-start: 5
        :caption: Main.cpp

        static int Multiply(int a,int b)

**LINK-ERROR: 已存在的符号**

-   代码一：

    .. code-block:: c++
        :linenos:
        :caption: Log.h

        #pragma once

        void Log(const char* message)
        {
            std::cout << message << std::endl;
        }

    .. code-block:: c++
        :linenos:
        :caption: Log.cpp
        :emphasize-lines: 2

        #include<iostream>
        #include"Log.h"

        void InitLog()
        {
            Log("Init");
        }

    .. code-block:: c++
        :linenos:
        :caption: Main.cpp
        :emphasize-lines: 2

        #include<iostream>
        #include"Log.h"

        int Multiply(int a, int b)
        {
            Log("Multiply");
            return a * b;
        }

        int main()
        {
            std::cout << Multiply(5, 8) << std::endl;
            std::cin.get();
        }

    build 时会出现以下错误信息： ::

        1>Log.obj : error LNK2005: "void __cdecl Log(char const *)" (?Log@@YAXPBD@Z) already defined in Main.obj
        1>C:\dev\C++\C++Temp\Debug\C++Temp.exe : fatal error LNK1169: one or more multiply defined symbols found

    这是由于在 `Log.cpp` 和 `Main.cpp` 文件中都使用了 `#include"Log.h"` 这条预处
    理指令，这会将 `Log.h` 中的内容复制到 `Log.cpp` 和 `Main.cpp` 中，即会存在两份
    ``Log`` 函数的定义，因此会在链接时产生符号已存在的错误。

    有以下3种解决方式：
        
        1.  `Log.h` 中的 ``Log`` 函数加上 ``static`` 关键字，表示仅在 include 的 .cpp 文件中自己可见
        2.  `Log.h` 中的 ``Log`` 函数加上 ``inline`` 关键字，表示在调用的地方展开（类似宏展开）
        3.  `Log.h` 中的 ``Log`` 函数移到 `Log.cpp` 中

5. C++ 中的变量
--------------------------------------------------------------------------------

``sizeof``

6. C++ 中的函数
--------------------------------------------------------------------------------

7. C++ 中的头文件
--------------------------------------------------------------------------------

``#pragma once`` 告诉预处理器仅包含一次头文件。

``include`` 中的 ``<xxx.h>`` 和 ``xxx.h"``:
如果 `xxx.h` 文件是在当前解决方案的 `include directories` 中的，则使用 ``<xx.h>`` （当然也可以使用 ``xxx.h`` ）;
如果 `xxx.h` 和当前的文件存在相对路径，则使用 ``"xxx.h"`` 或者 ``../xxx.h`` 。

8. 如何在 Visual Studio 中调试 C++ 程序
--------------------------------------------------------------------------------

9. C++ 中的条件和分支（ if语句 ）
--------------------------------------------------------------------------------

10. 关于 C++ 程序最好的 Visual  Studio 设置
--------------------------------------------------------------------------------

11. C++ 中的循环（for, while）
--------------------------------------------------------------------------------


12. C++ 中的流程控制（continue, break, return）
--------------------------------------------------------------------------------

13. C++ 中的指针
--------------------------------------------------------------------------------

指针是一个数整数，一个存储内存地址的数字。
在一个已存在的变量名前加 `&` 以获取变量的地址；在一个指针前面加 `*` 可以对指针解
引用以获取指针指向的变量中的值。

.. code-block:: c++
    :linenos:
    
    #include<iostream>

    int main()
    {
        int var = 8;
        int* ptr = &var;
        *ptr = 10;
        std::cin.get();
    }

上面代码中创建的变量是在栈里的，下面的代码则是在堆上创建了一个数组：

.. code-block:: c++
    :linenos:
    
    #include<iostream>

    int main()
    {
        char* buffer = new char[8];
        memset(buffer, 0, 8);
        delete[] buffer;
        std::cin.get();
    }

除此之外，还可以有指向指针的指针：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 8

    #include<iostream>

    int main()
    {
        char* buffer = new char[8];
        memset(buffer, 0, 8);

        char** ptr = &buffer;
        delete[] buffer;
        std::cin.get();
    }

14. C++ 中的引用
--------------------------------------------------------------------------------

引用不像指针那样可以设置一个为零的值，引用并不占据内存，必须进行初始化。引用只是
为已有的变量创建一个别名，本质上只有一个变量。 

.. code-block:: c++
    :linenos:
    :emphasize-lines: 6,7,8

    #include<iostream>

    int main()
    {
        int a = 5;
        int& ref = a;
        ref = 2;
        std::cout << a << std::endl; // a = 2
        std::cin.get();
    }

引用是关于指针的一个语法糖，看一个在函数中修改变量值的例子：
    
    - 使用指针：
    
        .. code-block:: c++
            :linenos:
            :emphasize-lines: 3,4,5,6,11

            #include<iostream>

            void  Increment(int* value)
            {
                (*value)++;
            }

            int main()
            {
                int a = 5;
                Increment(&a);
                std::cout << a << std::endl; // a = 6
                std::cin.get();
            }

    - 使用引用：

        .. code-block:: c++
            :linenos:
            :emphasize-lines: 3,11

            #include<iostream>

            void  Increment(int& value)
            {
                value++;
            }

            int main()
            {
                int a = 5;
                Increment(a);
                std::cout << a << std::endl; // a = 6
                std::cin.get();
            }

15. C++ 中的类
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:

    #include <iostream>

    class Player
    {
    public:
        int x, y;
        int speed;

        void Move(int xa, int ya)
        {
            x += xa * speed;
            y += ya * speed;
        }
    };

    int main()
    {
        Player player;
        player.x = 5;
        player.Move(1, -1);
        std::cin.get();
    }


16. C++ 中类和结构体的比较
--------------------------------------------------------------------------------

- 类中的成员变量的可见性默认是 `private` 而结构体中成员变量的可见性默认是 `public`；
- 尽量不要在结构体中使用继承。

17. 如何写一个 C++ 的类
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    
    #include <iostream>

    class Log
    {
    public:
        const int ErrorLevel = 0;
        const int WarningLevel = 1;
        const int InfoLevel = 2;

    private:
        int m_LogLevel = 0;

    public:
        void SetLevel(int level)
        {
            m_LogLevel = level;
        }

        void Error(const char* message)
        {
            if (m_LogLevel >= ErrorLevel)
                std::cout << "[ERROR]: " << message << std::endl;
        }
        void Warning(const char* message)
        {
            if (m_LogLevel >= WarningLevel)
                std::cout << "[WARNING]: " << message << std::endl;
        }
        void Info(const char* message)
        {
            if (m_LogLevel >= InfoLevel)
                std::cout << "[INFO]: " << message << std::endl;
        }
    };

    int main()
    {
        Log log;
        log.SetLevel(log.ErrorLevel);
        log.Error("Hello!");
        log.Warning("Hello!");
        log.Info("Hello!");
        std::cin.get();
    }

18. C++ 中的 Static
--------------------------------------------------------------------------------

C++ 中的 `static` 主要有两种不同的使用场景：

    - 在类或结构体内部使用 `static` ;
    - 在类或结构体外部使用 `static` ;

下面展示一些类或结构体外部使用 `static` 的代码片段：

- 场景一

  .. code-block:: c++
        :linenos:
        :caption: Static.cpp
        :emphasize-lines: 1

        int s_Variable = 5;
      
  .. code-block:: c++
        :linenos:
        :caption: Sandbox.cpp
        :emphasize-lines: 3

        #include <iostream>

        int s_Variable = 10;

        int main()
        {
          std::cout << s_Variable << std::endl;
          std::cin.get();
        }
     
  将会出现编译错误： ::
    
    1>Static.obj : error LNK2005: "int s_Variable" (?s_Variable@@3HA) already defined in Sandbox.obj
    1>C:\dev\CppTemp\Debug\Sandbox.exe : fatal error LNK1169: one or more multiply defined symbols found
    
  由于这里（一个编译单元 -- translation unit）有两个同名的全局变量 `s_Variable` 。
     
- 场景二：

  .. code-block:: c++
        :linenos:
        :caption: Static.cpp
        :emphasize-lines: 1

        static int s_Variable = 5;
      
  .. code-block:: c++
        :linenos:
        :caption: Sandbox.cpp
        :emphasize-lines: 3

        #include <iostream>

        int s_Variable = 10;

        int main()
        {
          std::cout << s_Variable << std::endl; // output will be 10
          std::cin.get();
        }
      
  在 `static.cpp` 中定义的 ``s_Variable`` 由于有 ``static`` 修饰，其作用
  类似于使其修饰的变量仅在当前 `.cpp` 文件中可见，因此没有出现场景一中链接错
  误。若在头文件中像这样定义 ``static`` 修饰的变量，在每一个使用该头文件的 `.cpp` 
  文件中都会各自定义一个 ``static`` 变量，这是因为引用头文件本质是将其代码进
  行复制。

- 场景三：

  .. code-block:: c++
        :linenos:
        :caption: Static.cpp
        :emphasize-lines: 1

        int s_Variable = 5;
      
  .. code-block:: c++
        :linenos:
        :caption: Sandbox.cpp
        :emphasize-lines: 3

        #include <iostream>

        extern int s_Variable;

        int main()
        {
          std::cout << s_Variable << std::endl; // output will be 5
          std::cin.get();
        }
      
  在 `static.cpp` 中定义的 ``s_Variable`` 没有 ``static`` 修饰，因此该定义
  对于 `Sandbox.cpp` 是可见的。

19. C++ 类和结构体中的 static
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:

    #include<iostream>

    struct  Entity
    {
        int x, y;
        void Print()
        {
            std::cout << x << " , " << y << std::endl;
        }
    };

    int main()
    {
        Entity entity;
        entity.x = 2;
        entity.y = 3;
        Entity  entity1 = { 5,8 };

        entity.Print();  // output will be "2 , 3"
        entity1.Print(); // output will be "5 , 8"
        std::cin.get();
    }

将成员变量 ``x`` 和 ``y`` 加上 ``static`` 修饰：
 
.. code-block:: c++
    :linenos:
    :emphasize-lines: 5,17

    #include<iostream>

    struct  Entity
    {
        static int x, y;
        void Print()
        {
            std::cout << x << " , " << y << std::endl;
        }
    };

    int main()
    {
        Entity entity;
        entity.x = 2;
        entity.y = 3;
        Entity  entity1 = { 5,8 };

        entity.Print();
        entity1.Print();
        std::cin.get();
    }

由于此时 ``x`` 和 ``y`` 不是实例中的成员，因此编译时将出现以下错误： ::

    1>C:\dev\CppTemp\Debug\Sandbox.exe(17,25): error C2078: too many initializers

继续调整如下：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 5,15,16,19,20,22,23

    #include<iostream>

    struct  Entity
    {
        static int x, y;
        void Print()
        {
            std::cout << x << " , " << y << std::endl;
        }
    };

    int main()
    {
        Entity entity;
        entity.x = 2;
        entity.y = 3;

        Entity entity1;
        entity1.x = 5;
        entity1.y = 8;

        entity.Print();
        entity1.Print();
        std::cin.get();
    }

编译时出现以下错误： ::

    1>Sandbox.obj : error LNK2001: unresolved external symbol "public: static int Entity::x" (?x@Entity@@2HA)
    1>Sandbox.obj : error LNK2001: unresolved external symbol "public: static int Entity::y" (?y@Entity@@2HA)
    1>C:\dev\CppTemp\Debug\Sandbox.exe : fatal error LNK1120: 2 unresolved externals

继续调整如下：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 12,13,25,26

    #include<iostream>

    struct  Entity
    {
        static int x, y;
        void Print()
        {
            std::cout << x << " , " << y << std::endl;
        }
    };

    int Entity::x;
    int Entity::y;

    int main()
    {
        Entity entity;
        entity.x = 2;
        entity.y = 3;

        Entity entity1;
        entity1.x = 5;
        entity1.y = 8;

        entity.Print();     // output will be "5, 8"
        entity1.Print();    // output will be "5, 8"
        std::cin.get();
    }

上述代码等效于：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 18,19,22,23

    #include<iostream>

    struct  Entity
    {
        static int x, y;
        void Print()
        {
            std::cout << x << " , " << y << std::endl;
        }
    };

    int Entity::x;
    int Entity::y;

    int main()
    {
        Entity entity;
        Entity::x = 2;
        Entity::y = 3;

        Entity entity1;
        Entity::x = 5;
        Entity::y = 8;

        entity.Print();     // output will be "5, 8"
        entity1.Print();    // output will be "5, 8"
        std::cin.get();
    }

20. C++ 中的 Local Static
--------------------------------------------------------------------------------

函数第一次被调用时，函数中的 static 变量将被创建一次，后续被调用时将不会再创建。

.. code-block:: c++
    :linenos:
    :emphasize-lines: 5

    #include<iostream>

    void Function()
    {
        static int i = 0;
        i++;
        std::cout << i << std::endl;
    }

    int main()
    {
        Function();     // output will be "1"
        Function();     // output will be "2"
        Function();     // output will be "3"
        Function();     // output will be "4"
        Function();     // output will be "5"
        std::cin.get();
    }

上面的代码等效于下面的代码，只是限制了变量 ``i`` 只能在函数 ``Function()`` 中访问：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 3

    #include<iostream>

    static int i = 0;
    void Function()
    {
        i++;
        std::cout << i << std::endl;
    }

    int main()
    {
        Function();     // output will be "1"
        Function();     // output will be "2"
        Function();     // output will be "3"
        Function();     // output will be "4"
        Function();     // output will be "5"
        std::cin.get();
    }

通常的单例模式代码：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 5,6,9,10,11,12,18,22

    #include<iostream>

    class Singleton
    {
    private:
        static Singleton* s_Instance;

    public:
        static Singleton& Get()
        {
            return *s_Instance;
        }
        void SomeFunc()
        {
        }
    };

    Singleton* Singleton::s_Instance = nullptr;

    int main()
    {
        Singleton::Get().SomeFunc();
        std::cin.get();
    }

使用本节中的 `Local Static` 后代码更简洁：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 6,7,8,9,10

    #include<iostream>

    class Singleton
    {
    public:
        static Singleton& Get()
        {
            static Singleton instance;
            return instance;
        }
        void SomeFunc()
        {
        }
    };

    int main()
    {
        Singleton::Get().SomeFunc();
        std::cin.get();
    }

21. C++  中的枚举
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 6,7,8,9,10,11,24,29,34,42
    
    #include <iostream>

    class Log
    {
    public:
        enum Level //  [ : [ unsigned ] char | int ]
        {
            LevelError = 0,
            LevelWarning,
            LevelInfo
        };

    private:
        Level m_LogLevel = LevelInfo;

    public:
        void SetLevel(Level level)
        {
            m_LogLevel = level;
        }

        void Error(const char* message)
        {
            if (m_LogLevel >= LevelError)
                std::cout << "[ERROR]: " << message << std::endl;
        }
        void Warning(const char* message)
        {
            if (m_LogLevel >= LevelWarning)
                std::cout << "[WARNING]: " << message << std::endl;
        }
        void Info(const char* message)
        {
            if (m_LogLevel >= LevelInfo)
                std::cout << "[INFO]: " << message << std::endl;
        }
    };

    int main()
    {
        Log log;
        log.SetLevel(Log::LevelError);
        log.Error("Hello!");
        log.Warning("Hello!");
        log.Info("Hello!");
        std::cin.get();
    }
    
上面的代码中 `enum Level` 并不是一个名称空间，因此这样访问 ``Log::LevelError`` 
而不是这样访问 ``Level::LevelError`` ;另外由于此处枚举的本质是整数，因
此可以使用比较运算符 `m_LogLevel >= LevelError` 。

22. C++ 中的构造函数
--------------------------------------------------------------------------------

构造函数是一个特殊的方法，在实例化对象的时候被调用。

.. code-block:: c++
    :linenos:
    
    #include <iostream>

    class Entity
    {
    public:
        float x, y;

        void Print()
        {
            std::cout << x << " , " << y << std::endl;
        }
    };

    int main()
    {
        Entity entity;
        entity.Print();
        std::cin.get();
    }
    
上面的代码会得到类似以下的输出： ::
    
    -1.07374e+08 , -1.07374e+08

.. code-block:: c++
    :linenos:
    :emphasize-lines: 17
    
    #include <iostream>

    class Entity
    {
    public:
        float x, y;

        void Print()
        {
            std::cout << x << " , " << y << std::endl;
        }
    };

    int main()
    {
        Entity entity;
        std::cout << entity.x << " , " << entity.y << std::endl;
        std::cin.get();
    }

上面的代码将会出现编译错误： ::

    error C4700: uninitialized local variable 'entity' used
    
这是由于 C++ 类中基础类型的成员变量默认将不会被初始化为“零”，必须手动对其进
行初始化，可以像下面代码中那样写一个构造函数来初始化：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 8,9,10,11,12
    
    #include <iostream>

    class Entity
    {
    public:
        float X, Y;

        Entity()
        {
            X = 0.0f;
            Y = 0.0f;
        }

        void Print()
        {
            std::cout << X << " , " << Y << std::endl;
        }
    };

    int main()
    {
        Entity entity;
        std::cout << entity.X << " , " << entity.Y << std::endl;  // 将会正确输出
        entity.Print(); // 将会正确输出
        std::cin.get();
    }


如果在 C++ 类中没有显示地通过代码创建构造函数，编译器将会实现一个默认的 `public` 
的“空”构造函数：

.. code-block:: c++
    :linenos:
    
    Entity()
    {
    }
    
如果不希望编译器创建默认的构造函数，可以添加下面的代码：

.. code-block:: c++
    :linenos:
    
    Entity() = delete;

另外，可以创建需要传递参数的构造函数：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 14,15,16,17,18,29,31
    
    #include <iostream>

    class Entity
    {
    public:
        float X, Y;

        Entity()
        {
            X = 0.0f;
            Y = 0.0f;
        }

        Entity(float x, float y)
        {
            X = x;
            Y = y;
        }

        void Print()
        {
            std::cout << X << " , " << Y << std::endl;
        }
    };

    int main()
    {
        Entity entity1;
        Entity entity2(10, 5);
        entity1.Print();    // 0 , 0
        entity2.Print();    // 10 , 5
        std::cin.get();
    }

23. C++ 中的析构函数
--------------------------------------------------------------------------------

当对象被销毁的时候析构函数将会被调用，通常在析构函数中释放在构造函数中分配在
堆中的内存；当然也可以手动调用析构函数，但是很少这样做，注意析构函数会被多次调用。

.. code-block:: c++
    :linenos:
    :emphasize-lines: 15,16,17,18,26,27,28,29,30,34

    #include <iostream>

    class Entity
    {
    public:
        float X, Y;

        Entity()
        {
            X = 0.0f;
            Y = 0.0f;
            std::cout << "Created Entity!" << std::endl;
        }

        ~Entity()
        {
            std::cout << "Destroyed Entity!" << std::endl;
        }

        void Print()
        {
            std::cout << X << " , " << Y << std::endl;
        }
    };

    void Function()
    {
        Entity entity;
        entity.Print();
    }

    int main()
    {
        Function();
        std::cin.get();
    }
    
输出为： ::

    Created Entity!
    0 , 0
    Destroyed Entity!

24. C++ 中的继承
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 15,33,34,36,37,38,39
    
    #include <iostream>

    class Entity
    {
    public:
        float X, Y;

        void Move(float xa, float ya)
        {
            X += xa;
            Y += ya;
        }
    };

    class Player : public Entity
    {
    public:
        const char* Name;

        Player(const char* name)
        {
            Name = name;
        }

        void PrintName()
        {
            std::cout << Name << std::endl;
        }
    };

    int main()
    {
        std::cout << sizeof(Entity) << std::endl; // output will be "8"
        std::cout << sizeof(Player) << std::endl; // output will be "12"

        Player player("playerA");
        player.Move(5, 5);
        player.X = 2;
        player.PrintName();

        std::cin.get();
    }

25. C++ 中的虚函数
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 28,29,30,31,38,39

    #include <iostream>
    #include <string>

    class Entity
    {
    public:
        std::string GetName()
        {
            return "Entity";
        }
    };

    class Player : public Entity
    {
    private:
        std::string m_Name;
    public:
        Player(const std::string& name) :m_Name(name)
        {
        }

        std::string GetName()
        {
            return m_Name;
        }
    };

    void PrintName(Entity* entity)
    {
        std::cout << entity->GetName() << std::endl;
    }

    int main()
    {
        Entity* entity = new Entity();
        Player* player = new Player("Cherno");

        PrintName(entity);  // output will be "Entity"
        PrintName(player);  // output will be "Entity"

        delete entity;
        delete player;

        std::cin.get();
    }
    
使用虚函数后（包含 V-Table），有两个额外花销，保存 V-Table 的空间和调用时查表:

.. code-block:: c++
    :linenos:
    :emphasize-lines: 7,22,38,39
    
    #include <iostream>
    #include <string>

    class Entity
    {
    public:
        virtual std::string GetName()
        {
            return "Entity";
        }
    };

    class Player : public Entity
    {
    private:
        std::string m_Name;
    public:
        Player(const std::string& name) :m_Name(name)
        {
        }

        std::string GetName() override // C++ 11 中 override 可选，为了可读性，建议加上
        {
            return m_Name;
        }
    };

    void PrintName(Entity* entity)
    {
        std::cout << entity->GetName() << std::endl;
    }

    int main()
    {
        Entity* entity = new Entity();
        Player* player = new Player("Cherno");

        PrintName(entity);  // output will be "Entity"
        PrintName(player);  // output will be "Cherno"

        delete entity;
        delete player;

        std::cin.get();
    }

26. C++ 中的接口（纯虚函数）
--------------------------------------------------------------------------------

C++ 中的包含纯虚函数的类就是“抽象类”，若所有方法都是纯虚函数，则是“接口”，包含未
实现纯的虚函数的类不能进行实例化操作。

.. code-block:: c++
    :linenos:
    :emphasize-lines: 7,13,22

    #include <iostream>
    #include <string>

    class Printable
    {
    public:
        virtual std::string GetClassName() = 0;
    };

    class Entity : public Printable
    {
    public:
        std::string GetClassName() override // C++ 11 中 override 可选，为了可读性，建议加上
        {
            return "Entity";
        }
    };

    class Player : public Entity
    {
    public:
        std::string GetClassName() override // C++ 11 中 override 可选，为了可读性，建议加上
        {
            return "Player";
        }
    };

    void Print(Printable* obj)
    {
        std::cout << obj->GetClassName() << std::endl;
    }

    int main()
    {
        Entity* entity = new Entity();
        Player* player = new Player();

        Print(entity);  // output will be "Entity"
        Print(player);  // output will be "Player"

        delete entity;
        delete player;

        std::cin.get();
    }

27. C++ 中的可见性（作用域）
--------------------------------------------------------------------------------

可见性是指类中的属性或者方法的可见性，C++ 中有三种可见性，分别是 ``public`` 、 ``protected`` 和 ``private``。
类中的可见性默认是 ``private``, 结构体中的可见性默认是 ``public`` 。

===========     ================================================================
可见性             说明
===========     ================================================================
private         修饰后的成员只能在 **当前类** 或者 **友元** 中进行访问
protected       修饰后的成员只能在 **当前类** 或者 **派生类** 中进行访问
public          修饰后的成员在任何地方都可进行访问
===========     ================================================================


28. C++ 中的数组
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:

    #include<iostream>
    
    int main()
    {
        int example[5];
        example[0] = 2;
        example[4] = 4;
        std::cout << example[0] << std::endl;   // 访问数组中元素
        std::cout << example << std::endl;      // 数组的地址
        std::cin.get();
    }

在上面的代码中数组名称就是一个指向整型（元素类型）的指针：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 6,13

    #include<iostream>

    int main()
    {
        int example[5];
        int* ptr = example;
        for (int i = 0; i < 5; i++)
        {
            example[i] = 2;
        }
        example[2] = 5;
        std::cout << example[2] << std::endl;// 5
        *(ptr + 2) = 6;
        std::cout << example[2] << std::endl;// 6

        std::cin.get();
    }

有时需要通过 `new` 关键字来创建数组，主要是考虑到数组对象的生命周期问题。如果需要
在某个方法种创建并返回数组，则通常需使用 `new` 关键字来创建数组，同时必须在代码中
调用 `delete` 来删除该数组，在此调用之前，该数组将会一直存在：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 5,11,17
    
    #include<iostream>

    int main()
    {
        int example[5];                 // 存储在栈中
        for (int i = 0; i < 5; i++)
        {
            example[i] = 2;
        }

        int* another = new int[5];      // 存储在堆中
        for (int i = 0; i < 5; i++)
        {
            another[i] = 2;
        }

        delete[] another;
        std::cin.get();
    }

C++ 中的数组无法直接获取其中包含的元素的数量：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 6,10

    #include<iostream>

    int main()
    {
        int a[5];
        int count = sizeof(a) / sizeof(int); // 5
        std::cout << count << std::endl;

        int* b = new int[5];
        count = sizeof(b) / sizeof(int); // 0
        std::cout << count << std::endl;

        std::cin.get();
    }

在 C++ 11 中可以通过以下代码获取数组中元素的数量，但是会有额外的开销：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 2,6,7

    #include<iostream>
    #include<array>

    int main()
    {
        std::array<int, 5> c;
        int count = c.size();
        std::cout << count << std::endl; // 5

        std::cin.get();
    }


29. C++ 中的 Stirng 是如何工作的
--------------------------------------------------------------------------------

- C 风格字符串：

 **双引号** 的类型默认为 ``char*`` , 使用 **单引号** 的类型为 ``char``。
 
 ``char* name = "Cherno";`` 这里使用了 C 风格的代码来表示字符串，虽然这里的 ``name`` 是
 一个指针类型，但不需要通过 ``delete name`` 来清理内存，记住仅在使用 new 关键字分
 配内存的时候才使用 ``delete`` 清理内存。 *内存中从指针开始到后面的第一个存储值为
 0的字节部分为字符串的内容。* 这也是下面代码中使用 ``std::cout`` 可以输出完整字符
 串的原因（name2、name3可是指针）。

 .. code-block:: c++
     :linenos:
     :emphasize-lines: 8,9,11,2
 
     #include <iostream>
     
     int main()
     {
         char name2[7] = { 'C','h','e','r','n','o','\0' };
         char name3[7] = { 'C','h','e','r','n','o',0 };
     
         std::cout << sizeof(name2) << std::endl; // output will be "7"
         std::cout << strlen(name3) << std::endl; // output will be "6"
     
         std::cout << name2 << std::endl; // output will be "Cherno"
         std::cout << name3 << std::endl; // output will be "Cherno"
     
         std::cin.get();
     }



- C++ 风格字符串：

  .. code-block:: c++
      :linenos:
      :emphasize-lines: 2,7,8
  
      #include <iostream>
      #include <string>

      int main()
      {
          std::string name = "Cherno";
          std::cout << name.size() << std::endl;  // output will be "6"
          std::cout << name << std::endl;         // output will be "Cherno"
          std::cin.get();
      }
  
  使用下面两种方式进行字符串的拼接：
  
      .. code-block:: c++
          :linenos:

          std::string name = "Cherno";
          name += "another";

      .. code-block:: c++
          :linenos:

          std::string name = std::string("Cherno") + "another";


30. C++ 中的 Stirng 字面量
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 5,8,9

    #include <iostream>

    int main()
    {
        const char name[8] = "Che\0rno";        // \0 represents NUL
        //const char name[] = "Che\0rno"        // same as above

        std::cout << strlen(name) << std::endl;  // output will be "3"
        std::cout << name << std::endl;          // output will be "Che"
        std::cin.get();
    }

.. code-block:: c++
    :linenos:
    :emphasize-lines: 5,8,9

    #include <iostream>

    int main()
    {
        const char* name = "Cherno"; // or u8"Cherno"   // UTF-8,1 bytes per character
        const wchar_t* name2 = L"Cherno";               // 1 or 2 or 4 byte(s) per character
        const char16_t* name3 = u"Cherno";              // UTF-16,2 bytes per character
        const char32_t* name4 = U"Cherno";              // UTF-32,4 bytes per character

        std::string s_name = "Cherno";
        std::wstring s_name2 = L"Cherno";
        std::u16string s_name3 = u"Cherno";
        std::u32string s_name4 = U"Cherno";

        const char* paragraph = R"(Line1
    Line2
    Line3
    Line4)";

        const char* paragraph2 = "Line1\n"
            "Line2\n"
            "Line3\n"
            "Line4\n";

        std::cout << paragraph << std::endl;
        std::cout << paragraph2 << std::endl;
        std::cin.get();
    }

输出为： ::

    Line1
    Line2
    Line3
    Line4
    Line1
    Line2
    Line3
    Line4

.. Warning::

    字符串总是存储在只读的内存空间中。

.. code-block:: c++
    :linenos:
    :emphasize-lines: 6,8

    #include <iostream>

    int main()
    {
        char name[] = "Cherno";
        name[2] = 'a';

        std::cout << name << std::endl; // output will be "Charno"
        std::cin.get();
    }

31. C++ 中的常量
--------------------------------------------------------------------------------

使用 `const` 修饰的变量表示其不希望在程序中被修改。

- 基本使用场景：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 5

        #include<iostream>

        int main()
        {
            const int MAX_AGE = 90;
            int* a = new int;

            a = (int*)&MAX_AGE;

            std::cout << *a << std::endl;
            std::cin.get();
        }

- 修饰类中的成员方法：
  
    表示方法不会对成员变量进行修改。

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 9,20,21,22,23,28 

        #include<iostream>

        class  Entity
        {
        private:
            int m_X, m_Y;

        public:
            int GetX() const
            {
                return m_X;
            }

            void SetX(int x)
            {
                m_X = x;
            }
        };

        void PrinEntity(const Entity& e)
        {
            std::cout << e.GetX() << std::endl;
        }

        int main()
        {
            Entity e;
            PrinEntity(e);
            std::cin.get();
        }

32. C++ 中的 Mutable 关键字
--------------------------------------------------------------------------------

`Mutable` 单词的意思为“可以修改的”，C++ 中主要又两个使用场景，分别是：

    - Const 常量相关
    - Lambda 表达式相关

- 在常量上下文中的 mutable 使用：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 6,8,10
        
        #include<iostream>

        class  Entity
        {
        private:
            std::string m_Name;
        public:
            const std::string& GetName() const
            {
                return m_Name;
            }
        };

        int main()
        {
            const Entity e;
            e.GetName();

            std::cin.get();
        }

    使用 `mutable` 关键字修饰的类成员变量使其可以在 const 方法中被修改：

        .. code-block:: c++
            :linenos:
            :emphasize-lines: 7,10,12

            #include<iostream>

            class  Entity
            {
            private:
                std::string m_Name;
                mutable int m_DebugCount = 0;

            public:
                const std::string& GetName() const
                {
                    m_DebugCount++;
                    return m_Name;
                }
            };

            int main()
            {
                const Entity e;
                e.GetName();

                std::cin.get();
            }

- 在 Lambda 上下文中使用 mutable:
    
    .. code-block:: c++
        :linenos:
        :emphasize-lines: 6,7,8,9,10,11

        #include<iostream>

        int main()
        {
            int x = 8;
            auto f = [=]()
            {
                int y = x;
                y++;
                std::cout << y << std::endl;
            };

            f();

            std::cin.get();
        }
    
    `[=]` 表示在 Lambda 中对外部的局部变量以值拷贝的方式使用，`[&]` 表示以引用的
    方式使用。使用 `mutable` 关键字修饰 Lambda 可以对上面的代码进行简化：

        .. code-block:: c++
            :linenos:
            :emphasize-lines: 6,7,8,9

            #include<iostream>

            int main()
            {
                int x = 8;
                auto f = [=]() mutable
                {
                    std::cout << ++x << std::endl;
                };

                f();
                // x = 8 here

                std::cin.get();
            }
    

33. C++ 中的成员初始化列表（构造函数初始化器列表）
--------------------------------------------------------------------------------

类成员初始化的几种方式：

-   方式一（构造函数中初始化）

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 11,16

        #include <iostream>

        class Entity
        {
        private:
            std::string m_Name;

        public:
            Entity()
            {
                m_Name = "Unknown";
            }

            Entity(const std::string& name)
            {
                m_Name = name;
            }

            const std::string& GetName() const { return m_Name; }
        };

        int main()
        {
            Entity entity;
            Entity entity2("Cherno");

            std::cout << entity.GetName() << std::endl;  // output will be "Unknown"
            std::cout << entity2.GetName() << std::endl; // output will be "Cherno"
            std::cin.get();
        }

-   方式二（成员初始化列表）

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 10,15

        #include <iostream>

        class Entity
        {
        private:
            std::string m_Name;

        public:
            Entity()
                : m_Name("Unknown")
            {
            }

            Entity(const std::string& name)
                : m_Name(name)
            {
            }

            const std::string& GetName() const { return m_Name; }
        };

        int main()
        {
            Entity entity;
            Entity entity2("Cherno");

            std::cout << entity.GetName() << std::endl;  // output will be "Unknown"
            std::cout << entity2.GetName() << std::endl; // output will be "Cherno"
            std::cin.get();
        }

    当有多个成员变量的时候，注意成员初始化列表中的顺序需要与它们定义的顺序保持一
    致，否则可能会导致某些编译器报错，这是因为类中成员变量初始化总是按照它们在类
    中出现的先后顺序确定的。

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 4,5,9

        class Entity
        {
        private:
            std::string m_Name;
            int m_Score;

        public:
            Entity()
                : m_Name("Unknown"), m_Score(0)
            {
            }
        };

为什么需要成员初始化列表？

    -   避免额外无意义的初始化
        
        .. code-block:: c++
            :linenos:
            :emphasize-lines: 8,10

            class Entity
            {
            private:
                std::string m_Name;
                int m_Score;

            public:
                Entity()
                    : m_Score(0) // without [ m_Name("Unknown") ] here
                {
                    m_Name = "Unknown";
                }
            };
        
        上面的代码中，我们没有在成员初始化列表中对 ``m_Name`` 成员进行初始化，而
        是将其初始化代码添加到构造函数体内部。这会导致 ``m_Name`` 进行两次初始化。
        第一次是默认的，第二次是在构造函数体中我们编码写的。
    
    -   演示代码

        .. code-block:: c++
            :linenos:
            :emphasize-lines: 6,7,8,9,11,12,13,14,23,24,25,26

            #include <iostream>

            class  Example
            {
            public:
                Example()
                {
                    std::cout << "Created Example !" << std::endl;
                }

                Example(int x)
                {
                    std::cout << "Created Example With " << x << "!" << std::endl;
                }
            };

            class Entity
            {
            private:
                Example m_Example;

            public:
                Entity()
                {
                    m_Example = Example(8);
                }
            };

            int main()
            {
                Entity entity;
                std::cin.get();
            }

        将会输出： ::

            Created Example !
            Created Example With 8!

        如果我们使用成员初始化列表：

        .. code-block:: c++
            :linenos:
            :emphasize-lines: 24

            #include <iostream>

            class  Example
            {
            public:
                Example()
                {
                    std::cout << "Created Example !" << std::endl;
                }

                Example(int x)
                {
                    std::cout << "Created Example With " << x << "!" << std::endl;
                }
            };

            class Entity
            {
            private:
                Example m_Example;

            public:
                Entity()
                    : m_Example(Example(8)) // or : m_Example(8)
                {
                }
            };

            int main()
            {
                Entity entity;
                std::cin.get();
            }

        输出将会是： ::
        
            Created Example With 8!

34. 三元运算符
--------------------------------------------------------------------------------

略。

35. C++ 中如何创建并初始化对象
--------------------------------------------------------------------------------

C++ 中对像的创建主要有两种，主要根据对象在内存中的创建的位置进行分类，栈中 和 堆中。
栈中的对象的生命周期在离开其作用域后结束，而堆中的对象的生命周期将由编程人员决定。

栈通常不会很大，因此如果需要创建大量的对象的时候，考虑在堆中创建。

使用 ``new`` 关键字创建的对象在堆中，注意使用 ``delete`` 删除堆中分配的内存。

.. code-block:: c++
    :linenos:
    :emphasize-lines: 17,18,20,22,23,25

    #include <iostream>

    class Entity
    {
    private:
        std::string m_Name;

    public:
        Entity() : m_Name("Unknown") {}
        Entity(const std::string& name) : m_Name(name) {}

        const std::string& GetName() const { return m_Name; }
    };

    int main()
    {
        Entity entity1("Cherno");               // stack
        Entity* entity2 = new Entity("Cherno"); // heap

        std::cout << entity1.GetName() << std::endl;

        std::cout << (*entity2).GetName() << std::endl;
        std::cout << entity2->GetName() << std::endl;

        delete entity2;

        std::cin.get();
    }


36. C++ 中的 NEW 关键字
--------------------------------------------------------------------------------

``new`` 关键字除了寻找恰当大小的内存以存储目标对象，还会进行构造函数的调用。

.. code-block:: c++
    :linenos:
    :emphasize-lines: 17,18,19,21,22,23,25,26,27,28

    #include <iostream>

    class Entity
    {
    private:
        std::string m_Name;

    public:
        Entity() : m_Name("Unknown") {}
        Entity(const std::string& name) : m_Name(name) {}

        const std::string& GetName() const { return m_Name; }
    };

    int main()
    {
        int a = 2;
        int* b = new int;
        int* c = new int[50];

        Entity* entity1 = new Entity; // or new Entity();
        Entity* entity2 = new Entity[50];
        // Entity* entity2 = new(c) Entity[50]; // 指定在哪里创建对象

        delete b;
        delete[] c;
        delete entity1;
        delete[] entity2;

        std::cin.get();
    }


37. C++ 中的隐式转换和 Explict 关键字
--------------------------------------------------------------------------------

-   隐式类型转换

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 25,26,27,29,30,31,33,34,35

        #include <iostream>

        class Entity
        {
        private:
            std::string m_Name;
            int m_Age;

        public:
            Entity(int age)
                : m_Name("Unknown"), m_Age(age) {}

            Entity(const std::string& name)
                : m_Name(name), m_Age(-1) {}

            const std::string& GetName() const { return m_Name; }
        };

        void Print(const Entity& entity)
        {
        }

        int main()
        {
            Entity a1("Cherno");
            Entity a2 = Entity("Cherno");
            Entity a3 = std::string("Cherno"); // only use "Cherno" is ok in tutorial video

            Entity b2(22);
            Entity b1 = Entity(22);
            Entity b3 = 22;

            Print(22);              // 如果存在 Print(int) 前面的函数，则会调用这个更匹配的
            // Print("Cherno");     // 这会失败因为仅允许一次隐式类型转化
            Print(std::string("Cherno"));

            std::cin.get();
        }

-   explicit 关键字

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 9,20,22

        #include <iostream>

        class Entity
        {
        private:
            int m_Age;

        public:
            explicit Entity(int age) : m_Age(age) {}
        };

        void Print(const Entity& entity)
        {
        }

        int main()
        {
            Entity b2(22);
            Entity b1 = Entity(22);
            // Entity b3 = 22;  // this will be fail

            // Print(22);       // this will be fail

            std::cin.get();
        }

C++ 中只会进行一次隐式类型转换，不会进行多次隐式类型转换。

38. C++ 中的操作符和操作符重载
--------------------------------------------------------------------------------

C++ 中的操作符仅仅是一个函数。

.. code-block:: c++
    :linenos:
    :emphasize-lines: 10,11,12,13,15,16,17,18,20,21,22,23,25,26,27,28,30,31,32,33,36,37,38,39,40,48,50

    #include <iostream>

    struct  Vector2
    {
        float x, y;

        Vector2(float x, float y)
            :x(x), y(y) {}

        Vector2 operator+(const Vector2& other) const
        {
            return Vector2(x + other.x, y + other.y);
        }

        Vector2 Add(const Vector2& other) const
        {
            return *this + other; // or return operator+(other);
        }

        Vector2 operator*(const Vector2& other) const
        {
            return Vector2(x * other.x, y * other.y);
        }

        bool operator==(const Vector2& other) const
        {
            return x == other.x && y == other.y;
        }

        bool operator!=(const Vector2& other) const
        {
            return !(*this == other);// or return !operator==(other);
        }
    };

    std::ostream& operator<<(std::ostream& stream, const Vector2& other)
    {
        stream << other.x << ", " << other.y;
        return stream;
    }

    int main()
    {
        Vector2 positon(4.0f, 4.0f);
        Vector2 speed(0.5f, 1.5f);
        Vector2 powerup(1.1f, 1.1f);

        Vector2 result1 = positon + speed * powerup;

        std::cout << result1 << std::endl;
        std::cin.get();
    }

:ref:`仿函数中的重载 <src/C++:临时对象的产生与运用>`

39. C++ 中的 this 关键字
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 8,9

    class Entity
    {
    public:
        int x, y;

        Entity(int x, int y)
        {
            this->x = x;
            this->y = y;
        }
    };

40. C++ 中的对象生命周期
--------------------------------------------------------------------------------

-   作用域（scope）
    
        -   函数作用域
            
            .. code-block:: c++
                :linenos:
                :emphasize-lines: 2,3,4
                
                if(condition)
                {
                    // code here
                }
        -   空作用域

            .. code-block:: c++
                :linenos:
                :emphasize-lines: 1,3
                
                {
                    // code here
                }

        -   类作用域

            .. code-block:: c++
                :linenos:
                :emphasize-lines: 19,20,21
                
                #include<iostream>

                class Entity
                {
                public:
                    Entity()
                    {
                        std::cout << "Entity Created!" << std::endl;
                    }

                    ~Entity()
                    {
                        std::cout << "Entity Destoried!" << std::endl;
                    }
                };

                int main()
                {
                    {
                        Entity e;   // output will be "Entity Created!"
                    }               // output will be "Entity Destoried!"

                    std::cin.get();
                }
                
            上面代码中的 ``e`` 对象是在 **栈** 空间中创建的，在其作用域结束时（第 
            21 行）由于栈空间中其内存的释放，该对象被销毁，因此其析构函数被调用。


            与上面的代码不同的是，下面代码中的 ``e`` 指针指向了分配在堆中的对象，
            在其作用域结束时（第 21 行）由于栈空间中其内存的释放，该 **指针** 被
            销毁， *但指针所指向的堆中的对象并没有被销毁* ，相反该堆中的对象在程序
            终止后由操作系统将其销毁。

            .. code-block:: c++
                :linenos:
                :emphasize-lines: 19,20,21

                #include<iostream>

                class Entity
                {
                public:
                    Entity()
                    {
                        std::cout << "Entity Created!" << std::endl;
                    }

                    ~Entity()
                    {
                        std::cout << "Entity Destoried!" << std::endl;
                    }
                };

                int main()
                {
                    {
                        Entity* e = new Entity;   // output will be "Entity Created!"
                    }

                    std::cin.get();
                }

            注意事项：
                
                下面代码 ``int* CreateArray()`` 函数中，由于 ``array`` 数组是在栈
                中创建的，因此在该函数的作用域结束后，该 ``array`` 数组对象将被销
                毁，因此 ``main`` 函数中的指针 ``a`` 将不会获得一个有效的数组（该
                指针指向的数组在 ``CreateArray`` 方法返回后就被销毁了，虽然该指针
                还指向之前的那个地址）：

                .. code-block:: c++
                    :linenos:
                    :emphasize-lines: 3,4,5,6,7,11

                    #include<iostream>

                    int* CreateArray()
                    {
                        int array[50];
                        return array;
                    }

                    int main()
                    {
                        int* a = CreateArray();
                        std::cin.get();
                    }

                可以在 ``int* CreateArray()`` 函数中在堆中创建数组对象，这样在该
                函数的作用域结束后，堆中的数组对象并不会被销毁，这样就可以在 ``main`` 
                函数中获得预期的数组对象：

                .. code-block:: c++
                    :linenos:
                    :emphasize-lines: 5,6,7,11

                    #include<iostream>

                    int* CreateArray()
                    {
                        int* array = new int[50];
                        return array;
                    }

                    int main()
                    {
                        int* a = CreateArray();
                        std::cin.get();
                    }
            
            利用作用域创建智能指针：

                .. code-block:: c++
                    :linenos:
                    :emphasize-lines: 17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,39,40,41

                    #include<iostream>

                    class Entity
                    {
                    public:
                        Entity()
                        {
                            std::cout << "Entity Created!" << std::endl;
                        }

                        ~Entity()
                        {
                            std::cout << "Entity Destoried!" << std::endl;
                        }
                    };

                    class  ScopedPtr
                    {
                    private:
                        Entity* m_Ptr;
                    public:

                        ScopedPtr(Entity* ptr)
                            :m_Ptr(ptr)
                        {
                        }
                        ~ScopedPtr()
                        {
                            delete m_Ptr;
                        }
                    };

                    int main()
                    {
                        {
                            Entity* e1 = new Entity;
                        }

                        {
                            ScopedPtr e2 = new Entity;  // 隐式转换
                        }
                        std::cin.get();
                    }

                输出： ::

                    Entity Created!
                    Entity Created!
                    Entity Destoried!
            
            Timer base on scope
            
            Mutex lock base on scope


41. C++ 中的智能指针
--------------------------------------------------------------------------------

C++ 中的智能指针就是在使用 ``new`` 关键字分配内存后不需要你手动地去 ``delete`` 掉
这部分内存。

1.  unique pointer (a kind of socped pointer)

    unique pinter 不能复制

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 2,23,25,27

        #include<iostream>
        #include<memory>

        class Entity
        {
        public:
            Entity()
            {
                std::cout << "Entity Created!" << std::endl;
            }

            ~Entity()
            {
                std::cout << "Entity Destoried!" << std::endl;
            }

            void Print() {};
        };

        int main()
        {
            {
                std::unique_ptr<Entity> entity1 = std::make_unique<Entity>();   // or : std::unique_ptr<Entity> entity1(new Entity);

                // std::unique_ptr<Entity> entity2 = entity1; // 这是不允许的

                entity1->Print();
            }
            std::cin.get();
        }

    输出： ::

        Entity Created!
        Entity Created!
        Entity Destoried!
        Entity Destoried!

2.  shared pointer(based on reference counting)

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 22,23,24,25,26,27,28,29

        #include<iostream>
        #include<memory>

        class Entity
        {
        public:
            Entity()
            {
                std::cout << "Entity Created!" << std::endl;
            }

            ~Entity()
            {
                std::cout << "Entity Destoried!" << std::endl;
            }

            void Print() {};
        };

        int main()
        {
            {
                std::shared_ptr<Entity> entity1;
                {
                    std::shared_ptr<Entity> entity2 = std::make_shared<Entity>();   // or : std::shared_ptr<Entity> entity2 (new Entity);
                                                                                    // 引用计数为一
                    entity1 = entity2;      // 引用计数加一
                }   //  entity2 的作用域结束，引用计数减一
            }       //  entity1 的作用域结束，引用计数减一，对象被销毁
            std::cin.get();
        }

    将 `shared_ptr` 拷贝给 `weak_ptr` ，不会增加 `shared_ptr` 的引用计数：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 22,23,24,25,26,27,28,29

        #include<iostream>
        #include<memory>

        class Entity
        {
        public:
            Entity()
            {
                std::cout << "Entity Created!" << std::endl;
            }

            ~Entity()
            {
                std::cout << "Entity Destoried!" << std::endl;
            }

            void Print() {};
        };

        int main()
        {
            {
                std::weak_ptr<Entity> entity1;
                {
                    std::shared_ptr<Entity> entity2 = std::make_shared<Entity>();   // or : std::shared_ptr<Entity> entity2 (new Entity);
                                                                                    // 引用计数为一
                    entity1 = entity2;      // 引用计数不变
                }   //  entity2 的作用域结束，引用计数减一，对象被销毁
            }       //  entity1 的作用域结束
            std::cin.get();
        }

      

42. Copying and Copy Constructors in C++
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 17,18,19,20,21,22,23,24

    #include <iostream>

    class String
    {
    private:
        char* m_Buffer;
        unsigned int m_Size;

    public:
        String(const char* string)
        {
            m_Size = strlen(string);
            m_Buffer = new char[m_Size + 1];
            memcpy(m_Buffer, string, m_Size + 1);
        }

        ~String()
        {
            delete[] m_Buffer;
        }

        friend std::ostream& operator<<(std::ostream& stream, const String& string);
    };

    std::ostream& operator<<(std::ostream& stream, const String& string)
    {
        stream << string.m_Buffer;
        return stream;
    }

    int main()
    {
        String string = "Cherno";
        std::cout << string << std::endl; // output will be "Cherno"
        std::cin.get();
    }

我们进行一次复制操作：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 34

    #include <iostream>

    class String
    {
    private:
        char* m_Buffer;
        unsigned int m_Size;

    public:
        //String(const String& string) = delete; // use this to remove the default copy constructor
        String(const char* string)
        {
            m_Size = strlen(string);
            m_Buffer = new char[m_Size + 1];
            memcpy(m_Buffer, string, m_Size + 1);
        }

        ~String()
        {
            delete[] m_Buffer;
        }

        friend std::ostream& operator<<(std::ostream& stream, const String& string);
    };

    std::ostream& operator<<(std::ostream& stream, const String& string)
    {
        stream << string.m_Buffer;
        return stream;
    }

    int main()
    {
        String string = "Cherno";
        String second = string;

        std::cout << string << std::endl;
        std::cout << second << std::endl;

        std::cin.get();
    }

输出：::

    Cherno
    Cherno

程序输出正确，然而当我们在命令行输出窗口中按下回车键，程序运行到 40 行时，程序将
崩溃。这是由于 C++ 中默认的复制操作底层实现是将类中的所有成员进行简单的复制，也
就是说在 ``string`` 和 ``second`` 对象中的成员 ``m_Buffer`` 和 ``m_Size`` 拥有相
同的值，程序运行到最后时，对象将会调用其析构函数，导致同一个 ``m_Buffer`` 值作为
参数被连续两次调用 `delete[]` ，这就是崩溃的原因。

按如下调整可解决该问题：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 17,18,19,20,21,22,23,24

    #include <iostream>

    class String
    {
    private:
        char* m_Buffer;
        unsigned int m_Size;

    public:
        String(const char* string)
        {
            m_Size = strlen(string);
            m_Buffer = new char[m_Size + 1];
            memcpy(m_Buffer, string, m_Size + 1);
        }

        //String(const String& other) = delete; // use this to remove the default copy constructor
        String(const String& other)
            : m_Size(other.m_Size)
        {
            std::cout << "String Copied!" << std::endl;
            m_Buffer = new char[m_Size + 1];
            memcpy(m_Buffer, other.m_Buffer, m_Size + 1);
        }

        char& operator[](unsigned int index)
        {
            return m_Buffer[index];
        }

        ~String()
        {
            delete[] m_Buffer;
        }

        friend std::ostream& operator<<(std::ostream& stream, const String& string);
    };

    std::ostream& operator<<(std::ostream& stream, const String& string)
    {
        stream << string.m_Buffer;
        return stream;
    }

    void PrintString(String string)
    {
        std::cout << string << std::endl;
    }

    int main()
    {
        String string = "Cherno";
        String second = string;

        PrintString(string);
        PrintString(second);

        std::cin.get();
    }

输出为： ::

    String Copied!
    String Copied!
    Cherno
    String Copied!
    Cherno

拷贝发生在 53，55，56 三处，其中 55，56 两行发生的拷贝可将 45 行代码调整如下解决：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 1

    void PrintString(const String& string)


43. C++ 中的箭头（->）操作符
--------------------------------------------------------------------------------

-   基础使用

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 18,19,20

        #include<iostream>

        class Entity
        {
        public:

            void Print()
            {
                std::cout << "Hello!" << std::endl;
            };
        };

        int main()
        {
            Entity e;
            e.Print();

            Entity* ptr = &e;
            ptr->Print();
            (*ptr).Print();

            Entity& entity = *ptr;
            entity.Print();

            std::cin.get();
        }

-   在 Scoped Pointer 中使用

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 27,28,29,30,39,40

        #include<iostream>

        class Entity
        {
        public:
            void Print()
            {
                std::cout << "Hello!" << std::endl;
            };
        };

        class  ScopedPtr
        {
        private:
            Entity* m_Ptr;
        public:

            ScopedPtr(Entity* ptr)
                :m_Ptr(ptr)
            {
            }
            ~ScopedPtr()
            {
                delete m_Ptr;
            }

            Entity* operator->()
            {
                return m_Ptr;
            }
        };

        int main()
        {
            Entity* e1 = new Entity;
            e1->Print();
            delete e1;

            ScopedPtr e2 = new Entity;
            e2->Print();

            std::cin.get();
        }

-   获取成员在内存中的偏移

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 10

        #include<iostream>

        struct Vector3
        {
            float x, y, z;
        };

        int main()
        {
            int offset = (int)&(((Vector3*)nullptr)->y);
            std::cout << offset << std::endl;   // output will be "4"

            std::cin.get();
        }

44. C++ 中的动态数组
--------------------------------------------------------------------------------

``std::vector<Vertex> vertices;`` 还是 ``std::vector<Vertex*> vertices;`` ？

第一种是在栈空间中创建数组，在内存中是连续的，因此遍历的效率会好一些。但是如果需
要 resize 的话，就需要将整个数据拷贝到另一个更大的内存空间中，会有一定的开销。

第二种是则是在堆空间中创建数组，在内存中通常不是连续的，因此遍历的效率会差一些。
但是 resize 的时候会少一些拷贝的开销。

.. code-block:: c++
    :linenos:

    #include<iostream>
    #include<vector>

    struct Vertex
    {
        float x, y, z;
    };

    std::ostream& operator<<(std::ostream& stream, const Vertex& vertex)
    {
        stream << vertex.x << ", " << vertex.y << ", " << vertex.z;
        return stream;
    }

    int main()
    {
        std::vector<Vertex> vertices;

        // 添加元素
        vertices.push_back({ 1,2,3 });
        vertices.push_back({ 4,5,6 });

        // 遍历元素
        for (int i = 0; i < vertices.size(); i++)
        {
            std::cout << vertices[i] << std::endl;
        }

        for (const Vertex& v : vertices)
        {
            std::cout << v << std::endl;
        }

        // 移除元素
        vertices.erase(vertices.begin() + 1);

        // 清除
        vertices.clear();

        std::cin.get();
    }

std::vector 更像是是 array list

45. C++ 中的 std-vector 使用优化
--------------------------------------------------------------------------------

使用 ``std::vector`` 向里面 ``push_back`` 元素时，如果 vector 的 capcity 无法完
成此次添加的操作，则需要分配一个更大的内存空间以将新添加的元素容纳进来，并把原来
内存空间中的数据拷贝到新分配的空间中。在使用 ``std::vector`` 过程中，如何避免这
种元素数据的拷贝？

.. code-block:: c++
    :linenos:
    :emphasize-lines: 13,14,15,16,17,24,25,26

    #include<iostream>
    #include<vector>

    struct Vertex
    {
        float x, y, z;

        Vertex(float x, float y, float z)
            :x(x), y(y), z(z)
        {
        }

        Vertex(const Vertex& vertex)
            :x(vertex.x), y(vertex.y), z(vertex.z)
        {
            std::cout << "Copied!" << std::endl;
        }
    };

    int main()
    {
        std::vector<Vertex> vertices;

        vertices.push_back(Vertex(1, 2, 3));
        vertices.push_back(Vertex(4, 5, 6));
        vertices.push_back(Vertex(7, 8, 9));

        std::cin.get();
    }

输出： ::

    Copied!
    Copied!
    Copied!
    Copied!
    Copied!
    Copied!

在上面的代码中，有两种类型的数据拷贝：
    
    1.  ``vertices.push_back(Vertex(1, 2, 3));`` 这里调用 `vector` 的 `push_back` 
        时，``Vertex(1, 2, 3`` 会在 ``mian`` 方法所在的 `stack frame` 中进行构建，
        然后在方法调用时拷贝到 `vector` 对象所在的 `stack frame` ；

            可以通过调用 ``vertices.push_back`` 而不是 ``vertices.push_back`` 避
            免这种类型的拷贝：

            .. code-block:: c++
                :linenos:
                :lineno-start: 24
                :emphasize-lines: 1,2,3

                vertices.emplace_back(1, 2, 3);
                vertices.emplace_back(4, 5, 6);
                vertices.emplace_back(7, 8, 9);
            
            输出： ::

                Copied!
                Copied!
                Copied!

            ``emplace_back`` 方法中传递的是构建目标对象的参数列表，而不是已构建好
            的对象本身。

    2.  上面代码创建的 `vertices` 对象默认的 `capacity` 是 ``1`` ，因此添加第二个
        元素的时候就需要把之前的元素拷贝到新分配的更大的内存空间中。

            可以通过调用 ``vertices.reserve(3);`` 来告诉 vector 准备创建可容纳 3
            个元素的的对象：

            .. code-block:: c++
                :linenos:
                :lineno-start: 20
                :emphasize-lines: 5,6,7,8

                int main()
                {
                    std::vector<Vertex> vertices;

                    vertices.reserve(3);
                    vertices.emplace_back(1, 2, 3);
                    vertices.emplace_back(4, 5, 6);
                    vertices.emplace_back(7, 8, 9);

                    std::cin.get();
                }

            这时将不会有任何输出，即避免了之前两种拷贝的发生。

46. C++ 中库的使用（静态链接）
--------------------------------------------------------------------------------

includes: a bounch of header files.

libraries: pre-compiled binaries, static or dynamic.

静态链接效率通常会好一些。

visual studio 中设置：

    1.   include directories:

        ``Project Properties -> Configuration Properties -> C/C++ -> General -> Adding include Directories``

    2.  include directories:
        
        ``Project Properties -> Configuration Properties -> Linker -> General -> Additional Library Directories``
        
        ``Project Properties -> Configuration Properties -> Linker -> Input -> Additional Dependencies`` : ``glfw3.lib``

        如果设置了第一项，第二项中只填入库文件的相对路径就行，否则需要在第二项中填入完整的库文件路径。
        

.. code-block:: c++
    :linenos:
    :emphasize-lines: 2,3,7

    #include <iostream>
    // #include <GLFE/glfw3.h>
    extern "C" int glfwInit();

    int main()
    {
        int a  = glfwInit();
        std::cout << a << std::endl;

        std::cin.get();
    }


47. C++ 中使用动态链接库
--------------------------------------------------------------------------------

visual studio 中设置：

    1.  include directories:

        ``Project Properties -> Configuration Properties -> C/C++ -> General -> Adding include Directories``

    2.  include directories:
        
        ``Project Properties -> Configuration Properties -> Linker -> General -> Additional Library Directories``
        
        ``Project Properties -> Configuration Properties -> Linker -> Input -> Additional Dependencies`` : ``glfw3dll.lib`` (注意保证 ``glfw3dll.lib`` 与 ``glfw3.dll`` 是同时编译的 )

        如果设置了第一项，第二项中只填入库文件的相对路径就行，否则需要在第二项中填入完整的库文件路径。

        **运行程序时，需要把 ``glfw3.dll`` 放到程序所在的路径下。**

48. 创建和使用 C++ 库
--------------------------------------------------------------------------------

1.  Visual Studio 中创建一个空的 C++ 项目 ``Game`` ; 然后再添加一个空的 C++ 项目 ``Engine`` 。

2.  在 ``Game`` 项目的 `Project Properties -> Configuration Properties -> General -> General Properties -> Configuration Type` 选项中设置为 ``Application (.exe)`` 。

3.  在 ``Engine`` 项目的 `Project Properties -> Configuration Properties -> General -> General Properties -> Configuration Type` 选项中设置为 ``Static library (.lib)`` 。

4.  在 ``Game`` 项目的 ``Project Properties -> Configuration Properties -> C/C++ -> General -> Adding include Directories`` 选项中添加 ``Engine`` 项目中头文件所在的路径。（为了编译通过）

5.  在 ``Game`` 项目的引用中添加对 ``Engine`` 项目的引用。（为了链接通过）



49. C++ 中如何处理多个返回值
--------------------------------------------------------------------------------

``结构体`` ``以引用的方式传递待返回的数据到方法中`` ``std::tuple`` ``std::pair``

50. C++ 中的模板
--------------------------------------------------------------------------------

C++ 中的模板有些类似于 CSharp 中的泛型，模板在编译的时候被“展开”，而宏则是
在此之前进行“展开”（简单的文本替换）。

没有使用模板的代码：

    .. code-block:: c++
        :linenos:
        
        #include<iostream>

        void Print(int value)
        {
            std::cout << value << std::endl;
        }
        void Print(float value)
        {
            std::cout << value << std::endl;
        }
        void Print(std::string value)
        {
            std::cout << value << std::endl;
        }

        int main()
        {
            Print(5);
            Print("Hello");
            Print(5.5f);
            std::cin.get();
        }
        
使用模板后的代码：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 3,4,11,12,13
        
        #include<iostream>

        template<typename T>    // or : template<class T>
        void Print(T value)
        {
            std::cout << value << std::endl;
        }

        int main()
        {
            Print(5);           // or : Print<int>(5);
            Print("Hello");     // or : Print<std::string>("Hello");
            Print(5.5f);        // or : Print<float>(5.5f);
            std::cin.get();
        }

编译时，编译器会根据代码的情况将模板生成相应的代码，然后进行编译。比如上面的
代码中，编译器就会生成3个函数 ``void Print(int value)`` 、 ``void Print(float value)`` 和 ``void Print(std::string value)`` 。
如果代码中没有任何调用模板的代码，则编译器不会生成相应的函数。当不需要编译器
生成函数的时候，如果模板中的代码有错误，有些编译器是不会报错的。

示例：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 3,7,15
        
        #include<iostream>

        template<typename T, int N>
        class Array
        {
        private:
            T m_Array[N];

        public:
            int GetSize() const { return N; };
        };

        int main()
        {
            Array<int, 5> array;
            std::cout << array.GetSize() << std::endl;
            std::cin.get();
        }


51. C++ 中的栈和堆
--------------------------------------------------------------------------------

52. C++ 中的宏
--------------------------------------------------------------------------------

模板在编译的时候被“展开”，而宏则是在此之前进行“展开”（简单的文本替换）。

-   示例代码一：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 3,7

        #include<iostream>

        #define WAIT std::cin.get()

        int main()
        {
            WAIT;
        }

-   示例代码二（带参数）：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 3,7

        #include<iostream>

        #define Log(x) std::cout << x << std::endl

        int main()
        {
            Log("Hello");
            std::cin.get();
        }

-   示例代码三（条件编译）：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 3,4,5,6,7

        #include<iostream>

        #ifdef DEBUG 
        #define Log(x) std::cout << x << std::endl
        #else
        #define Log(x)
        #endif

        int main()
        {
            Log("Hello");
            std::cin.get();
        }

-   示例代码四（条件编译）：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 3,5

        #include<iostream>

        #define DEBUGLevel  1

        #if DEBUGLevel == 1
        #define Log(x) std::cout << x << std::endl
        #else
        #define Log(x)
        #endif

        int main()
        {
            Log("Hello");
            std::cin.get();
        }

-   示例代码四（换行）：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 3,4,5,6,8

        #include<iostream>

        #define MAIN int main() \
        {\
            std::cin.get(); \
        }

        MAIN
        
        
53. C++ 中的 auto 关键字
--------------------------------------------------------------------------------

54. C++ 中的静态数组
--------------------------------------------------------------------------------

55. C++ 中的函数指针
--------------------------------------------------------------------------------

-   函数指针的基本使用：

        .. code-block:: c++
            :linenos:
            :emphasize-lines: 15,18,21,22,25,15,33,36,39,40,43

            #include<iostream>

            void Hello1()
            {
                std::cout << "Hello!" << std::endl;
            }

            void Hello2(const std::string& message)
            {
                std::cout << message << std::endl;
            }

            int main() {
                // 11. auto
                auto func11 = Hello1;

                // 12. 指定类型
                void(*func12)() = Hello1;

                // 13. typedef 类似于 C# 中的 delegate
                typedef void(*HelloFunc1)();
                HelloFunc1 func13 = Hello1;

                // 14. lambda
                auto func14 = []() {std::cout << "Hello!" << std::endl; };

                func11();
                func12();   // or: (*func12)()
                func13();
                func14();

                // 21. auto
                auto func21 = Hello2;

                // 22. 指定类型
                void(*func22)(const std::string & message) = Hello2;

                // 23. typedef 类似于 C# 中的 delegate
                typedef void(*HelloFunc2)(const std::string& message);
                HelloFunc2 func23 = Hello2;

                // 24. lambda
                auto func24 = [](const std::string& message) {std::cout << message << std::endl; };

                func21("Hello!");
                func22("Hello!");   // or: (*func22)("Hello!")
                func23("Hello!");
                func24("Hello!");

                std::cin.get();
            }

-   实际使用场景：

        .. code-block:: c++
            :linenos:
            :emphasize-lines: 9,10,11,12,13,14,15,20
            
            #include<iostream>
            #include<vector>

            void print(int value)
            {
                std::cout << value << " ";
            }

            void HandleVector(const std::vector<int> data, void(*func)(int))
            {
                for (int item : data)
                {
                    func(item);
                }
            }
            
            int main()
            {
                std::vector<int> data = { 1,2,3,4,5,6,7,8 };
                HandleVector(data, print);

                std::cin.get();
            }
        
        输出： ::
        
            1 2 3 4 5 6 7 8

56. C++ 中的 Lambda 表达式
--------------------------------------------------------------------------------

Lambda 表达式主要是用于创建匿名函数，通常在 C++ 中使用函数指针的地方都可以
使用 Lambda 表达式。

比如上一节 :ref:`src/C++:55. C++ 中的函数指针` 中的示例代码可以做如下修改：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 15
        
        #include<iostream>
        #include<vector>

        void HandleVector(const std::vector<int> data, void(*func)(int))
        {
            for (int item : data)
            {
                func(item);
            }
        }

        int main()
        {
            std::vector<int> data = { 1,2,3,4,5,6,7,8 };
            HandleVector(data, [](int value) {std::cout << value << " "; });

            std::cin.get();
        }

    输出： ::
    
        1 2 3 4 5 6 7 8

.. code-block:: c++
    :linenos:
    :emphasize-lines: 18,19,25,33
        
    #include<iostream>

    void Print1(int value)
    {
        std::cout << "value outside labmda: " << value << " " << std::endl;
    }

    void Print2(int value)
    {
        std::cout << "value in labmda: " << value << " " << std::endl;
    }

    int main()
    {
        int a = 0;
        int b = 0;

        auto func1 = [=]() { Print2(a); };
        auto func2 = [=]() mutable
        {
            a++;
            Print2(a);
        };

        auto func3 = [a,&b]() mutable
        {
            a++;
            b++;
            Print2(a);
            Print2(b);
        };

        auto func4 = [&]()
        {
            a++;
            b++;
            Print2(a);
            Print2(b);
        };

        func1();
        Print1(a);

        func2();
        Print1(a);

        func3();
        Print1(a);
        Print1(b);

        func4();
        Print1(a);
        Print1(b);

        std::cin.get();
    }

输出： ::

    value in labmda: 0
    value outside labmda: 0
    value in labmda: 1
    value outside labmda: 0
    value in labmda: 1
    value in labmda: 1
    value outside labmda: 0
    value outside labmda: 1
    value in labmda: 1
    value in labmda: 2
    value outside labmda: 1
    value outside labmda: 2


Labmda 表达式中的 ``[]`` 是 `captures` 表示如果在 Lambda 表达式内部如
何访问外部的变量:

    -   ``[=]`` :

        Lambda 表达式内部全部都按值（by value）的方式访问外部变量;

    -   ``[&]`` :

        Lambda 表达式内部全部都按引用（by reference）的方式访问外部变量;

    -   ``[a,&b]`` :

        Lambda 表达式内部按值（by value）的方式访问外部变量 ``a`` ，按引用
        （by reference）的方式访问外部变量 ``b`` 。

关于上述代码中 `mutable` 的使用，可参考前面的章节 :ref:`src/C++:32. C++ 中的 Mutable 关键字` 。

更多详细的信息可参考 `Lambda expressions (since C++11) <https://en.cppreference.com/w/cpp/language/lambda>`_ 。

57. 为什么不使用 std 命名空间
--------------------------------------------------------------------------------

58. C++ 中的命名空间
--------------------------------------------------------------------------------

59. C++ 中的线程
--------------------------------------------------------------------------------


60. C++ 中的计时（Timing）
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:

    #include<iostream>
    #include<chrono>

    struct  Timer
    {
        std::chrono::time_point<std::chrono::steady_clock> start, end;
        std::chrono::duration<float> duration;
        Timer()
        {
            start = std::chrono::high_resolution_clock::now();
        }
        ~Timer()
        {
            end = std::chrono::high_resolution_clock::now();
            duration = end - start;
            float ms = duration.count() * 1000.0f;
            std::cout << "Timer took " << ms << "ms" << std::endl;
        }
    };

.. code-block:: c++
    :linenos:

    #include<iostream>
    #include<chrono>

    struct  Timer
    {
    public:
        Timer()
        {
            m_StartTimepoint = std::chrono::high_resolution_clock::now();
        }
        ~Timer()
        {
            Stop();
        }

        void Stop()
        {
            auto endTimepoint = std::chrono::high_resolution_clock::now();

            auto start = std::chrono::time_point_cast<std::chrono::microseconds>(m_StartTimepoint).time_since_epoch().count();
            auto end = std::chrono::time_point_cast<std::chrono::microseconds>(endTimepoint).time_since_epoch().count();
            auto duration = end - start;

            double ms = duration * 0.001;

            std::cout << duration << "us (" << ms << "ms) \n";
        }
    private:
        std::chrono::time_point<std::chrono::high_resolution_clock> m_StartTimepoint;
    };

61. C++ 中的多维数组
--------------------------------------------------------------------------------

62. C++ 中的排序
--------------------------------------------------------------------------------

63. C++ 中的（Type Punning）
--------------------------------------------------------------------------------

将类型 `A` 的指针转换为类型 `B` 的指针，然后按照类型 `B` 来操作关联的内存。

64. C++ 中的 Unions
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 26,27,28,29,30,31,32,33
    
    #include<iostream>

    struct Vector2
    {
        float x, y;
    };

    struct Vector4
    {
        float x, y, z, w;
    };

    std::ostream& operator<<(std::ostream& stream, const Vector2& other)
    {
        stream << other.x << ", " << other.y;
        return stream;
    }
    std::ostream& operator<<(std::ostream& stream, const Vector4& value)
    {
        stream << value.x << ", " << value.y << ", " << value.z << ", " << value.w;
        return stream;
    }

    struct MyUnion
    {
        union
        {
            Vector4 v4;
            struct
            {
                Vector2 a, b;
            };
        };
    };

    int main() {
        MyUnion data;
        data.v4.x = 1.0f;
        data.v4.y = 2.0f;
        data.v4.z = 3.0f;
        data.v4.w = 4.0f;

        std::cout << data.v4 << std::endl;
        std::cout << data.a << std::endl;
        std::cout << data.b << std::endl;

        return 0;
    }

输出： ::

    1, 2, 3, 4
    1, 2
    3, 4

65. C++ 中的虚构造函数
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 36,37
    
    #include<iostream>

    class  Base
    {
    public:
        Base()
        {
            std::cout << "Base Constructed.\n";
        }
        ~Base()
        {
            std::cout << "Base Destructed.\n";
        }
    };

    class  Derived : public Base
    {
    public:
        Derived()
        {
            std::cout << "Derived Constructed.\n";
        }
        ~Derived()
        {
            std::cout << "Derived Destructed.\n";
        }
    };

    int main() {
        Base* base = new Base;
        delete base;
        std::cout << "--------------------------\n";
        Derived* derived = new Derived;
        delete derived;
        std::cout << "--------------------------\n";
        Base* poly = new Derived;
        delete poly;

        std::cin.get();
    }

输出： ::

    Base Constructed.
    Base Destructed.
    --------------------------
    Base Constructed.
    Derived Constructed.
    Derived Destructed.
    Base Destructed.
    --------------------------
    Base Constructed.
    Derived Constructed.
    Base Destructed.

可以看到 ``poly`` 变量在被销毁的时候并没有正确地调用 ``Derived::~Derived()`` 
这个析构函数，这是因为 ``poly`` 被以指向 ``Base`` 类型地指针对待，在 ``delete poly;`` 
调用的时候无法知道其是否具有派生类的析构函数。

为了解决这个问题，将基类的析构函数设置为虚函数即可：

.. code-block:: c++
    :linenos:
    :lineno-start: 10
    :emphasize-lines: 1

    
    virtual ~Base()

调整后的输出：::

    Base Constructed.
    Base Destructed.
    --------------------------
    Base Constructed.
    Derived Constructed.
    Derived Destructed.
    Base Destructed.
    --------------------------
    Base Constructed.
    Derived Constructed.
    Derived Destructed.
    Base Destructed.

66. C++ 中的类型转换
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    
    #include<iostream>

    int main() {
        double value = 5.3;
        std::cout << (int)value << std::endl;               // C style
        std::cout << static_cast<int>(value) << std::endl;  // C++ style
        std::cin.get();
    }

C++ style:

    -   static_cast
    -   dynamic_cast
    -   const_cast
    -   reinterpret_cast

67. C++ 中的条件和动作断点
--------------------------------------------------------------------------------

略。

68. 现代 C++ 中的安全
--------------------------------------------------------------------------------

69. C++ 中的预编译头文件
--------------------------------------------------------------------------------

使用方式：

1.  pch.h

    在一个头文件中包含需要预编译的头文件信息。

2.  pch.cpp

    1.  在一个 `.cpp` 文件中 `include` 上一步中的头文件。

        .. code-block:: c++
            :caption: pch.cpp
            :linenos:

            #include"pch.h"

    2.  在该文件的 Properties -> Configuration Properties -> C/C++ -> Precompiled Header -> Precompiled Header : `Create (/Yc)`

3.  修改项目相关属性
    
    1.  在项目的 Properties -> Configuration Properties -> C/C++ -> Precompiled Header -> Precompiled Header : `Use (/Yu)`
    2.  在项目的 Properties -> Configuration Properties -> C/C++ -> Precompiled Header -> Precompiled Header File : `pch.h`




缺点：

    -   使用预编译头文件的项目中不太好知道项目依赖于哪些库

70. C++ 中的动态类型转换（Dynamic Casting）
--------------------------------------------------------------------------------

C++ 中的动态类型转换是在运行时发生的，因此会有一定的性能开销。动态类型转换通常是
发生在类的继承树中，检查一个以基类类型命名的变量中存储的是否是某个子类的实例。

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 5,6,22,23

        #include<iostream>

        class Entity
        {
        public:
            void virtual PrintName() {};
        };

        class Player :public Entity
        {
        };

        class Enemy :public Entity
        {
        };

        int main()
        {
            Player* player = new Player;
            Enemy* enemy = new Enemy;

            Player* p0 = dynamic_cast<Player*>(player);     // cast success. p0 will be some value
            Player* p1 = dynamic_cast<Player*>(enemy);      // cast failed. p1 will be nullptr

            std::cin.get();
        }

C++ 使用 RTTI(Run time type information) 来实现运行时的动态类型转换，有一定的开
销，在 Visual Studio 中的项目的 Properties -> Configuration Properties -> C/C++ 
-> Language -> Enable Run-Time Type Information 选项中可开启或禁用，禁用后编译的
代码中的动态类型转换相关的代码会出现不可预知的行为。

71. C++ 中的性能测试（如何测量性能）
--------------------------------------------------------------------------------

注意在 `Debug` 和 `Release` 模式下存在编译后代码的差异。

测试一：

    .. code-block:: c++
        :linenos:

        #include<iostream>
        #include<chrono>

        struct  Timer
        {
        public:
            Timer()
            {
                m_StartTimepoint = std::chrono::high_resolution_clock::now();
            }
            ~Timer()
            {
                Stop();
            }

            void Stop()
            {
                auto endTimepoint = std::chrono::high_resolution_clock::now();

                auto start = std::chrono::time_point_cast<std::chrono::microseconds>(m_StartTimepoint).time_since_epoch().count();
                auto end = std::chrono::time_point_cast<std::chrono::microseconds>(endTimepoint).time_since_epoch().count();
                auto duration = end - start;

                double ms = duration * 0.001;

                std::cout << duration << "us (" << ms << "ms) \n";
            }
        private:
            std::chrono::time_point<std::chrono::high_resolution_clock> m_StartTimepoint;
        };

        int main()
        {
            int value = 0;
            {
                Timer timer;
                for (int i = 0; i < 1000000; i++)
                    value += 2;
            }
            std::cout << value << std::endl;

            __debugbreak();
        }

    输出（Debug）：::

        8935us (8.935ms)
        2000000

    输出（Release）：::

        1us (0.001ms)
        2000000

测试二：

    .. code-block:: c++
        :linenos:

        #include<iostream>
        #include<chrono>
        #include<array>

        struct  Timer
        {
        public:
            Timer()
            {
                m_StartTimepoint = std::chrono::high_resolution_clock::now();
            }
            ~Timer()
            {
                Stop();
            }

            void Stop()
            {
                auto endTimepoint = std::chrono::high_resolution_clock::now();

                auto start = std::chrono::time_point_cast<std::chrono::microseconds>(m_StartTimepoint).time_since_epoch().count();
                auto end = std::chrono::time_point_cast<std::chrono::microseconds>(endTimepoint).time_since_epoch().count();
                auto duration = end - start;

                double ms = duration * 0.001;

                std::cout << duration << "us (" << ms << "ms) \n";
            }
        private:
            std::chrono::time_point<std::chrono::high_resolution_clock> m_StartTimepoint;
        };

        int main()
        {
            struct Vector2
            {
                float x, y;
            };
            std::cout << "Make Shared\n";
            {
                std::array<std::shared_ptr<Vector2>, 1000> ptrs;
                Timer timer;
                for (int i = 0; i < ptrs.size(); i++)
                    ptrs[i] = std::make_shared<Vector2>();
            }

            std::cout << "New Shared\n";
            {
                std::array<std::shared_ptr<Vector2>, 1000> ptrs;
                Timer timer;
                for (int i = 0; i < ptrs.size(); i++)
                    ptrs[i] = std::shared_ptr<Vector2>(new Vector2());
            }

            std::cout << "Make Unique\n";
            {
                std::array<std::unique_ptr<Vector2>, 1000> ptrs;
                Timer timer;
                for (int i = 0; i < ptrs.size(); i++)
                    ptrs[i] = std::make_unique<Vector2>();
            }

            __debugbreak();
        }

    输出（Debug）：::

        Make Shared
        1142us (1.142ms)
        New Shared
        1476us (1.476ms)
        Make Unique
        990us (0.99ms)

    输出（Release）：::

        Make Shared
        112us (0.112ms)
        New Shared
        292us (0.292ms)
        Make Unique
        89us (0.089ms)

72. C++ 17 中的结构化绑定（Structured Bindings）
--------------------------------------------------------------------------------

从 C++ 17 开始的一种可以让方法有多个返回值的方式，在 Visual Studio 中的项目
的 Properties -> Configuration Properties -> C/C++ -> Language -> C++ Language Standard : ISO C++17 Standard (/std:c++17)

-   使用 ``std::tuple`` 或者 ``std::pair`` :

    .. code-block:: c++
        :linenos:

        #include<iostream>
        #include<tuple>

        std::tuple<std::string, int> CreatePerson() // 或者 std::pair<std::string, int> CreatePerson()
        {
            return { "Cherno",24 };
        }
        int main() {
            // 方式一
            auto person = CreatePerson();
            std::string& name = std::get<0>(person);
            int age = std::get<1>(person);
            
            // 方式二
            std::string name2;
            int age2;
            std::tie(name2, age2) = CreatePerson();

            return 0;
        }

-   使用 Structured Bindings :

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 9

        #include<iostream>
        #include<tuple>

        std::tuple<std::string, int> CreatePerson()
        {
            return { "Cherno",24 };
        }
        int main() {
            auto [name, age] = CreatePerson();
            std::cout << name<<std::endl;
            std::cout << age <<std::endl;
            return 0;
        }
        

73. C++ 17 中如何处理可选数据（Optional Data）
--------------------------------------------------------------------------------

C++ 17 引入的 ``std::optional`` 类似于 C# 中的 ``Nullable`` 。

-   常规处理方式：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 4,12,15,16,19,20,21
        
        #include<iostream>
        #include<fstream>

        std::string ReadFileAsString(const std::string& filePath, bool& outSuccess)
        {
            std::ifstream stream(filePath);
            if (stream)
            {
                std::string  result;
                // read file
                stream.close();
                outSuccess = true;
                return result;
            }
            outSuccess = false;
            return std::string();
        }
        int main() {
            bool fileOpendSuccessfully;
            std::string data = ReadFileAsString("data.txt", fileOpendSuccessfully);
            if (fileOpendSuccessfully)
            {
                std::cout << "File read successfully!\n";
            }
            else
            {
                std::cout << "File could not be opened!\n";
            }
            return 0;
        }

-   使用 ``std::optional`` ：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 3,5,15,18,19,21,22,24
        
        #include<iostream>
        #include<fstream>
        #include<optional>

        std::optional<std::string> ReadFileAsString(const std::string& filePath)
        {
            std::ifstream stream(filePath);
            if (stream)
            {
                std::string  result;
                // read file
                stream.close();
                return result;
            }
            return {};
        }
        int main() {
            std::optional<std::string> data = ReadFileAsString("data.txt");
            if (data.has_value())
            {
                std::string& content1 = data.value();
                std::string& content2 = *data;

                std::cout << "File read successfully!\n";
            }
            else
            {
                std::cout << "File could not be opened!\n";
            }
            return 0;
        }

74. C++ 17 中让一个变量拥有多种类型
--------------------------------------------------------------------------------

-   基本使用

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 2,5,7,8,10,11

        #include<iostream>
        #include<variant>

        int main() {
            std::variant<std::string, int> data;

            data = "Cherno";
            std::cout << std::get<std::string>(data) << "\n";

            data = 2;
            std::cout << std::get<int>(data) << "\n";

            // std::cout << std::get<std::string>(data) << "\n"; // 这里会泡抛出异常

            return 0;
        }

-   检查变量中存储的类型：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 10,14
        
        #include<iostream>
        #include<variant>

        int main() {
            std::variant<std::string, int> data;

            data = "Cherno";
            data = 2;

            if (data.index() == 0)
            {
                std::cout << std::get<std::string>(data) << "\n";
            }
            else if (data.index() == 1)
            {
                std::cout << std::get<int>(data) << "\n";
            }

            return 0;
        }

    或者：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 10,12,15,17

        #include<iostream>
        #include<variant>

        int main() {
            std::variant<std::string, int> data;

            data = "Cherno";
            data = 2;

            if (auto value = std::get_if<std::string>(&data))
            {
                std::string& v = *value;
                std::cout << v << "\n";
            }
            else if (auto value = std::get_if<int>(&data))
            {
                int& v = *value;
                std::cout << v << "\n";
            }

            return 0;
        }
        
-   检查变量中存储的类型：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 7,8,9

        #include<iostream>
        #include<variant>

        int main() {
            std::variant<std::string, int> data;

            std::cout << sizeof(int) << "\n";               // output will be 4
            std::cout << sizeof(std::string) << "\n";       // output will be 28
            std::cout << sizeof(data) << "\n";              // output will be 32

            return 0;
        }

    `variant` 的底层实现有些像类中包含了多个成员变量，没有 ``unino`` 那样的
    高效，但是更安全一些。

-   其它使用场景

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 3,5,6,7,8,10
        
        #include<iostream>
        #include<variant>
        #include<optional>

        enum  ErrorCode
        {
            None = 0, NorFound = 1, NoAccess = 2
        };

        std::variant<std::string, int> ReadFileAsString()
        {
            return {};
        }

75. C++ 17 How to store ANY data in C++
--------------------------------------------------------------------------------

浏览的 C++ 源码得知 ``std::any`` 类型的变量在当存储到其中的数据较小时，使用栈来
存储；当数据较大时，使用堆来存储。作为比较 ``std::variant`` 则不会存在动态分配内
存的情况，性能可能会好一些。

-   常规使用

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 2,6,7,8,9,11,12

        #include<iostream>
        #include<any>

        int main()
        {
            std::any data;
            data = 2;
            data = "Cherno"; //  const char*
            data = std::string("Cherno");

            std::string string = std::any_cast<std::string>(data); // pay attention to try catch
            std::string& string2 = std::any_cast<std::string&>(data);
            std::cin.get();
        }

-   其他

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 4,5,6,7,17,18

        #include<iostream>
        #include<any>

        void* operator new(size_t size) // 兼容性不是很好
        {
            return malloc(size);
        }

        struct CustomClass
        {
            std::string s0, s1;
        };

        int main()
        {
            std::any data;
            data = 2;               // use stack 
            data = CustomClass();   // use heap with big poiner
            std::cin.get();
        }

76. 如何让 C++ 运行更快（std-async）
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 2,4,6,10,15,24

    #include<iostream>
    #include<future>

    std::vector<std::future<void>> m_Futures;

    static std::mutex s_MeshMutex;

    static void LoadMesh(std::string file)
    {
        std::lock_guard<std::mutex> lock(s_MeshMutex);
    }

    static void LoadMesh(std::string file)
    {
        std::lock_guard<std::mutex> lock(s_MeshMutex);
        // other operations
    }

    int main()
    {
        std::vector<std::string> meshFilepaths;
        for (const auto& file : meshFilepaths)
        {
            m_Futures.push_back(std::async(std::launch::async, LoadMesh, file));
        }
        std::cin.get();
    }

77. C++ 17 如何让 String 更快
--------------------------------------------------------------------------------

-   常规写法

    .. code-block:: c++
        :linenos:

        #include<iostream>

        static int s_Allocations = 0;
        void* operator new(size_t size)
        {
            s_Allocations++;
            std::cout << "Allocating " << size << " bytes\n";
            return malloc(size);
        }

        void PrintName(const std::string& name)
        {
            std::cout << name << std::endl;
        }

        int main()
        {
            std::string name = "Yan Chernikov";

            std::string firstName = name.substr(0, 3);
            std::string lastName = name.substr(4, 9);

            PrintName("Yan Chernikov");
            PrintName(firstName);
            PrintName(lastName);

            std::cout << s_Allocations << " allocations " << std::endl;
            std::cin.get();
        }

    输出: ::

        Allocating 8 bytes
        Allocating 8 bytes
        Allocating 8 bytes
        Allocating 8 bytes
        Yan Chernikov
        Yan
        Chernikov
        4 allocations

    四次内存分配发生在第18，20，21和23这几行。

-   使用 ``std::string_view``

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 11,20,21

        #include<iostream>

        static int s_Allocations = 0;
        void* operator new(size_t size)
        {
            s_Allocations++;
            std::cout << "Allocating " << size << " bytes\n";
            return malloc(size);
        }

        void PrintName(std::string_view name)
        {
            std::cout << name << std::endl;
        }

        int main()
        {
            std::string name = "Yan Chernikov";

            std::string_view firstName = std::string_view(name.c_str(), 4);
            std::string_view lastName = std::string_view(name.c_str() + 4, 9);

            PrintName("Yan Chernikov");
            PrintName(firstName);
            PrintName(lastName);

            std::cout << s_Allocations << " allocations " << std::endl;
            std::cin.get();
        }

    输出: ::

        Allocating 8 bytes
        Yan Chernikov
        Yan
        Chernikov
        1 allocations

    唯一的一次内存分配发生在第18行。

-   继续优化

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 18,20,21

        #include<iostream>

        static int s_Allocations = 0;
        void* operator new(size_t size)
        {
            s_Allocations++;
            std::cout << "Allocating " << size << " bytes\n";
            return malloc(size);
        }

        void PrintName(std::string_view name)
        {
            std::cout << name << std::endl;
        }

        int main()
        {
            const char* name = "Yan Chernikov";

            std::string_view firstName = std::string_view(name, 4);
            std::string_view lastName = std::string_view(name + 4, 9);

            PrintName("Yan Chernikov");
            PrintName(firstName);
            PrintName(lastName);

            std::cout << s_Allocations << " allocations " << std::endl;
            std::cin.get();
        }

    输出: ::

        Yan Chernikov
        Yan
        Chernikov
        0 allocations

78. C++ 中让性能测试可视化
--------------------------------------------------------------------------------

79. C++ 中的单例
--------------------------------------------------------------------------------

C++ 中单例类的行为和命名空间的作用类型。

-   常规实现

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 12,16,19,21

        #include<iostream>

        class Singleton
        {
        public:
            static Singleton& Get()
            {
                return s_Instance;
            }

            // 禁用拷贝构造函数
            Singleton(const Singleton& other) = delete;

            void Function() {}
        private:
            Singleton() {}

            // 静态实例
            static Singleton s_Instance;
        };
        Singleton Singleton::s_Instance;

        int main()
        {
            // Singleton instance = Singleton::Get(); // 这会复制一个实例 因此需要把拷贝构造函数禁用

            Singleton::Get().Function();

            std::cin.get();
        }

-   优化

    .. code-block:: c++
        :linenos:

        class Singleton
        {
        public:
            static Singleton& Get()
            {
                // 静态实例
                static Singleton s_Instance;
                return s_Instance;
            }

            // 禁用拷贝构造函数
            Singleton(const Singleton& other) = delete;

            void Function() {}
        private:
            Singleton() {}
        };

-   命名空间

    .. code-block:: c++
        :linenos:

        #include<iostream>

        namespace RandomClass
        {
            static void Function() {}
        }

        int main()
        {
            RandomClass::Function();

            std::cin.get();
        }

80. C++ 中对短字符串的优化
--------------------------------------------------------------------------------

C++ 中，使用 ``std::stirng`` 时，如果字符串的长度小于等于 15 ，则在 *Release* 模
式下会存储在栈中，不会进行堆空间内存的分配。

.. code-block:: c++
    :linenos:

    #include<iostream>

    void* operator new(size_t size)
    {
        std::cout << "Allocation " << size << " bytes\n";
        return malloc(size);
    }

    int main()
    {
        std::string name = "Cherno";

        std::cin.get();
    }

输出： ::

    Debug(x86) 模式：
        Allocation 8 bytes
    Release(x86) 模式：
        无

调整字符串，使其长度大于 15 :

.. code-block:: c++
    :linenos:
    :lineno-start: 11

    std::string name = "Cherno small str";

输出： ::

    Debug(x86) 模式：
        Allocation 8 bytes（？？？）
        Allocation 32 bytes
    Release(x86) 模式：
        Allocation 32 bytes

81. C++ 中以最简单的方式对内存分配进行跟踪
--------------------------------------------------------------------------------

在 C++ 代码中重写 ``new`` 操作符，使其替换 STL 中的实现，在链接时被使用，便于断
点调试。

.. code-block:: c++
    :linenos:

    #include<iostream>
    #include<memory>

    struct AllocationMetrics
    {
        uint32_t TotalAllocated = 0;
        uint32_t TotalFreed = 0;

        uint32_t CurrentUsage() { return TotalAllocated - TotalFreed; }
    };

    AllocationMetrics s_AllocationMetrics;

    static void PrintMemoryUsage()
    {
        std::cout << "Memory Usage: " << s_AllocationMetrics.CurrentUsage() << " bytes\n";
    }

    void* operator new(size_t size)
    {
        //std::cout << "Allocation " << size << " bytes\n";
        s_AllocationMetrics.TotalAllocated += size;
        return malloc(size);
    }

    void operator delete(void* obj, size_t size)
    {
        //std::cout << "Freeing " << size << " bytes\n";
        s_AllocationMetrics.TotalFreed += size;
        free(obj);
    }

    struct  Object
    {
        int x, y, z;
    };
    int main()
    {
        PrintMemoryUsage();
        std::string name = "Cherno";
        PrintMemoryUsage();
        {
            Object* obj = new Object;
            delete obj;
            PrintMemoryUsage();

            std::unique_ptr<Object> obj2 = std::make_unique<Object>();
            PrintMemoryUsage();
        }
        PrintMemoryUsage();
        std::cin.get();
    }

输出： ::

    Memory Usage: 0 bytes
    Memory Usage: 8 bytes
    Memory Usage: 8 bytes
    Memory Usage: 20 bytes
    Memory Usage: 8 bytes

82. C++ 的左值和右值
--------------------------------------------------------------------------------

C++ 中的左值 ( `lvalue` ) 是指已经分配内存的对象；而右值（ `rvalue` ）是指
尚未为其分配内存的对象。

在类型名后面加一个 `&` 以声明左值类型，加两个 `&` 以声明右值类型，仅在函数的
参数列表中可以使用这两种类型进行声明。

.. code-block:: c++
    :linenos:

    #include<iostream>

    void Print(std::string& first, std::string&& last)
    {
        // do something here
    }

83. C++ 中的持续集成
--------------------------------------------------------------------------------

`jenkins <https://www.jenkins.io/>`_ `linode <https://www.linode.com/>`_

84. C++ 中的静态分析
--------------------------------------------------------------------------------

`PVS-Studio <https://pvs-studio.com/en/>`_

85. C++ 中参数 evaluation 顺序
--------------------------------------------------------------------------------

C++ 中没有规定参数被 evalueated 的顺序，但在 C++ 17 中规定了 ++i 在 i++ 之
前被 evaluated。

86. C++ 中的 Move 含义（semantics）
--------------------------------------------------------------------------------

-   第一版代码

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 47,63

        #include<iostream>
        class String
        {
        private:
            char* m_Data;
            uint32_t m_Size;
        public:
            String() = default;

            String(const char* string)
            {
                printf("Constructed!\n");
                m_Size = strlen(string);
                m_Data = new char[m_Size];

                memcpy(m_Data, string, m_Size);
            }

            String(const String& copiedObject)
            {
                printf("Copied!\n");
                m_Size = copiedObject.m_Size;
                m_Data = new char[copiedObject.m_Size];
                memcpy(m_Data, copiedObject.m_Data, m_Size);
            }

            ~String()
            {
                printf("Destroyed!\n");
                delete m_Data;
            }

            void Print()
            {
                for (size_t i = 0; i < m_Size; ++i)
                {
                    printf("%c", m_Data[i]);
                }
                printf("\n");
            }
        };

        class  Entity
        {
        public:
            Entity(const String& name)
                : m_Name(name)
            {
            }

            void PrintName()
            {
                m_Name.Print();
            }

        private:
            String m_Name;
        };

        int main()
        {
            {
                Entity entity("Cherno");    // same as: Entity entity(String("Cherno"));
                entity.PrintName();
            }
            std::cin.get();
        }

    输出： ::

        Constructed!
        Copied!
        Destroyed!
        Cherno
        Destroyed!

    -   `main` 函数中的代码 ``Entity entity("Cherno");`` 会调用 ``String::String(const char* string)`` 
        构造函数将参数 `"Cherno"` 进行隐式类型转换；
    -   然后在调用 ``Entity::Entity(const String& name): m_Name(name)`` 
        构造函数时， ``m_Name(name)`` 会调用 ``String(const String& copiedObject)`` 
        进行一次拷贝构造（copy construct）。

-   第二版代码

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 27,28,29,30,31,32,33,34,35,61,62,63,64

        #include<iostream>
        class  String
        {
        private:
            char* m_Data;
            uint32_t m_Size;
        public:
            String() = default;

            String(const char* string)
            {
                printf("Constructed!\n");
                m_Size = strlen(string);
                m_Data = new char[m_Size];

                memcpy(m_Data, string, m_Size);
            }

            String(const String& copiedObject)
            {
                printf("Copied!\n");
                m_Size = copiedObject.m_Size;
                m_Data = new char[copiedObject.m_Size];
                memcpy(m_Data, copiedObject.m_Data, m_Size);
            }

            String(String&& movedObject) noexcept
            {
                printf("Moved!\n");
                m_Size = movedObject.m_Size;
                m_Data = movedObject.m_Data;

                movedObject.m_Size = 0;
                movedObject.m_Data = nullptr;
            }

            ~String()
            {
                printf("Destroyed!\n");
                delete m_Data;
            }

            void Print()
            {
                for (size_t i = 0; i < m_Size; ++i)
                {
                    printf("%c", m_Data[i]);
                }
                printf("\n");
            }
        };

        class  Entity
        {
        public:
            Entity(const String& name)
                : m_Name(name)
            {
            }

            Entity(String&& name)
                : m_Name(std::move(name)) // same as: m_Name((String&&)name)
            {
            }

            void PrintName()
            {
                m_Name.Print();
            }

        private:
            String m_Name;
        };

        int main()
        {
            {
                Entity entity("Cherno");    // same as: Entity entity(String("Cherno"));
                entity.PrintName();
            }
            std::cin.get();
        }

    输出： ::

        Constructed!
        Moved!
        Destroyed!
        Cherno
        Destroyed!

    -   增加了 move constructor 的实现，相较第一版代码而言，移除了因拷贝构造
        带来的内存分配。

87. C++ 中的 Move 和 move assigment 操作符
--------------------------------------------------------------------------------

.. code-block:: c++
    :linenos:
    :emphasize-lines: 37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,95,96,103

    #include<iostream>
    class  String
    {
    private:
        char* m_Data;
        uint32_t m_Size;
    public:
        String() = default;

        String(const char* string)
        {
            printf("Constructed!\n");
            m_Size = strlen(string);
            m_Data = new char[m_Size];

            memcpy(m_Data, string, m_Size);
        }

        String(const String& copiedObject)
        {
            printf("Copied!\n");
            m_Size = copiedObject.m_Size;
            m_Data = new char[copiedObject.m_Size];
            memcpy(m_Data, copiedObject.m_Data, m_Size);
        }

        String(String&& movedObject) noexcept
        {
            printf("Moved!\n");
            m_Size = movedObject.m_Size;
            m_Data = movedObject.m_Data;

            movedObject.m_Size = 0;
            movedObject.m_Data = nullptr;
        }

        String& operator=(String&& asignedObject)
        {
            printf("Move assigned!\n");

            if (this != &asignedObject)
            {
                delete m_Data;

                m_Size = asignedObject.m_Size;
                m_Data = asignedObject.m_Data;

                asignedObject.m_Size = 0;
                asignedObject.m_Data = nullptr;
            }

            return *this;
        }

        ~String()
        {
            printf("Destroyed!\n");
            delete m_Data;
        }

        void Print()
        {
            for (size_t i = 0; i < m_Size; ++i)
            {
                printf("%c", m_Data[i]);
            }
            printf("\n");
        }
    };

    class  Entity
    {
    public:
        Entity(const String& name)
            : m_Name(name)
        {
        }

        Entity(String&& name)
            : m_Name(std::move(name)) // same as: m_Name((String&&)name)
        {
        }

        void PrintName()
        {
            m_Name.Print();
        }

    private:
        String m_Name;
    };

    int main()
    {
        String apple = "Apple";
        String dest;

        std::cout << "Apple: ";
        apple.Print();
        std::cout << "Dest: ";
        dest.Print();

        dest = std::move(apple);

        std::cout << "Apple: ";
        apple.Print();
        std::cout << "Dest: ";
        dest.Print();
    }

输出： ::

    Constructed!
    Apple: Apple
    Dest:
    Move assigned!
    Apple:
    Dest: Apple
    Destroyed!
    Destroyed!

88. C++ 中的设计数据结构 -  ARRAY
--------------------------------------------------------------------------------

-   基础使用

    .. code-block:: c++
        :linenos:

        #include<iostream>

        int main()
        {
            int array[5];

            int size = 5;
            int* heapArray = new int[size];
            delete heapArray[];
        }

-   stl 使用

    .. code-block:: c++
        :linenos:

        #include<iostream>
        #include<array>

        int main()
        {
            std::array<int, 10> collection;
            collection.size();
            for (int i: collection)
            {
                std::cout << i << " ";
            }
        }

-   自己实现

    .. code-block:: c++
        :linenos:

        #include<iostream>

        template<typename T, size_t S>
        class  Array
        {
        private:
            T m_Data[S];

        public:
            constexpr size_t Size() const { return S; } // constexpr 表示该函数可以编译时被 evaluated， 否则 static_assert 不能正常编译通过

            T& operator[](size_t index)
            {
                if (!(index < S))
                {
                    __debugbreak();
                }
                return m_Data[index];
            }
            const T& operator[](size_t index) const
            {
                if (!(index < S))
                {
                    __debugbreak();
                }
                return m_Data[index];
            }

            T* Data() { return m_Data; }
            const T* Data() const { return m_Data; }
        };

        int main()
        {
            int size = 5;
            Array<int, 5> data;

            // following statements can be used since the Size method is been marked with constexpr
            // static_assert(data.Size() < 10, "Size is too large!");
            // Array<int, data.Size()> newData;

            memset(data.Data(), 0, data.Size() * sizeof(int)); //  same as: memset(&data[0], 0, data.Size() * sizeof(int));

            data[1] = 5;
            data[3] = 7;

            for (size_t i = 0; i < data.Size(); ++i)
            {
                std::cout << data[i] << std::endl;
            }
        }

89. VECTOR DYNAMIC ARRAY - 设计数据结构
--------------------------------------------------------------------------------

90. C++ 中的迭代器
--------------------------------------------------------------------------------

-   基础使用

    .. code-block:: c++
        :linenos:

        #include<iostream>
        #include<vector>

        int main()
        {
            std::vector<int> values = { 1,2,3,4,5 };

            for (size_t i = 0; i < values.size(); i++)
            {
                std::cout << values[i] << std::endl;
            }

            for (int value : values)
            {
                std::cout << value << std::endl;
            }

            for (std::vector<int>::iterator it = values.begin(); it != values.end(); ++it)
            {
                std::cout << *it << std::endl;
            }

            std::cin.get();
        }

-   扩展

    .. code-block:: c++
        :linenos:

        #include<iostream>
        #include<unordered_map>

        int main()
        {
            using ScoreMap = std::unordered_map<std::string, int>;
            
            ScoreMap map;
            map["Cherno"] = 5;
            map["C++"] = 2;

            for (ScoreMap::const_local_iterator it = map.begin(); it != map.end(); ++it)
            {
                auto& key = it->first;
                auto& value = it->second;
                std::cout << key << " = " << value << std::endl;
            }

            for (auto kv : map)
            {
                auto& key = kv.first;
                auto& value = kv.second;
                std::cout << key << " = " << value << std::endl;
            }

            for (auto [key, value] : map) // C++ 17 structured binding
            {
                std::cout << key << " = " << value << std::endl;
            }

            std::cin.get();
        }

91. 在 C++ 中写一个迭代器
--------------------------------------------------------------------------------

92. 如何学习 C++
--------------------------------------------------------------------------------

STL 源码剖析
================================================================================

第一章 STL 概论与版本简介
--------------------------------------------------------------------------------

测试当前编译器中使用的 STL 实现版本中的 GCC 常量设定：

    .. code-block:: c++
        :caption: lconfig.cpp
        :linenos:

        #include<iostream>
        int main()
        {
        #if defined(__sgi)
            std::cout << "__sgi" << std::endl;
        #endif

        #if defined(__GNUC__)
            std::cout << "__GNUC__" << std::endl;
            std::cout << __GNUC__ << ' ' << __GNUC_MINOR__ << std::endl;
            std::cout << __GLIBC__ << std::endl;
        #endif

            // case 2
        #ifdef __STL_NO_DRAND48
            std::cout << "__STL_NO_DRAND48 defined" << std::endl;
        #else
            std::cout << "__STL_NO_DRAND48 undefined" << std::endl;
        #endif

            // case 3
        #ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG
            std::cout << "__STL_STATIC_TEMPLATE_MEMBER_BUG defined" << std::endl;
        #else
            std::cout << "__STL_STATIC_TEMPLATE_MEMBER_BUG undefined" << std::endl;
        #endif

            // case 5
        #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
            std::cout << "__STL_CLASS_PARTIAL_SPECIALIZATION defined" << std::endl;
        #else
            std::cout << "__STL_CLASS_PARTIAL_SPECIALIZATION undefined" << std::endl;
        #endif
        }


可能令你困惑的 C++ 语法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

stl_config.h 中的各种组态（congigurations）

-   组态3： ``__STL_STATIC_TEMPLATE_MEMBER_BUG``

    .. code-block:: c++
        :caption: lconfig3.cpp
        :linenos:
        :emphasize-lines: 10

        // 测试在 class template 中拥有 static member.
        // vc6[o] cb4[x] gcc[o]
        // cb4 does not support static data member initialization.
        #include<iostream>

        template<typename T>
        class testClass
        {
        public:
            static int _data;
        };

        // 为 static data member 进行定义（配置内存），并设初值
        int testClass<int>::_data = 1;
        int testClass<char>::_data = 2;

        int main()
        {
            // 以下，CB4 表现不佳，没有接受初值设定
            std::cout << testClass<int>::_data << std::endl;        // GCC, VC6:1 CB4:0
            std::cout << testClass<char>::_data << std::endl;       // GCC, VC6:2 CB4:0

            testClass<int> obji1, obji2;
            testClass<char> objc1, objc2;

            std::cout << obji1._data << std::endl;          // GCC, VC6:1 CB4:0
            std::cout << obji2._data << std::endl;          // GCC, VC6:1 CB4:0
            std::cout << objc1._data << std::endl;          // GCC, VC6:2 CB4:0
            std::cout << objc2._data << std::endl;          // GCC, VC6:2 CB4:0

            obji1._data = 3;
            objc2._data = 4;

            std::cout << obji1._data << std::endl;          // GCC, VC6:3 CB4:3
            std::cout << obji2._data << std::endl;          // GCC, VC6:3 CB4:3
            std::cout << objc1._data << std::endl;          // GCC, VC6:4 CB4:4
            std::cout << objc2._data << std::endl;          // GCC, VC6:4 CB4:4
            return 0;
        }

-   组态5： ``__STL_CLASS_PARTIAL_SPECIALIZATION``

    .. code-block:: c++
        :caption: lconfig5.cpp
        :linenos:
        :emphasize-lines: 16,23

        // 测试 class template partial specialization —— 在 class template 的
        // 一般化设计之外，特别针对某些 template 参数做特殊设计
        // vc6[x] cb4[o] gcc[o]
        // cb4 does not support static data member initialization.
        #include<iostream>

        // 一般化设计
        template<class I, class O >
        struct testClass
        {
            testClass() { std::cout << "I, O" << std::endl; }
        };

        // 特殊化设计
        template<class T >
        struct testClass<T*, T*>
        {
            testClass() { std::cout << "T*, T*" << std::endl; }
        };

        // 特殊化设计
        template<class T >
        struct testClass<const T*, T*>
        {
            testClass() { std::cout << "const T*, T*" << std::endl; }
        };

        int main()
        {
            testClass<int, char> obj1;
            testClass<int*, int*> obj2;
            testClass<const int*, int*> obj3;
        }

-   组态6： ``__STL_CLASS_PARTIAL_SPECIALIZATION``

    .. code-block:: c++
        :caption: lconfig6.cpp
        :linenos:

        // vc6[x] cb4[o] gcc[o]
        #include<iostream>

        class alloc {};

        template<class T, class Alloc = alloc >
        class Vector
        {
        public:
            void swap(Vector<T, Alloc>&) { std::cout << "swap()" << std::endl; }
        };

        #ifdef   __STL_FUNCTION_TMPL_PARTIAL_ORDER      // 只为说明，非本程序内容
        template<class T, class Alloc >
        inline void swap(Vector<T, Alloc>& x, Vector<T, Alloc>& y)
        {
            x.swap(y);
        }
        #endif //  __STL_FUNCTION_TMPL_PARTIAL_ORDER

        // 以上代码节选自 stl_vector.h，为条件编译吧部分的代码，非本测试程序的内容
        int main()
        {
            Vector<int> x, y;
            swap(x, y);
        }

-   组态8： ``__STL_MEMBER_TEMPLATES``

    .. code-block:: c++
        :caption: lconfig8.cpp
        :linenos:
        :emphasize-lines: 7,15

        // 测试 template 之内可否再有 template (members)
        // vc6[o] cb4[o] gcc[o]
        #include<iostream>

        class alloc {};

        template<class T, class Alloc = alloc >
        class vector
        {
        public:
            typedef T value_type;
            typedef value_type* iterator;

        public:
            template<class I>
            void insert(iterator position, I first, I last)
            {
                std::cout << "insert()" << std::endl;
            }
        };

        int main()
        {
            int ia[5] = { 0,1,2,3,4 };
            vector<int> x;
            vector<int>::iterator ite;
            x.insert(ite, ia, ia + 5);
        }

-   组态10： ``__STL_LIMITED_DEFAULT_TEMPLATES``

    .. code-block:: c++
        :caption: lconfig10.cpp
        :linenos:
        :emphasize-lines: 7,18

        // 测试 template 参数可否根据前一个 template 参数而设定默认值
        // vc6[o] cb4[o] gcc[o]
        #include<iostream>

        class alloc {};

        template<class T, class Alloc = alloc, size_t BufSize = 0>
        class deque
        {
        public:
            deque()
            {
                std::cout << "deque" << std::endl;
            }
        };

        // 根据前一个参数值T，设定下一个参数 Sequence 的默认值 deque<T>
        template<class T, class Sequence = deque<T>>
        class stack
        {
        public:
            stack()
            {
                std::cout << "stack" << std::endl;
            }
        private:
            Sequence c;
        };

        int main()
        {
            stack<int> x;   // deque
                            // stack
        }

-   组态11： ``__STL_NONE_TYPE_TMPL_PARAM_BUG``

    .. code-block:: c++
        :caption: lconfig11.cpp
        :linenos:
        :emphasize-lines: 12,21

        // 测试 class template 可否拥有 none-type template 参数
        // vc6[o] cb4[o] gcc[o]
        #include<iostream>

        class alloc {};

        inline size_t __deque_buf_size(size_t n, size_t sz)
        {
            return n != 0 ? n : (sz < 512 ? size_t(512 / sz) : size_t(1));
        }

        template<class T, class Ref, class Ptr, size_t BufSize>
        struct __deque_iterator
        {
            typedef __deque_iterator<T, T&, T*, BufSize> iterator;
            typedef __deque_iterator<T, const T&, const T*, BufSize> const_iterator;

            static size_t buffer_size() { return __deque_buf_size(BufSize, sizeof(T)); }
        };

        template<class T, class Alloc = alloc, size_t BufSize = 0>
        class deque
        {
        public:
            typedef __deque_iterator<T, T&, T*, BufSize> iterator;
        };

        int main()
        {
            std::cout << deque<int>::iterator::buffer_size() << std::endl;                  // 128
            std::cout << deque<int, alloc, 64>::iterator::buffer_size() << std::endl;       // 64
        }

临时对象的产生与运用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

所谓临时对象，就是一种无名对象（unnamed objects）。

-   如果不在预期之下出现，往往造成效率上的负担。
    
    例如任何 pass by value 操作都会引发 copy 操作，于是形成一个临时对象

-   刻意制造临时对象，使程序干净清爽。

    方法是在类型名称之后直接加一对小括号，并可指定初值，例如 shape(3,5) 或 int (8),
    其意义相当与调用相应的 constructor 且不指定对象名称。

    STL 最常将此技巧应用于仿函数与算法的搭配上，例如：

        .. code-block:: c++
            :linenos:
            :emphasize-lines: 22

            // 本例测试仿函数用于 for_each 的情形
            // vc6[o] cb4[o] gcc[o]
            #include<iostream>
            #include<algorithm>
            #include<vector>

            template<typename T>
            class  print
            {
            public:
                void operator()(const T& elem) // operator() 重载
                {
                    std::cout << elem << ' ';
                }
            private:
            };

            int main()
            {
                int ia[6] = { 0,1,2,3,4,5 };
                std::vector<int> iv(ia, ia + 6);
                for_each(iv.begin(), iv.end(), print<int>());
            }


静态常量整数成员在 class 内部直接初始化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果 class 内含 const static intefral data member， 那么根据 C++ 标准规范，我们
可以在 class 之内直接赋初值。所谓 integral 泛指所有整数类型，不单只是指 int 。

.. code-block:: c++
    :linenos:
    :emphasize-lines: 8,9,10

    // vc6[x] cb4[o] gcc[o]
    #include<iostream>

    template<typename T>
    class  testClass
    {
    public:
        static const int _datai = 5;
        static const long _datal = 3L;
        static const char _datac = 'c';
    };

    int main()
    {
        std::cout << testClass<int>::_datai << std::endl;   // 5
        std::cout << testClass<int>::_datal << std::endl;   // 3
        std::cout << testClass<int>::_datac << std::endl;   // c
    }

increment / decrement / dereference 操作符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

increment / dereference 操作符在迭代器的实现上占有非常重要的地位，因为i任何一个
迭代器都必须实现出前进（ **increment** , operator++ ）和取值（ **dereference** , operator* ）功能，
前者还分为前置式和后置式两种。有些迭代器具备双向移动的功能，那么就必须再提供
decrement 操作符（也分前置式和后置式两种）。下面是一个示例：

.. code-block:: c++
    :linenos:

    // vc6[x] cb4[o] gcc[o]
    // vc6 的 friend 机制搭配 C++ 标准程序库，有 bug
    #include<iostream>

    class INT
    {
        friend std::ostream& operator<<(std::ostream& os, const INT& i);

    public:
        INT(int i) :m_i(i) {};

        // prefix: increment and then fetch
        INT& operator++()
        {
            ++(this->m_i);      // 随着 class 的不同，该行应该有不同的操作
            return *this;
        }
        // postfix: fetch and then increment
        const INT& operator++(int)
        {
            INT temp = *this;
            ++(this->m_i);
            return temp;
        }

        // prefix: decrement and then fetch
        INT& operator--()
        {
            --(this->m_i);      // 随着 class 的不同，该行应该有不同的操作
            return *this;
        }
        // postfix: fetch and then decrement
        const INT& operator--(int)
        {
            INT temp = *this;
            --(this->m_i);
            return temp;
        }

        // dereference
        int& operator*() const
        {
            return (int&)m_i;
            // 以上转换操作告诉编译器，你确实要将 从 const int 转为 non-const lvalue.
            // 如果没有这样显示地转型，有些编译器会给你警告，有些更严格的编译器会视为错误
        }
    private:
        int m_i;
    };

    std::ostream& operator<<(std::ostream& os, const INT& i)
    {
        os << '[' << i.m_i << ']';
        return os;
    }

    int main()
    {
        INT I(5);
        const INT J(5);
        std::cout << I++;   // [5]
        std::cout << ++I;   // [7]
        std::cout << I--;   // [7]
        std::cout << --I;   // [5]
        std::cout << *I;    // 5
    }

前闭后开区间表示法 [)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

任何一个 STL 算法，都需要获得由一对迭代器（泛型指针）所标示的区间，用以表示操作
范围。这一迭代器所标示的是个所谓的前闭后开区间，以[first,last)表示。也就是说，整
个实际范围从 first 开始，直到 last-1。如下两个 STL 算法的循环设计，就显得干净利落：

.. code-block:: c++
    :linenos:

    template<class InputIterator, class T>
    InputIterator find(InputIterator first, InputIterator last, const T& value)
    {
        wihle(first != last && *first != value) ++first;
        return first;
    }

    template<class InputIterator, class Function>
    Function for_each(InputIterator first, InputIterator last, Function f)
    {
        for (; first != last; ++first)
            f(*first);
        return f;
    }

fucntion call 操作符 （operator ()）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

很少有人注意到，函数调用操作（C++ 语法中的左右小括号）也可以被重载。

许多 STL 算法都提供了两个版本，一个用于一般状况（例如排序时以递增方式排序），一
个用于特殊状况（例如排序时由使用者指定以何种特殊关系进行排序）。像这种情况，需要
用户指定某个条件或某个策略，而条件或策略的背后由一整组操作构成，便需要某种特殊的
东西来代表这“一整组操作”。

代表“一整组操作”的，当然是函数。过去 C 语言时代，欲将函数当作参数传递，唯有通过
函数指针才能达成。


但是函数指针由缺点，最重要的时他无法持有自己的状态（所欸局部状态，local states），
也无法达到组件技术中的可适配性（adaptability）—— 也就是无法再将某些修饰条件加诸
于其上而改变其状态。

为此，STL 算法的特殊版本所接受的所谓“条件”或“策略”或“一整组操作”，都以仿函数形式
呈现。所谓仿函数（functor）就是使用起来像函数一样的东西。如果你针对某个 class 进
行 operator() 重载，它就成为一个仿函数。至于要成为一个可配接的仿函数，还需要做一
些额外的努力。

下面是一个将 operator() 重载的例子：

.. code-block:: c++
    :linenos:
    :emphasize-lines: 7,14,28,29

    #include<iostream>

    // 由于将 operator() 重载了，因此 plus 成了一个仿函数
    template<class T>
    struct plus
    {
        T operator()(const T& x, const T& y) const { return x + y; }
    };

    // 由于将 operator() 重载了，因此 minus 成了一个仿函数
    template<class T>
    struct minus
    {
        T operator()(const T& x, const T& y) const { return x - y; }
    };

    int main()
    {
        // 以下产生仿函数对象
        plus<int> plusobj;
        minus<int> minusobj;

        // 以下使用仿函数，就像使用一般函数一样
        std::cout << plusobj(3, 5) << std::endl;            // 8
        std::cout << minusobj(3, 5) << std::endl;           // -2

        // 以下直接产生仿函数临时对象（第一对小括号），并调用之（第二对小括号）
        std::cout << plus<int>()(43, 50) << std::endl;      //93
        std::cout << minus<int>()(43, 50) << std::endl;     // -7
    }


第二章 空间配置器
--------------------------------------------------------------------------------

空间配置器是 STL 实现过程中所必须的，因为整个 STL 的操作对象（所有的数值）都
存放在容器之内，而容器一定需要配置空间以放置资料。

之所以说是空间配置器而不是内存配置器，是因为需要分配的空间不一定是内存，也可
以是磁盘或其它辅助存储介质。

2.1 空间配置器的标准接口
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

根据 STL 的规范，以下是 allocator 的必要接口：

    #.  allocator::value_type
    #.  allocator::pointer
    #.  allocator::const_pointer
    #.  allocator::reference
    #.  allocator::const_reference
    #.  allocator::size_type
    #.  allocator::difference_type
    #.  allocator::rebind
    
        一个嵌套的 class template, class rebind<U> 拥有唯一的成员 other，
        那是一个 typedef ，代表 allocator<U>

    #.  allocator::allocator()
    
        default constructor

    #.  allocator::allocator(const allocator&)
    
        copy constructor

    #.  template <class U> allocator::allocator(const allocator<U>&)
    
        泛化的 copy constructor

    #.  allocator::~allocator()
    
        default deconstructor

    #.  pointer allocator::address(reference x) const
    
        返回某个对象的地址。算式 a.address(x) 等同于 &x

    #.  const_pointer allocator::address(const_reference x) const
    
        返回某个 const 对象的地址。算式 a.address(x) 等同于 &x

    #.  pointer allocator::allocate(size_type n, const void* = 0)
    
        配置空间，足以存储 n 个 T 对象。第二个参数是个提示，实现上可能会利用
        它来增进区域性（locality），或完全忽略之
        
    #.  void allocator::deallocate(pointer p, size_type n)
    
        归还先前配置的空间
        
    #.  size_type allocator::max_size() const
    
        返回可成功配置的最大量
        
    #.  void allocator::construct(pointer p, const T& x)
    
        等同于 new(const void*) p) T(x)
        
    #.  void allocator::destroy(pointer p)
    
        等同于 p->~T()

2.1.1 设计一个简单的空间配置器，JJ::alocator
********************************************************************************

.. code-block:: c++
    :caption: 2jjalloc.h
    :linenos:
    :emphasize-lines: 57,63,68,73,75,77,79

    #pragma once

    #include<new>       // for placement new
    #include<cstddef>   // for ptrdiff_t, size_t
    #include<cstdlib>   // for exit()
    #include<climits>   // for UNIT_MAX
    #include<iostream>  // for cerr

    namespace JJ
    {
        template<class T>
        inline T* _allocate(ptrdiff_t size, T*)
        {
            std::set_new_handler(0);
            T* temp = (T*)(::operator new((size_t)(size * sizeof(T))));
            if (temp == 0)
            {
                std::cerr << "out of memory" << std::endl;
                std::exit(1);
            }
            return temp;
        }

        template<class T>
        inline void _deallocate(T* buffer)
        {
            ::operator delete(buffer);
        }

        template<class T1, class T2>
        inline void _construct(T1* p, const T2& value)
        {
            new (p) T1(value);  // placement new. invoke ctor of T1
        }

        template<class T>
        inline void _destroy(T* ptr)
        {
            ptr->~T();
        }
        template<class T>
        class allocator
        {
        public:
            typedef T value_type;
            typedef T* pointer;
            typedef const T* const_pointer;
            typedef T& reference;
            typedef const T& const_reference;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;

        public:

            // rebind allocator of type U
            template <class U>
            struct rebind
            {
                typedef allocator<U> other;
            };

            // hint used for locality. ref.[Austern],p189
            pointer allocate(size_t n, const void* hint = 0)
            {
                return _allocate((difference_type)n, (pointer)0);
            }

            void construct(pointer p, const T& value)
            {
                _construct(p, value);
            }

            void destroy(pointer p) { _destroy(p); }

            pointer address(reference x) { return (pointer)&x; }

            const_pointer const_address(reference x) { return (const_pointer)&x; }

            size_type max_size() const
            {
                return size_type(UINT_MAX / sizeof(T));
            }
        };
    }

将 JJ::allocator 应用与程序之中，我们发现，它只能有限度地搭配 PJ STL 和 RW STL ，例如：

.. code-block:: c++
    :caption: 2jjalloc.cpp
    :linenos:
    :emphasize-lines: 9

    // vc6[o] BCB4[o] GCC2.9[x]
    #include <iostream>
    #include <vector>
    #include "2jjalloc.h"

    int main()
    {
        int ia[5] = { 0,1,2,3,4 };
        std::vector<int, JJ::allocator<int>> iv(ia, ia + 5);
        for (size_t i = 0; i < iv.size(); ++i)
        {
            std::cout << iv[i] << ' ';
        }
        std::cout << std::endl;
    }

“只能有限度搭配 PJ STL”是因为，PJ STL 未完全遵循 STL 规范，其所供应的许多容
器都需要一个非标准的空间配置接口 allocator::_Charalloc()。

“只能有限度地搭配 RW STL”则是因为，RW STL 在很多容器身上运用了缓冲区，情况复
杂得多，JJ::allocator 无法与之兼容。

至于完全无法应用于 SGI STL，是因为 SGI STL 在这个项目上根本逸脱了 STL 标准
规范，使用一个专属的、拥有次层配置（sub-allocation）能力的、效率优越的特殊配
置器，稍后有详细介绍。

事实上，SGI STL 仍然提供了一个标准的配置器接口，只是把它做了一层隐藏。这个标
准接口的配置器名为 simple_alloc，稍后便会提到。

2.2 具备次层配置力（sub-allocation）的 SGI 空间配置器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SGI STL 的配置器与众不同，也与标准规范不同，其名称是 alloc 而非 allocator，
而且不接受任何参数。换句话说，如果你要在程序中显示采用 SGI 配置器，则不能采
用标准写法：

    .. code-block:: c++
    
        vector<int, std::allocator<int>> iv;    // in VC or CB

必须这么写：

    .. code-block:: c++

        vector<int, std::alloc> iv;             // in GCC

SGI STL allocator 未能符合标准规范，这个事实通常不会给我们带来困扰，因为通
常我们使用缺省的空间配置器，很少有需要自行指定配置器名称，而 SGI STL 的每一
个容器都已经指定其缺省的空间配置器为 alloc 。例如下面的 vector 声明：

    .. code-block:: c++
    
        template <class T, class Alloc = alloc> // 缺省使用 alloc 为配置器
        class vector { ... };

2.2.1 SGI 标准的空间配置器， std::allocator
********************************************************************************

虽然 SGI 也定义有一个符合部分标准、名称 allocator 的配置器，但 SGI 自己从未
使用过它，也不建议我们使用。主要原因是效率不佳，只是把 C++ 的 operator:: new
和 ::operator delete 做一层薄薄的包装而已。下面是 SGI 的 std::allocator
全貌：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 43,48,53,58,63,68,76
    
        #ifndef DEFALLOC_H
        #define DEFALLOC_H

        #include<new.h>
        #include<stddef.h>
        #include<stdlib.h>
        #include<limits.h>
        #include<iostream.h>
        #include<algobase.h>

        template<class T>
        inline T* allocate(ptrdiff_t size, T*)
        {
            set_new_handler(0);
            T* temp = (T*)(::operator new((size_t)(size * sizeof(T))));
            if (temp == 0)
            {
                cerr << "out of memory" << std::endl;
                exit(1);
            }
            return temp;
        }

        template<class T>
        inline void deallocate(T* buffer)
        {
            ::operator delete(buffer);
        }

        template<class T>
        class allocator
        {
        public:
            typedef T value_type;
            typedef T* pointer;
            typedef const T* const_pointer;
            typedef T& reference;
            typedef const T& const_reference;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;

        public:
            pointer allocate(size_type n)
            {
                return ::allocate((difference_type)n, (pointer)0);
            }

            void deallocate(pointer p)
            {
                ::deallocate(p);
            }

            pointer address(reference x)
            {
                return (pointer)&x;
            }

            const_pointer address(const_reference x)
            {
                return (const_pointer)&x;
            }

            size_type init_page_size()
            {
                return max(size_type(1), size_type(4096 / sizeof(T)));
            }

            size_type max_size()
            {
                return max(size_type(1), size_type(UINT_MAX / sizeof(T)));
            }
        };

        // 特化版本（specialization）。注意，为什么最前面不需要加上 template<>?
        // 见 1.9.1 节的状态测试。注意，只适用于 GCC
        class allocator<void>
        {
        public:
            typedef void* pointer;
        };
        #endif

2.2.2 SGI 特殊的空间配置器， std::alloc
********************************************************************************

一般而言，我们所习惯的 C++ 内存配置操作和释放操作是这样的：

        .. code-block:: c++
        
            class Foo { ... };
            Foo* pf = new Foo;      // 配置内存，然后构造对象
            delete pf;              // 将对象析构，然后释放内存

这其中的 ``new`` 算式内含两阶段操作：

    #.  调用 `::operator new` 配置内存；
    #.  调用 `Foo::Foo()` 构造对象内容。

``delete`` 算式也含两阶段操作：

    #.  调用 `Foo::~Foo()` 将对象析构；
    #.  调用 `::operator delete` 释放内存。

为了精密分工，STL allocator 决定将这两阶段操作区分开来。内存配置操作由
`alloc::allocate()` 负责，内存释放操作由 `alloc::deallocate()` 负责；
对象构造操作由 `::constructor()` 负责，对象析构操作由 `::destroy()` 负责。

STL 标准规范告诉我们，配置器定义于 `<memory>` 之中，SGI `<memory>` 内含以
下两个文件：

    .. code-block:: c++

        #include<stl_alloc.h>       // 负责内存空间的配置与释放
        #include<stl_construct.h>   // 负责对象内容的构造与析构

2.2.3 构造和析构基本工具： construct() 和 destroy()
********************************************************************************

2.2.4 空间的配置与释放，std::alloc
********************************************************************************

2.2.5 第一级配置器 __malloc_alloc_template 剖析
********************************************************************************

.. code-block:: c++
    :linenos:
    :emphasize-lines: 20,31,36,49,60,63,81,99

    #if 0
    #include<new>
    #define __THROW_BAD_ALLOC throw bad_alloc
    #elif !defined(__THROW_BAD_ALLOC)
    #include<iostream>
    #define __THROW_BAD_ALLOC std::cerr << "out of memory" << std::endl; exit(1)
    #endif // 0

    template<int inst>
    class __malloc_alloc_template
    {
    private:
        // 以下函数将用来处理内存不足的情况
        // oom: out of memory
        static void* oom_malloc(size_t);
        static void* oom_remalloc(void*, size_t);
        static void (*__malloc_alloc_oom_handler)();

    public:
        static void* allocate(size_t n)
        {
            void* result = malloc(n);      // 第一级配置器直接使用 malloc()
            // 以下无法满足需求时，改用 oom_malloc()
            if (0 == result)
            {
                result = oom_malloc(n);
            }
            return result;
        }

        static void deallocate(void* p, size_t /*n*/)
        {
            free(p);       // 第一级配置器直接使用 free()
        }

        static void* reallocate(void* p, size_t /*old_sz*/, size_t new_sz)
        {
            void* result = remalloc(p, new_sz);      // 第一级配置器直接使用 remalloc()
            // 以下无法满足需求时，改用 oom_remalloc()
            if (0 == result)
            {
                result = oom_remalloc(p, new_sz);
            }
            return result;
        }

        // 以下模仿 C++ 的 set_new_handler()。换句话说，你可以通过它
        // 指定你自己的 out-of-memory handler
        static void(*set_malloc_handler(void (*f)()))()
        {
            void (*old)() = __malloc_alloc_oom_handler;
            __malloc_alloc_oom_handler = f;
            return (old);
        }
    };

    // malloc_alloc out-of-memory handling
    // 初值为0。有待客户端设定
    template<int inst>
    void(*__malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;

    template<int inst>
    void* __malloc_alloc_template<inst>::oom_malloc(size_t n)
    {
        void (*my_malloc_handler)();
        void* result;

        for (;;)        // 不断尝试释、配置、再释放、再配置...
        {
            my_malloc_handler = __malloc_alloc_oom_handler;

            if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }

            (*my_malloc_handler)();     // 调用处理例程，企图释放内存
            result = malloc(n);         // 再次尝试配置内存
            if (result) return (result);
        }
    }

    template<int inst>
    void* __malloc_alloc_template<inst>::oom_remalloc(void* p, size_t n)
    {
        void (*my_malloc_handler)();
        void* result;

        for (;;)        // 不断尝试释、配置、再释放、再配置...
        {
            my_malloc_handler = __malloc_alloc_oom_handler;

            if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }

            (*my_malloc_handler)();         // 调用处理例程，企图释放内存
            result = remalloc(p, n);        // 再次尝试配置内存
            if (result) return (result);
        }
    }

    // 注意，以下直接将参数 inst 指定为 0
    typedef __malloc_alloc_template<0> malloc_alloc;


上述代码与以下代码等价，主要是函数指针的写法不太直观：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 14,21,53,55,64,69,87

        #pragma once
        #if 0
        #include<new>
        #define __THROW_BAD_ALLOC throw bad_alloc
        #elif !defined(__THROW_BAD_ALLOC)
        #include<iostream>
        #define __THROW_BAD_ALLOC std::cerr << "out of memory" << std::endl; exit(1)
        #endif // 0

        template<int inst>
        class __malloc_alloc_template
        {
        public:
            typedef void(*HandlerType)();

        private:
            // 以下函数将用来处理内存不足的情况
            // oom: out of memory
            static void* oom_malloc(size_t);
            static void* oom_remalloc(void*, size_t);
            static HandlerType __malloc_alloc_oom_handler;

        public:
            static void* allocate(size_t n)
            {
                void* result = malloc(n);      // 第一级配置器直接使用 malloc()
                // 以下无法满足需求时，改用 oom_malloc()
                if (0 == result)
                {
                    result = oom_malloc(n);
                }
                return result;
            }

            static void deallocate(void* p, size_t /*n*/)
            {
                free(p);       // 第一级配置器直接使用 free()
            }

            static void* reallocate(void* p, size_t /*old_sz*/, size_t new_sz)
            {
                void* result = remalloc(p, new_sz);      // 第一级配置器直接使用 remalloc()
                // 以下无法满足需求时，改用 oom_remalloc()
                if (0 == result)
                {
                    result = oom_remalloc(p, new_sz);
                }
                return result;
            }

            // 以下模仿 C++ 的 set_new_handler()。换句话说，你可以通过它
            // 指定你自己的 out-of-memory handler
            static HandlerType set_malloc_handler(HandlerType f)
            {
                HandlerType old = __malloc_alloc_oom_handler;
                __malloc_alloc_oom_handler = f;
                return (old);
            }
        };

        // malloc_alloc out-of-memory handling
        // 初值为0。有待客户端设定
        template<int inst>
        __malloc_alloc_template<inst>::HandlerType __malloc_alloc_template<inst>::__malloc_alloc_oom_handler = 0;

        template<int inst>
        void* __malloc_alloc_template<inst>::oom_malloc(size_t n)
        {
            __malloc_alloc_template<inst>::HandlerType my_malloc_handler;
            void* result;

            for (;;)        // 不断尝试释、配置、再释放、再配置...
            {
                my_malloc_handler = __malloc_alloc_oom_handler;

                if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }

                (*my_malloc_handler)();     // 调用处理例程，企图释放内存
                result = malloc(n);         // 再次尝试配置内存
                if (result) return (result);
            }
        }

        template<int inst>
        void* __malloc_alloc_template<inst>::oom_remalloc(void* p, size_t n)
        {
            __malloc_alloc_template<inst>::HandlerType my_malloc_handler;
            void* result;

            for (;;)        // 不断尝试释、配置、再释放、再配置...
            {
                my_malloc_handler = __malloc_alloc_oom_handler;

                if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }

                (*my_malloc_handler)();         // 调用处理例程，企图释放内存
                result = remalloc(p, n);        // 再次尝试配置内存
                if (result) return (result);
            }
        }

        // 注意，以下直接将参数 inst 指定为 0
        typedef __malloc_alloc_template<0> malloc_alloc;

第一级配置器以 ``malloc()``，``free()``，``realloc()`` 等 C 函数执行实际
的内存配置、释放、重配置操作，并实现出类似 C++ new-handler 的机制。是的，它
不能直接运用 C++ new-handler 机制，因为它并非使用 ``::operator new`` 来配
置内存。

所谓 C++ new handler 机制是，你可以要求系统在内存配置需求无法被满足时，调用
一个你所指定的函数。卷句话说，一旦 ``::operator new`` 无法完成任务，在丢出
``std::bad_alloc`` 异常状态之前，会先调用由客户端指定的处理例程。该处理例程
通常即被称为 *new-handler* 。 *new-handler* 解决内存不足的组发有特定的模式，
请参考 《Effecitive C++》2e 条款 7 。

注意，SGI 以 ``malloc`` 而非 ``::operator new`` 来配置内存（能够想到的一个
原因是历史因素，另一个原因是 C++ 并未提供相应于 ``realloc`` 的内存配置操作），
因此，SGI 不能直接使用 C++ 的 `set_new_handler()` ，必须模仿一个类似的
`set_new_handler()` 。

2.2.6 第二级配置器 __sdefault_alloc_template 剖析
********************************************************************************

第二级配置器多了一些机制，避免太多小额区块造成内存的碎片。小额区块带来的其实
不仅是内存碎片，配置时的额外负担也是大问题。

SGI 第二级配置器的做法是，如果区块够大，超过 128 bytes 时，就移交第一级配置
器处理。当区块小于 128 bytes 时，则以内存池管理，此法又称为次层配置：每次配
置一大块内存，并维护对应之自由链表（free-lists）。下次若再有相同大小的内存需
求，就直接从 free-lists 中拨出，如果客户端释还小额区块，就由配置器回收到
free-lists 中 —— 配置器除了负责配置，也负责回收。为了方便管理，SGI 第二级配
置器会主动将任何小额区块的内存需求上调至 8  的倍数，并维护 16 个 free-lists，
各自管理大小分别为 8，16，24，32，40，48，56，64，72，80，88，96，104，112，
120，128 bytes 的小额区块。free-lists 的节点结构如下：

    .. code-block:: c++
        :linenos:

        union obj   // free-lists 的节点构造
        {
            union obj* free_list_link;
            char client_data[1];        /*The client sees this.*/
        };

下面是第二级配置器的部分实现内容：

    .. code-block:: c++
        :linenos:
        :emphasize-lines: 9,13,18,25,28,34,38,41,42,43,45,46,47,52,55,58,62

        enum { __ALIGN = 8 };   // 小型区块的上调边界
        enum { __MAX_BYTES = 128 };   // 小型区块的上限
        enum { __NFREELISTS = __MAX_BYTES / __ALIGN };   // free-lists 个数

        // 以下是第二级配置器
        // 注意，无 "template" 类型参数，且第二参数完全没派上用场
        // 第一参数用于多线程环境下。本书不讨论多线程环境
        template<bool threads, int inst>
        class __default_alloc_template
        {
        private:
            // ROUND_UP 将 bytes 上调至 8 的倍数
            static sizt_t ROUND_UP(size_t bytes)
            {
                return (((bytes)+__ALIGN - 1) & ~(__ALIGN - 1));
            }

            union obj   // free-lists 的节点构造
            {
                union obj* free_list_link;
                char client_data[1];        /*The client sees this.*/
            };

            // 16 个 free-lists
            static obj* volatile free_list[__NFREELISTS];

            // 以下函数根据区块大小，决定使用第 n 号 free-list。 n 从1起算
            static size_t FREELIST_INDEX(size_t bytes)
            {
                return (((bytes)+__ALIGN - 1) / __ALIGN - 1);
            }

            // 返回一个大小为 n 的对象，并可能加入大小为 n 的其它区块到 free list
            static void* refill(size_t n);

            // 配置一大块空间，可容纳 nobjs 个大小为 size 的区块
            // 如果配置 nobjs 个区块有所不便，nobjs 可能会降低
            static char* chunk_alloc(size_t size, int& nobjs);

            // Chunk allocation state
            static char* start_free;    // 内存池起始位置。只在 chunk_alloc() 中变化
            static char* end_free;      // 内存池结束位置。只在 chunk_alloc() 中变化
            static size_t heap_size;
        public:
            static void* allocate(size_t n) {/*详述于后*/ }
            static void* deallocate(void* p, size_t n) {/*详述于后*/ }
            static void* reallocate(void* p, size_t old_sz, size_t new_sz);
        };

        // 以下是 static data member 的定义与初值设定
        template<bool threads, int inst>
        char* __default_alloc_template<threads, inst>::start_free = 0

        template<bool threads, int inst>
        char* __default_alloc_template<threads, inst>::end_free = 0

        template<bool threads, int inst>
        char* __default_alloc_template<threads, inst>::heap_size = 0

        template<bool threads, int inst>
        __default_alloc_template<threads, inst>::obj* volatile
        __default_alloc_template<threads, inst>::free_list[__NFREELISTS] =
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

2.2.7 空间配置函数 allocate()
********************************************************************************

2.2.8 空间释放函数 deallocate()
********************************************************************************

2.2.9 重新填充 free lists
********************************************************************************

2.2.10 内存池（memory pool）
********************************************************************************

2.3 内存基本处理工具
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

STL 定义有5个全局函数，作用于未初始化空间上，这样的功能对于容器的实现很有帮助：

    -   construct()
    -   destroy()
    -   uninitialized_copy()
    -   uninitialized_fill()
    -   uninitialized_fill_n()

前两个函数是之前提到过的用于构造的 ``construct()`` 和用于析构的 ``destroy()``，
另外三个函数分别对应于高层次函数 ``copy()`` 、 ``fill()`` 、``fill_n()`` —— 
这些都是 STL 是算法。如果要使用本节的三个低层次函数，应该包含 ``<memory>`` ，
不过 SGI 把它们实际定义于 ``<stl_uninitialized>`` 。

2.3.1 uninitialized_copy
********************************************************************************

.. code-block:: c++
    
    template<class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);

``uninitialized_copy()`` 使用们能够将内存的配置与对象的构造行为分离开来。如
果作为输出目的地的 *[result, result + (last - first))* 范围内的每一个迭代
器都指向未初始化区域，则 ``uninitialized_copy`` 会使用 *copy constructor* ，
将输入源里面 *[first, last)* 范围内的每一个对象产生一份复制品，再将其放到目
标输出范围中。即针对输入源范围内的每一个迭代器 ``i`` ，该函数会调用
``construct(&(result + (i - first)), *i)`` 来产生 ``*i`` 的复制品，然后
将其放置于目标输出范围的对应位置上。

如果你需要实现一个容器， ``uninitialized_copy()`` 这样的函数会为你带来很大
的帮助，因为容器的全区间构造函数（range constructor）通常以两个步骤完成：

    -   配置内存区块，足以包含范围内的所有元素。
    -   使用 ``uninitialized_copy()`` ，在该内存区块上构造元素。

C++ 标准规范要求 ``uninitialized_copy()`` 具有 **"commit or rollback"**
语义，即要么构造出所有元素，要么不构造任何东西。

2.3.2 uninitialized_fill
********************************************************************************

.. code-block:: c++
    
    template<class ForwardIterator, class T>
    void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);

``uninitialized_fill()`` 也能够使我们将内存配置与对象的构造行为分离开来。如
果 *[first, last)* 范围内的每个迭代器都指向未初始化的内存，那么 ``uninitialized_fill()``
会在该范围内产生 ``x`` 的复制品。即 ``uninitialized_fill()`` 会针对操作范围
内的每个迭代器 ``i`` ，调用 ``construct(&*i, x)`` ，在 ``i`` 所指之处产生
``x`` 的复制品。

与 ``uninitialized_copy()`` 一样， ``uninitialized_fill()`` 必须具备
**"commit or rollback"** 语义。

2.3.3 uninitialized_fill_n
********************************************************************************

.. code-block:: c++
    
    template<class ForwardIterator, class Size, class T>
    ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);

``uninitialized_fill_n()`` 能够使我们将内存配置与对象构造行为分离开来。它
会为指定范围内的所有元素设定相同的初值。

如果 *{first, first + n)* 范围内的每一个迭代器都指向未初始化的内存，那么
``uninitialized_fill_n()`` 会调用 *copy constructor* ，在该范围内产生 ``x``
的复制品。即针对 *[first, first + n)* 范围内的每个迭代器 ``i`` ， ``unintialized_fill_n()``
会调用 ``construct(&*i, x)`` ，在对应位置处产生 ``x`` 的复制品。

``uninitialized_fill_n()`` 也具备 **"commit or rollback"** 语义。

以下分别介绍这三个函数的实现。其中所呈现的 ``iterators`` 、 ``value_type()`` 、
``__type_traits`` 、 ``__true_type`` 、 ``__false_type`` 、 ``is_POD_type``
等实现技术，都将于第 3 章介绍。


第三章 迭代器（iterators）概念与 traits 编程技法
--------------------------------------------------------------------------------


3.1 迭代器设计思维 —— STL 关键所在
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3.2 迭代器（iterator）是一种 smart pointer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3.3 迭代器相应类型（associated types）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3.4 Traits 编程技法 —— STL 源代码门钥
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3.4.5 迭代器相应类型之五： iterator_category
********************************************************************************

根据移动特性与施行操作，迭代器被分为五类：

-   **Input Iterator**: 这种迭代器所指的对象，不允许外界改变。只读。
-   **Output Iteratot**: 只写。
-   **Forward Iterator**: 允许写入型算法（例如 replace() ）在此种迭代器所形成
    的区间上进行读写操作。
-   **Bidirectional Iterator**: 可双向移动。某些算法需要逆向遍历某个迭代器区间
    （例如逆向拷贝某范围内的元素），可以使用 Bidirectional Iterator.
-   **Random Access Iterator**:  前四种迭代器都只供应一部分指针算术能力（前三
    种支持 *opetator++* ，第四种支持 *operator--* ），第五种则涵盖所有指针
    算术能力，包括 *p + n* ， *p - n* ， *p[n]* ， *p1 - p2* ， *p1 < p2* 。

.. graphviz::
    :caption: 迭代器的分类与从属关系
    :align: center

    digraph test{
        bgcolor = "transparent"
        rankdir = TB;
        splines = false;
        node [shape="plaintext"];
        edge [style="solid"];

        subgraph cluster_0 {
            a [label = "Input Iterator"];
            b [label = "Output Iterator"];
            c [label = "Forward Iterator"];
            d [label = "Bidirectional Iterator"];
            e [label = "Random Access Iterator"];

            a:s->c;
            b:s->c;
            c:s->d:n;
            d:s->e:n;
        }
    }

.. code-block:: c++
    :caption: iterator_traits.h
    :linenos:
    :emphasize-lines: 18,29

    #pragma once
    #include<cstddef>

    template<typename T>
    struct iterator_traits
    {
        typedef typename T::iterator_category iterator_category;
        typedef typename T::value_type value_type;
        typedef typename T::difference_type difference_type;
        typedef typename T::pointer pointer;
        typedef typename T::reference reference;
    };

    // 偏特化版本 —— 指针
    template<typename T>
    struct iterator_traits<T*>
    {
        typedef typename /*something todo here*/ iterator_category;
        typedef T value_type;
        typedef ptrdiff_t difference_type;
        typedef T* pointer;
        typedef T& reference;
    };

    // 偏特化版本 —— 常量指针
    template<typename T>
    struct iterator_traits<const T*>
    {
        typedef typename /*something todo here*/ iterator_category;
        typedef T value_type;
        typedef ptrdiff_t difference_type;
        typedef const T* pointer;
        typedef const T& reference;
    };

总结：

    设计适当的相应类型（associated types），是迭代器的责任。设计适当的迭代
    器，则是容器的责任。唯容器本身，才知道该设计出怎样的迭代器来遍历自己，并
    执行迭代器该有的各种行为（前进、后退、取值、取用成员...）。至于算法，完全
    可以独立于容器和迭代器之外自行发展，只要设计时以迭代器为对外接口就行。
    
    **traits** 编程技法大量运用于 STL 实现品中。它利用“内嵌类型”的编程技巧
    与编译器的 template 参数推导功能，增强 C++ 未能提供的关于类型认证方面的
    能力，弥补 C++ 不为强类型（strong typed）语言的遗憾。

3.5 std::iterator 的保证
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3.6 iterator 源代码完整重列
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++
    :caption: stl_iterator.h
    :linenos:

    #pragma once
    #include<cstddef>

    // 节选自 SGI STL <stl_iterator.h>
    // 物种迭代器类型
    struct input_iterator_tag {};
    struct output_iterator_tag {};
    struct forward_iterator_tag :public input_iterator_tag {};
    struct bidirectional_iterator_tag :public forward_iterator_tag {};
    struct random_access_iterator_tag :public bidirectional_iterator_tag {};

    // 为避免写代码时挂一漏万，自行开发迭代器时最好继承自下面这个 std::iterator
    template<class Category, class T, class Distance = ptrdiff_t, class Pointer = T*, class Reference = T&>
    struct iterator
    {
        typedef Category iterator_category;
        typedef T value_type;
        typedef Distance difference_type;
        typedef Pointer pointer;
        typedef Reference reference;
    };

    // “榨汁机” traits
    template<class Iterator>
    struct iterator_traits
    {
        typedef typename Iterator::iterator_category iterator_category;
        typedef typename Iterator::value_type value_type;
        typedef typename Iterator::difference_type difference_type;
        typedef typename Iterator::pointer pointer;
        typedef typename Iterator::reference reference;
    };

    // 针对原生指针而设计的 traits 偏特化版
    template<class T>
    struct iterator_traits<T*>
    {
        typedef random_access_iterator_tag iterator_category;
        typedef T value_type;
        typedef ptrdiff_t difference_type;
        typedef T* pointer;
        typedef T& reference;
    };

    // 针对原生之 pointer-to-const 而设计的 traits 偏特化版
    template<class T>
    struct iterator_traits<const T*>
    {
        typedef random_access_iterator_tag iterator_category;
        typedef T value_type;
        typedef ptrdiff_t difference_type;
        typedef const T* pointer;
        typedef const T& reference;
    };

    // 决定某个迭代器的类型
    template<class Iterator>
    inline typename iterator_traits<Iterator>::iterator_category
    iterator_category(const Iterator&)
    {
        typedef typename iterator_traits<Iterator>::iterator_category categoty;
        return categoty();
    }
    // 决定某个迭代器的 distance type
    template<class Iterator>
    inline typename iterator_traits<Iterator>::difference_type*
    distance_type(const Iterator&)
    {
        return static_cast<typename iterator_traits<Iterator>::difference_type*>(0);
    }

    // 决定某个迭代器的 value type
    template<class Iterator>
    inline typename iterator_traits<Iterator>::value_type*
    value_type(const Iterator&)
    {
        return static_cast<typename iterator_traits<Iterator>::value_type*>(0);
    }

    // 以下是整组 distance 函数
    template<class InputIterator>
    inline typename iterator_traits<InputIterator>::difference_type
    __distance(InputIterator first, InputIterator last, input_iterator_tag)
    {
        typename iterator_traits<InputIterator>::difference_type n = 0;
        while (first != lase)
        {
            ++first;
            ++n;
        }
        return n;
    }

    template<class RandomAccessIterator>
    inline typename iterator_traits<RandomAccessIterator>::difference_type
    __distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag)
    {
        return last - first;
    }

    template<class InputIterator>
    inline typename iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last)
    {
        typedef typename iterator_traits<InputIterator>::iterator_category category;
        return__distance(first, last, category());
    }

    // 以下是整组 advance 函数
    template<class InputIterator, class Distance>
    inline void __advance(InputIterator& i, Distance n, input_iterator_tag)
    {
        while (n--) ++i;
    }

    template<class BidirectionalIterator, class Distance>
    inline void __advance(BidirectionalIterator& i, Distance n, bidirectional_iterator_tag)
    {
        if (n >= 0)
            while (n--)
                ++i;
        else
            while (n++)
                --i;
    }

    template<class RandomAccessIterator, class Distance>
    inline void __advance(RandomAccessIterator& i, Distance n, random_access_iterator_tag)
    {
        i += n;
    }

    template<class InputIterator, class Distance>
    inline void advance(InputIterator& i, Distance n, random_access_iterator_tag)
    {
        __advance(i, n, iterator_category(i));
    }

3.7 SGI STL 的私房菜： __type_traits
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

traits 编程技法很棒，适度弥补了 C++ 语言本身的不足。STL 只对迭代器加以规范，
制定出 *iterator_traits* 这样的东西。SGI 把这种技法进一步扩大到迭代器以外的
世界，于是有了所谓的 *__type_traits* 。双下划线前缀词意指这是 SGI STL 内部
作用的东西，不在 STL 标准规范之内。

*iterator_traits* 负责萃取迭代器的特性， **__type_traits** 则负责萃取类型
的特性。此处我们所关注的类型特性是指：

    -   这个类型是否具备 non-trivial defalt ctor
    -   是否具备 non-trivial copy ctor
    -   是否具备 non-trivial assignment operator
    -   是否具备 non-trivial dtor

如果答案是否定的，我们在对这个类型进行构造、析构、拷贝、赋值等操作时，就可以
采用最有效率的措施（例如根本不调用身居高位，不谋实事的那些 constructor,
destructor），而采用内存直接处理操作如 *malloc()* 、 *memcpy()* 等等，获得
最高效率。这对于大规模而操作频繁的容器，有着显著的效率提升。

根据 *iterator_traits* 得来的经验，我们希望，程序之中可以这样运用
*__type_traits<T>* , *T* 代表任意类型：

.. code-block:: c++
    :linenos:

    __type_traits<T>::has_trivial_default_constructor
    __type_traits<T>::has_trivial_copy_constructor
    __type_traits<T>::has_trivial_assignmenr_operator
    __type_traits<T>::has_trivial_destructor
    __type_traits<T>::is_POD_type

为达成上述五个式子， *__type_traits* 内必须定义一些 typedefs ，其值不是
*__true_type* 就是 *__false_type* 。下面是 SGI 的做法：

.. code-block:: c++
    :linenos:

    struct __true_type {};
    struct __false_type {};

    template<class type>
    struct __type_traits
    {
        typedef __true_type this_dummy_member_must_be_first;
        
        typedef __false_type has_trivial_default_constructor;
        typedef __false_type has_trivial_copy_constructor;
        typedef __false_type has_trivial_assignmenr_operator;
        typedef __false_type has_trivial_destructor;
        typedef __false_type is_POD_type;

    };

第四章 序列式容器
--------------------------------------------------------------------------------

4.1 容器的概观与分类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. graphviz::
    :caption: 迭代器的分类与从属关系
    :align: center

    digraph test{
        bgcolor = "transparent"
        rankdir = TB;
        splines = false;
        node [shape = "plaintext"];
        edge [style = "invis"];
        
        a0 [label = "序列式容器\nSequence Containers"];
        b0 [label = "关联式容器\nAssociative Containers"];

        node [shape = "box", fixedsize = false, fontsize = 12, margin = "0.11,0.055", width = 0.3 , height = 0.2];
        a1 [label = "Array(built-in)"];
        a2 [label = "Vector"];
        a3 [label = "heap"];
        a4 [label = "priority-queue"];
        a5 [label = "list"];
        a6 [label = "slist"];
        a7 [label = "deque"];
        a8 [label = "stack"];
        a9 [label = "queue"];
        
        b1 [label = "RB-tree"];
        b2 [label = "set"];
        b3 [label = "map"];
        b4 [label = "multiset"];
        b5 [label = "multimap"];
        b6 [label = "hashtable"];
        b7 [label = "hash_set"];
        b8 [label = "hash_map"];
        b9 [label = "hash_multiset"];
        b10 [label = "hash_multimap"];
        
        a0 -> a1;
        a1 -> a2;
        a2 -> a3;
        a3 -> a4;
        a4 -> a5;
        a5 -> a6;
        a6 -> a7;
        a7 -> a8;
        a8 -> a9;
        
        b0 -> b1;
        b1 -> b2;
        b2 -> b3;
        b3 -> b4;
        b4 -> b5;
        b5 -> b6;
        b6 -> b7;
        b7 -> b8;
        b8 -> b9;
        b9 -> b10;
        
    }

4.1.1 序列式容器
********************************************************************************


所谓序列式容器，其中的元素都可序（ *ordered* ），但未必有序（ *sorted* ）。
C++ 语言本身提供了一个序列式容器 **array** ，STL 另外再提供 **vector** ，
**list** ， **deque** ， **stack** ， **queue** ， **priotity-queue**
等等序列式容器。其中 **stack** 和 **queue** 由于只是将 **deque** 改头换面
而成，技术上被归类为一种适配器。

4.2 vector
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4.2.1 vector 概述
********************************************************************************

vector 的数据安排以及操作方式，与 array 非常相似。两者唯一的区别在于空间运用
的灵活性。

array :

    -   静态空间，一旦配置就不能改变
    -   换更大的空间需要客户端自己处理
        
            #.  配置一块新空间
            #.  将元素从旧址一一搬往新址
            #.  把原来的空间释还给系统

vector :

    -   动态空间
    -   随着元素的加入，内部机制会自行扩充空间以容纳新元素

vector 的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。

4.2.2 vector 定义摘要
********************************************************************************

以下是 vector 定义的源代码摘录。虽然 STL 规定，欲使用 vector 者必须先包括
<vector>，但 SGI　STL 将 vector 实现于更底层的 <stl_vector.h>。

.. code-block:: c++
    :caption: stl_vector.h
    :linenos:
    :emphasize-lines: 108,109

    #pragma once
    #include<cstddef>   // for ptrdiff_t, size_t

    class alloc {};

    // alloc 是 SGI STL 的空间配置器，见第二章
    template<class T, class Alloc = alloc>
    class vector
    {
    public:
        // vector的嵌套类型定义
        typedef T value_type;
        typedef value_type* pointer;
        typedef value_type* iterator;       // vector 的迭代器是普通指针
        typedef value_type& reference;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;

    protected:
        // 以下，simple_alloc 是 SGI STL 的空间配置器，见 2.2.4 节
        typedef simple_alloc<value_type, Alloc> data_allocator;
        iterator start;             // 表示目前使用空间的头
        iterator finish;            // 表示目前使用空间的尾
        iterator enf_of_storage;    // 表示目前可用空间的尾

        void insert_aux(iterator positoin, const T& x);
        void deallocate()
        {
            if (start)
                data_allocator::deallocate(start, enf_of_storage - start);
        }

        void fill_initialize(size_type n, const T& value)
        {
            start = allocate_and_fill(n, value);
            finish = start + n;
            enf_of_storage = finish;
        }

    public:
        iterator begin() { return start; }
        iterator end() { return finish; }
        size_type size() const { return size_type(end() - begin()); }
        size_type capacity() const { return size_type(enf_of_storage - begin()); }
        bool empty() const { return begin() == end(); }
        reference operator[](size_type n) { return *(begin() + n); }

        vector() :start(0), finish(0), enf_of_storage(0) {}
        vector(size_type n, const T& value) { fill_initialize(n, v); }
        vector(int n, const T& value) { fill_initialize(n, v); }
        vector(long n, const T& value) { fill_initialize(n, v); }
        explicit vector(size_type n) { fill_initialize(n, T()); }

        ~vector()
        {
            destroy(start, finish);     // 全局函数，见 2.2.3 节
            deallocate();               // 这是 vector 的一个 member function
        }

        reference front() { return *begin(); }      // 第一个元素
        reference back() { return *(end() - 1); }   // 最后一个元素
        void push_back() { const T& x }               // 将元素插入至尾端
        {
            if (finish != end_of_storage)
            {
                construct(finish, x);
                ++finish;               // 全局函数，见 2.2.3 节
            }
            else
                insert_aux(end(), x);
        }

        void pop_back()                 // 将最尾端元素取出
        {
            --finish;
            destroy(finish);
        }

        iterator erase(iterator position)   // 清除某位置上的元素
        {
            if (position + 1 != end())
                copy(position + 1, finish, .position);     // 后续元素往前移动
            --finish;
            destroy(finish);
            return position;
        }

        void resize(size_type new_size, const T& x)
        {
            if (new_size < size)
                erase(begin() + new_size, end());
            else
                insert(end(), new_size - size(), x);
        }
        void resize(size_type new_size) { resize(new_size, T()); }
        void clear() { erase(begin(), end()); }

    protected:
        // 配置空间并填充内容
        iterator allocate_and_fill(size_type n, const T& x)
        {
            iterator result = data_allocator::allocate(n);
            uninitialized_fill_n(result, n, x);       // 全局函数，见 2.3 节
            return result;
        }
    };

    template<class T, class Alloc>
    void vector<T, Alloc>::insert_aux(iterator positoin, const T& x)
    {
        if (finish != enf_of_storage)
        {
            // 在备用空间起始处构造一个元素，并以 vector 最后一个元素值为其初值
            construct(finish, *(finish - 1));
            ++finish;
            T x_copy = x;
            copy_backward(position, finish - 2, finish - 1);
            *positoin = x_copy；
        }
        else
        {
            const size_type old_size = size();
            const size_type len = old_size != 0 ? 2 * old_size : 1;

            iterator new_start = data_allocator::allocate(len); // 实际配置
            iterator new_finish = new_start;

            try
            {
                // 将原 vector 的内容拷贝到新 vector
                new_finish = uninitialized_copy(start, position, new_start);
                // 为新元素设定初值
                construct(new_finish, x);
                ++new_finish;
                // 将原 vector 的备用空间中的内容也拷贝过来（啥用途）
                new_finish = uninitialized_copy(position, finish, new_finish);
            }
            catch (...)
            {
                // "commit or rollback" semantics.
                destroy(new_start, new_finish);
                data_allocator::deallocate(new_start, len);
                throw；
            }

            // 析构并释放原 vector
            destroy(begin(), end());
            deallocate();

            // 调整迭代器，指向新 vector
            start = new_start;
            finish = new_finish;
            enf_of_storage = new_start + len;
        }
    }

4.2.3 vector 的迭代器
********************************************************************************

vector 维护的是一个连续的线性空间，所以不论其元素类型为何，普通指针都可以作
为vector 的迭代器而满足所有必要条件，因为 vector 迭代器所需要的操作行为，如
operator*，operator->，operator++，operator--，operator+，operator-，
operator+=，operator-=，普通指针天生就具备。vector 支持随机存取，而普通指
针正有着这样的能力。所以，vector 提供的是 Random Access Iterators。

4.2.4 vector 的数据结构
********************************************************************************

vector 所采用的数据结构非常简单，线性连续空间。它以两个迭代器 start 和
finish 分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器
end_of_storage 指向整块连续空间（含备用空间）的尾端。

为了降低空间配置时的速度成本，vector 实际配置的大小可能比客户端需求量更大一
些，以备将来可能的扩充。这便是容量（capacity）的观念。换句话说，一个 vector
的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整
个 vectoer 就得另觅居所。

4.2.5 vector 的构造与内存管理： constructor，push_back
********************************************************************************

以客户端程序代码为引导，观察其所得结果并实证源代码，是一个良好的学习路径。下
面是一个小小的测试程序，观察重点在构造的方式、元素的添加，以及大小、容量的变
化：

    .. code-block:: c++
        :caption: 4vector_test.cpp
        :linenos:

        #include <iostream>
        #include <vector>
        #include <algorithm>

        int main()
        {
            int i;
            std::vector<int> iv(2, 9);
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;

            iv.push_back(1);
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;

            iv.push_back(2);
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;

            iv.push_back(3);
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;

            iv.push_back(4);
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;

            iv.push_back(5);
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;

            for (size_t i = 0; i < iv.size(); ++i)
            {
                std::cout << iv[i] << ' ';
            }
            std::cout << std::endl;

            iv.pop_back();
            iv.pop_back();
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;

            iv.pop_back();
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;

            std::vector<int>::iterator ivite = find(iv.begin(), iv.end(), 1);
            if (ivite != iv.end())
                iv.erase(ivite);
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;
            for (size_t i = 0; i < iv.size(); ++i)
            {
                std::cout << iv[i] << ' ';
            }
            std::cout << std::endl;

            ivite = find(iv.begin(), iv.end(), 2);
            if (ivite != iv.end())
                iv.insert(ivite, 3, 7);
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;
            for (size_t i = 0; i < iv.size(); ++i)
            {
                std::cout << iv[i] << ' ';
            }
            std::cout << std::endl;

            iv.clear();
            std::cout << "size = \t\t" << iv.size() << std::endl;
            std::cout << "capacity = \t" << iv.capacity() << std::endl;
        }

    输出： ::

        size =          2
        capacity =      2
        size =          3
        capacity =      3
        size =          4
        capacity =      4
        size =          5
        capacity =      6
        size =          6
        capacity =      6
        size =          7
        capacity =      9
        9 9 1 2 3 4 5
        size =          5
        capacity =      9
        size =          4
        capacity =      9
        size =          3
        capacity =      9
        9 9 2
        size =          6
        capacity =      9
        9 9 7 7 7 2
        size =          0
        capacity =      9

.. Warning::

   对 vector 的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就
   都失效了。这是程序员易犯的一个错误，务必小心。

4.2.6 vector 的元素操作：pop_back，erase，clear，insert
********************************************************************************

4.3 list
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.3.1 list 概述
********************************************************************************

4.3.2 list 的节点（node）
********************************************************************************

.. code-block:: c++
    :linenos:
    
    template<class T>
    struct __list_node
    {
        typedef void* void_pointer;
        void_pointer prev;      //  类型为 void*。其实可设为 __list_node<T>*
        void_pointer next;
        T data;
    };

显然这是一个双向链表。

4.3.3 list 的迭代器
********************************************************************************

list 不再能够像 vector 一样以普通指针作为迭代器，因为其节点不保证在存储空间
中连续存在。由于 STL list 是一个双向链表（double linked-list），迭代器必须
具备前移、后移的能力，所以 list 提供的是 **Bidirectional Iterators** 。

list 还有一个重要性质：插入（insert）操作和接合操作（splice）都不会造成原有
的 list 迭代器失效。甚至 list 的元素删除（erase）操作，也只有“指向被删除元
素”的那个迭代器失效，其它的迭代器不受任何影响。

.. code-block:: c++
    :caption: list_iterator.h
    :linenos:

    #pragma once
    #include<cstddef>   // for ptrdiff_t, size_t

    struct input_iterator_tag {};
    struct output_iterator_tag {};
    struct forward_iterator_tag :public input_iterator_tag {};
    struct bidirectional_iterator_tag :public forward_iterator_tag {};
    struct random_access_iterator_tag :public bidirectional_iterator_tag {};

    template<class T>
    struct __list_node
    {
        typedef void* void_pointer;
        void_pointer prev;      //  类型为 void*。其实可设为 __list_node<T>*
        void_pointer next;
        T data;
    };

    template<class T, class Ref, class Ptr>
    struct __list_iterator
    {
        typedef __list_iterator<T, T&, T*> iterator;
        typedef __list_iterator<T, Ref, Ptr> self;

        typedef bidirectional_iterator_tag iterator_category;
        typedef T value_type;
        typedef ptrdiff_t difference_type;
        typedef Ptr pointer;
        typedef Ref reference;

        typedef size_t size_type;
        typedef __list_node<T>* link_type;

        link_type node; // 迭代器内部当然要有一个普通指针，指向 list 的节点

        // constructor
        __list_iterator(link_type x) :node(x) {}
        __list_iterator() {}
        __list_iterator(const iterator& x) :node(x.node) {}

        bool operator==(const self& x) const { return node == x.node; }
        bool operator!=(const self& x) const { return node != x.node; }

        // 以下对迭代器取值（dereference），取的是节点的数据值
        reference operator*() const { return (*node).data; }

        // 以下是迭代器成员存取（member access）运算子的标准做法
        pointer operator->()const { return &(operator*()); }

        // 对迭代器累加 1 ，就是前进一个节点
        self& operator++()
        {
            node = (link_type)((*node).next);
            return *this;
        }
        self& operator++(int)
        {
            self temp = *this;
            ++* this;
            return temp;
        }

        // 对迭代器递减 1 ，就是后退一个节点
        self& operator--()
        {
            node = (link_type)((*node).prev);
            return *this;
        }
        self& operator--(int)
        {
            self temp = *this;
            --* this;
            return temp;
        }
    };

4.3.4 list 的数据结构
********************************************************************************

4.3.5 list 的构造与内存管理
********************************************************************************

4.3.6 list 的元素操作
********************************************************************************


Open Source Projects
================================================================================


`olcPixelGameEngine <https://github.com/OneLoneCoder/olcPixelGameEngine>`_
--------------------------------------------------------------------------------

C++ Templates
================================================================================

第Ⅰ部分 基础
--------------------------------------------------------------------------------

第2章 函数模板
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   模板函数为不同的模板实参定义了一个函数家族。
-   当你传递模板实参的时候，可以根据实参的类型来对函数模板进行实例化。
-   你可以显示指定模板参数。
-   你可以重载模板函数。
-   当重载模板的时候，把你的改变限制在：显示地指定模板参数。
-   一定要让函数模板的所有重载版本的声明都位于它们被调用的位置之前。

第3章 类模板
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   类模板是具有以下性质的类：在类的实现中，可以有一个或多个类型还没有被指定。
-   为了使用类模板，你可以传入某个具体类型作为模板实参；然后编译器将会基于该类型
    来实例化莫模板。
-   对于类模板而言，只有那些被调用的成员函数才会被实例化。
-   你可以用某种特定类型特化类模板。
-   你可以用某种特定类型局部特化类模板。
-   你可以为类模板的参数定义缺省值，这些值还可以引用之前的模板参数。

第4章 非类型模板参数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   模板可以具有值模板参数，而不仅仅是类型模板参数。
-   对于非类型模板参数，你不能使用浮点数、class 类型的对象和内部链接对象（例如
    string）作为实参。

第5章 技巧性基础知识
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第6章 模板实战
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第7章 模板术语
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第Ⅱ部分 深入模板
--------------------------------------------------------------------------------

第8章 深入模板基础
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第9章 模板中的名称
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第10章 实例化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第11章 模板实参演绎
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第12章 特化与重载
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第13章 未来的方向
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第Ⅲ部分 模板与设计
--------------------------------------------------------------------------------

第14章 模板的多态威力
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第15章 trait 与 policy 类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第16章 模板与继承
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第17章 metaprogram
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第18章 表示式模板
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第Ⅳ部分 高级应用程序
--------------------------------------------------------------------------------

第19章 类型区分
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第20章 智能指针
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第21章 tuple
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

第22章 函数对象和回调
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~