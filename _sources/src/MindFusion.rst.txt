================================================================================
MindFusion.Diagramming for WPF, V3.7
================================================================================

.. :

    = - ` : ' " ~ ^ _ * + # < >

    ====================
    --------------------
    ~~~~~~~~~~~~~~~~~~~~
    ********************
    ++++++++++++++++++++
    ####################
    ::::::::::::::::::::
    >>>>>>>>>>>>>>>>>>>>
    <<<<<<<<<<<<<<<<<<<<


`参考文档 <https://www.mindfusion.eu/onlinehelp/wpfdiagram/index.htm>`_
================================================================================

1. 介绍
--------------------------------------------------------------------------------

WpfDiagram 是一个通用软件组件，可用于以多种不同格式显示各种类型的图表。
它是作为一个 WPF 控件实现的，
并且可以轻松地集成到任何针对 Microsoft WPF 平台的应用程序中。
通过为您的软件提供现成的用于可视化和编辑关系数据的功能，
WpfDiagram 为您节省了数百小时的编码和调试工作。

WpfDiagram 可以使用图形表示：

    -   工作流程
    -   类关系
    -   图和网络
    -   实体关系/数据库图
    -   IVR系统
    -   工业自动化流程
    -   家谱树
    -   算法和流程图
    -   组织结构图
    -   XML文件
    -   分类层次结构
    -   以及更多

WpfDiagram 为创建或编辑图提供了直观的用户交互模型。
此外，它的编程接口还提供了许多有用的功能，
从打印和 XML 序列化到路径查找和自动布局算法。

2. 授权许可
--------------------------------------------------------------------------------

MindFusion 组件没有单独的试用版本。
当您购买组件后，可以在官网页面上找到该组件的许可密钥。
将此许可密钥分配给 **LicenseKey** 属性，以禁用组件的评估模式并停止显示试用消息。
如果开发的应用程序包含多个 MindFusion 组件，
可以从应用程序启动代码中调用 ``MindFusion.Licensing.LicenseManager.AddLicense(key)``
方法指定一次密钥，而不用在使用每个控件时设置。

3. 基本信息
--------------------------------------------------------------------------------

3.1 关于 WpfDiagram 组件
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   再分发是免费的
-   程序集是强命名的
-   可以购买源代码
-   是用C#编写的

3.2 用户交互
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   多种用户交互模式
-   自由式绘图
-   自由形式选择模式
-   滚动和缩放
-   Windows剪贴板的复制、粘贴
-   平移
-   用鼠标拖动项时自动滚动
-   放大
-   网格对齐
-   节点对齐引导线
-   多项选择
-   Tooltips
-   可以为节点定义停靠点（Docking points）
-   撤销/重做支持
-   同时调整多个节点的大小
-   旋转和翻转形状

3.3 编程开发
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   对图表元素的程序化访问
-   流畅的 API 的扩展方法
-   用于自定义外观和行为的众多属性
-   众多的实用方法
-   路径搜索和环形检测
-   丰富的事件集

3.4 Diagram 的存储和检索
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   磁盘上的文件
-   .NET 流
-   ASCII 字符串
-   XML文件
-   JSON 字符串

3.5 输出
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   使用 WPF 渲染到屏幕
-   打印和打印预览
-   到使用 HTML 图像映射的浏览器
-   以 3D 方式显示图形

3.6 导入和导出
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   导入 Visio 2003 XML (VDX) 图纸。
-   导入 Visio 2013 XML (VSDX) 图纸
-   导入 OpenOffice Draw (ODG) 文件
-   导入 Scalable Vector Graphics （SVG） 文件
-   导出位图图像
-   导出 Portable Document Format (PDF) 文件
-   导出 Scalable Vector Graphics (SVG) 文件
-   导出 Visio 2003 XML (VDX) 图纸
-   导出 Visio 2013 XML (VSDX) 图纸
-   导出 Excel Open XML Format (XLSX) 文件 
-   导出 Windows MetaFile (WMF) 图像
-   导出 Drawing Exchange Format (DXF) 文件

3.7 Diagram 元素
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   使用任何 WPF UIElement 作为 diagram node
-   超过 100 种预定义节点形状
-   在节点中显示 SVG 绘图
-   能够定义自定义形状和形状库
-   可模板化的图表节点
-   形状可以任意角度的旋转
-   容器节点
-   无限行数和列数的表格
-   表格单元格可以跨越几列和几行
-   用户绘制的自由形式的轮廓
-   在 TreeView 节点中显示层级数据
-   使用 Visio 模板文件显示形状
-   给 diagram item 指定图层
-   表行的 Sections 可以展开或折叠
-   链接可以由多个段（segments）组成
-   链接段（link segments）可以是直线或曲线
-   每个链接显示多个标签
-   支持自定义节点和链接类型

3.8 自动布局
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   避开障碍方法
-   Spring-Embedder图形布局
-   定向树布局
-   水平/垂直二元树布局
-   径向树状布局
-   分形树布局
-   分层图形布局
-   网格布局
-   模拟退火图布局
-   单向图布局
-   正交图形布局
-   圆形图布局
-   正交链路路由器
-   源代码流程图布局
-   决策流程图布局
-   流程图布局
-   树形图布局
-   泳道图布局图
-   拓扑图布局
-   级联图布局
-   层次图布局
-   三角形图形布局
-   多层次图形布局
-   自动链接路由

3.9 外观
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   节点可以显示图像和文本
-   各种文本对齐方式
-   文字可以在多边形区域内布局。
-   玻璃视觉效果
-   样式化的类似HTML的文本格式
-   可定制的字体和颜色
-   节点的自定义绘画 
-   阴影
-   用户指定的鼠标光标
-   Z顺序
-   丰富的笔和画笔风格选择
-   透明节点
-   隐形节点
-   背景泳道网格

3.10 Behavior
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   锁定图表元素
-   支持只读模式
-   表格可以滚动
-   折叠和展开层次结构分支
-   In-place text editing
-   链接相对于其所连接的节点动态定位

3.11 Link Diagram Items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   节点到节点
-   表行到表行
-   表行到节点
-   未连接的链接

3.12 层次分组
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   将节点附加到其他节点
-   将节点附加到链接控制点（link control points）
-   将节点附加到链接段（link segments）

3.13 辅助控件
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   预览控件
-   标尺控件
-   虚拟图表控件
-   NodeListView控件
-   ShapeListBox控件
-   LayerListView控件
-   TabbedDiagramView控件
-   缩放控件
-   形状设计器控件

4. 编程接口概述
--------------------------------------------------------------------------------

4.1 集成 WpfDiagram 到用户界面中
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

WpfDiagram 开发包中提供的大部分功能都是由 `Diagram <https://www.mindfusion.eu/onlinehelp/wpfdiagram/T_MindFusion_Diagramming_Wpf_Diagram.htm>`_ 
类实现的。你可以直接它的实例作为 **Panel** 派生对象的子元素。
在这种情况下，它将和其它 WPF 控件一样进行测量和布局 。
注意，在测量阶段， **Diagram** 实例总是返回他的 `Bounds <https://www.mindfusion.eu/onlinehelp/wpfdiagram/P_MindFusion_Diagramming_Wpf_Diagram_Bounds_0.htm>`_
属性作为所需的尺寸，而不是使用其内容的尺寸。

**Diagram** 也可以放在以下容器中：

    -   **ScrollViewer**: 使用它以提供对 Diagram 内容的滚动和平移操作。
    -   `Ruler <https://www.mindfusion.eu/onlinehelp/wpfdiagram/T_MindFusion_Diagramming_Wpf_Ruler.htm>`_ :
        提供滚动操作，还显示对齐标尺，用于测量和对齐 diagram 中的对象。
    -   `DiagramView <https://www.mindfusion.eu/onlinehelp/wpfdiagram/T_MindFusion_Diagramming_Wpf_DiagramView.htm>`_ :
        支持显示同一个 diagram 的多个视图，每个视图具有不同的缩放级别和滚动位置。

4.2 Diagram 结构
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  标准的 Item 类型

    WpfDiagram 中的图表元素（diagram elements）
    由 ``DiagramNode`` 和 ``DiagramLink`` 类的实例表示。
    通过组合和链接（combined and linked together），
    它们可以形成复杂的数据结构，例如流程或实体关系图、类层次结构、网络和图形（graphs）。
    它们的每个特性（rich features）都可以通过多种方法和属性进行自定义。
    WpfDiagram 还提供直观的（intuitive）用户界面，用于以交互方式绘制和编辑图表项目。

    -   形状节点（Shape Nodes）

        形状节点可以表示几何形状、流程图元素、网络图中的图标等。
        它们可以以不同的字体、大小和颜色显示图形和文本。
        有超过 100 个预定义的节点形状（node shapes），除此之外，
        WpfDiagram 还提供了一种定义自定义形状（shapes）的简单方法。
        可以使用绘制在节点上方的圆形选择手柄（selection handle）交互式地旋转形状节点，
        或使用 ``RotationAngle`` 属性以编程方式旋转形状节点。
        可以使用多种类型的自定义绘制（custom painting）方式
        进一步自定义 ``ShapeNode`` 的外观。

            -   第一种类型使您可以完全控制绘制（painting）。
            -   第一种类型中您的绘制代码是在基本绘制基础之上执行的。
            -   第三个类型，节点执行标准的绘制，可以自定义其阴影的绘制。

    -   SVG Nodes

        除了基础类 ``ShapeNode`` 提供的渲染之外，
        ``SvgNode`` 类还可以表示显示 SVG 绘图（drawings）的节点（nodes）。
        一个节点的 SVG 绘图在其关联的位图（bitmap） ``Image`` 之后渲染。
        设置基本类（base type）的 ``Transparent`` 属性
        以隐藏节点的 ``Shape`` 几何图形并仅绘制 SVG 图形（graphics）。
        应该在 **SvgNode** 内显示的 SVG 绘图是通过节点的 ``Content`` 属性指定的。
        SVG 图形（graphics）通过 **SvgContent** 对象加载并与节点关联，
        该对象应该被初始化然后分配给这个属性。

    -   Templated Nodes

        ``TemplatedNode`` 类表示其外观是通过 Xaml 数据模板设置的节点。
        此类主要用作自定义节点的基本类型，
        如 :ref:`教程三 <src/MindFusion:5.3 创建一个自定义节点类型>` 和
        :ref:`教程四 <src/MindFusion:5.4 自定义节点的集成>` 所示。
        但是它不是抽象类，如果在 ``DiagramItem`` 中定义的文本相关属性足以满足您的需求，
        则可以直接使用它。
        此类节点的外观可以通过它们的 ``Template`` 属性
        或 ``Diagram`` 类的 ``NodeTemplate`` 属性进行设置。

    -   Table Nodes

        表格（Tables）可用于表示数据库图中的表模式或类层次结构中的类。
        表格包含排列在网格中（arranged in a  grid）的单元格（cells），
        每个单元格都可以显示文本和/或图像。
        单元格可以跨越在 ``RowSpan`` 和 ``ColumnSpan`` 属性中设置的多个行和列。
        单元格、列和行可以通过多种方式自定义 —— 有一些属性
        可用于设置它们的缩进（extents）、样式、图像和文本对齐方式。
        可以通过编程方式更改表格的尺寸（dimensions）；
        插入、追加或删除行和列可以在您需要时以非常全面、直观的方式完成。
        表格还可以显示背景图像（background images）和图形（graphics）。
        支持的文件格式有 BMP、GIF、JPEG、ICO 和 WMF（同样适用于形状节点）。

    -   容器节点（Container Nodes）

        一个 ``ContainerNode`` 可以包含其他图表节点（diagram nodes）。
        当容器移动时，包含的节点也会移动。
        容器可以折叠以隐藏包含的节点，然后展开以再次显示它们。
        容器内的节点可以链接到（be linked to）容器内部和外部的节点。
        当容器折叠时，连接到包含在容器内部节点的链接将会指向容器轮廓。
        容器可以一个嵌套另一个，深度不限。。

    -   自由形式节点（Free-form Nodes）

        一个 ``FreeFormNode`` 节点从用户的鼠标或触摸输入中收集所有点（points），
        并将它们显示为节点的轮廓（node's outline）。
        要让用户以交互方式绘制自由形式的节点，
        请将 ``Behavior`` 设置为 ``DrawFreeForms`` 。
        使用 **FreeFormNode** 的 ``Points`` 属性以编程方式获取或设置轮廓点。
        如果设置了 ``Closed`` 属性，则将节点绘制为封闭形状并填充其内部，
        否则将节点绘制为折线（poly-line）。
        如果用户绘制的第一个和最后一个点之间的距离小于 ``AutoCloseDistance`` ，
        则该节点将自动闭合。

    -   TreeView Nodes

        ``TreeViewNode`` 类表示可以显示分层数据的节点（nodes）。
        可以通过 ``RootItems`` 属性访问节点中显示的根项目（root items）。
        可以在返回的集合中添加和删除 items 。
        根项目可以有自己的子项目。
        有关更多信息，请参阅 `TreeViewItem <https://www.mindfusion.eu/onlinehelp/wpfdiagram/T_MindFusion_Diagramming_Wpf_TreeViewItem.htm>`_ 类。

    -   Visio Nodes

        图表（diagram）可以以 Visio 2003 XML 模板（stencil ）格式（.vsx）
        显示模板文件（stencil file）中的形状（shapes）。
        要加载模板文件，请使用 ``VisioStencil`` 类的实例。
        形状（shapes）通过 ``VisioNode`` 对象显示在图表中。
        要将模板形状（stencil shape）与节点关联，
        请创建 ``VisioContent`` 类的实例并将其分配给节点的 ``Content`` 属性。
        请注意，随 Visio 安装的标准模板（stencils）的版权归 Microsoft 所有，
        您不应在应用程序中使用它们。
        此功能旨在让您使用公共领域的模板或已购买许可的商业剪贴画（commercial clipart）。

    -   Barcode Nodes

        ``BarcodeNode`` 类将 EAN、UPC、Code 128 或 QR 条码显示为节点的内容。
        就地编辑操作允许用户为一维代码输入新的数字代码或为二维码输入文本字符串。
        条码的格式（format）通过 ``Format`` 属性指定，编码数字（encoded number）或
        文本通过 ``Content`` 属性进行设置，
        一维条（1D bars）/二维模块（2D modules）的颜色通过 ``BarColor`` 设置。

    -   链接（Links）

        链接用于表示图表（diagrams）中的各种类型的连接（connections）和关系（relations）。
        WpfDiagram 提供三种基本链接类型：

            -   由直线段（segments）组成的折线链接（ ``Polyline`` links）
            -   由贝塞尔（Bézier）或样条线段（spline segments）组成的曲线链接（ **Curved** links）
            -   由水平线段和垂直线段组成的级联链接（ **Cascading** links），
                它们的方向交替变化，因此每个线段都与其相邻线段正交。

        一个链接可以通过其两端连接到节点（node）。
        也可以有未连接到节点的链接 —— 它们的一端或两端未连接到节点。
        链接一些可自定义的属性包括：
        箭头（arrowheads）、 ``Shape`` 、颜色、文本、笔宽和样式、
        修改行为（modification behavior）和段数（number of segments）。

#.  自定义 Item 类型

    您可以通过派生 ``DiagramNode`` 和 ``DiagramLink`` 类或其子类
    （例如 TableNode、ContainerNode 等）来创建自己的 item 类型。
    您可以向 diagram items 添加自定义数据字段，并实现自定义的可视化和交互功能。

    -   序列化

        如果您将自定义字段添加到您的 item 类，
        您可能希望在保存图表文件（diagram files）时保存它们的值，
        并在加载文件时恢复它们。
        要启用此功能，请重写 ``DiagramItem`` 类的 SaveTo\* 和 LoadFrom\* 方法，
        您可以使用 **BinaryWriter** 和 **BinaryReader** 对象来实现二进制序列化。
        对于 XML 格式的序列化，您必须实现 ``SaveToXml`` 和 ``LoadFromXml`` 方法。

    -   剪贴板操作

        您必须实现 ``Clone`` 方法
        以使 ``CopyToClipboard`` 和 ``PasteFromClipboard`` 能在您的自定义 item 类型
        中使用。如果没有实现 **Clone** ，在粘贴时将会得到其基类的实例。
        当基类反序列化代码试图从派生类创建的数据流加载 item 的状态（state）时，
        可能会导致异常。如果您的类有任何自定义字段，
        它还必须实现 ``SaveToXml`` 和 ``LoadFromXml`` 方法以进行正确的序列化。

    -   渲染

        如果您需要为您的 items 提供自定义渲染（rendering），请重写 ``Draw`` 方法。
        通过这种方式，您可以在 **DrawingContext** 上渲染您的 item。

    -   用户交互

        要启用从自定义类绘制（drawing） items，
        请将图表视图（diagram view）的 ``Behavior`` 属性设置为 **Custom** ，
        并将 ``CustomNodeType`` 或 ``CustomLinkType`` 属性
        设置为与自定义 item 类对应的对象。
        如果需要更改 items 在初始创建时处理用户交互的方式，
        请实现 ``StartCreate`` 、 ``UpdateCreate`` 和 ``CompleteCreate`` 方法。
        为了更改项目在被修改时响应用户交互的方式，
        请实现 ``StartModify`` 、 ``UpdateModify`` 和 ``CompleteModify`` 方法。

#.  使用 WPF 控件作为节点

    ``DiagramNodeAdapter`` 类允许您使用任何 WPF UIElement 对象
    作为图表节点（diagram node）。
    这允许您使用现成的或自定义的 WPF 控件来显示或编辑应用程序图表中表示的实体。
    WpfDiagram 节点中托管（hosted in diagrams）的控件可能是交互式的
    并带有嵌入式用户界面。
    例如，您可以使用日历、网格、富文本控件或 html 页面作为实体编辑器或查看器。
    您还可以创建自己的自定义控件并将其与 WpfDiagram 无缝集成；
    因此，您可以获得应用程序所需的高级实体关系图编辑器。

    -   交互式创建

        要让用户使用鼠标绘制 **UIElement** 对象，
        请将 ``Behavior`` 设置为 **Custom** 。
        要在宿主节点（host nodes）中创建的控件类型
        由 ``Diagram`` 的 ``CustomNodeType`` 属性指定。
        如果执行以下代码，用户绘制的每个节点都会托管（host）一个 ``GridView`` 实例，
        节点之间可以通过绘制链接来连接：

        .. code-block :: C#

            // Draw datagrid nodes and allow connecting them with links
            diagram.Behavior = Behavior.Custom;

            // Default type of hosted controls is GridView
            diagram.CustomNodeType = typeof(GridView);

    -   编程式创建

        要以编程方式在图表（diagram）中显示 WPF UIElement 派生类的对象，
        请将该类的实例添加到图表的 ``Nodes`` 集合中。
        这会自动为 **UIElement** 对象创建一个 ``DiagramNodeAdapter`` 。 
        您也可以显式实例化 ``DiagramNodeAdapter`` 并将其添加到 **Nodes** 。
        要获取与 **UIElement** 关联的 **DiagramNodeAdapter** ，
        请使用 **DiagramItem** 中相关的附加属性。

#.  创建和删除 Items

    -   编程式创建 Items

        要向图表（diagram）添加新节点（node）或链接（link），
        请使用 **new** 运算符创建 item 类的实例，
        并将其添加到图表的 ``Nodes`` 或 ``Links`` 集合中。
        这与添加来自自定义类的 items 或来自 WpfDiagram 预定义类型的 items 的方式相同。

        图表的 ``Factory`` 对象的成员方法
        提供了一些创建预定义节点和链接类型实例的快捷方法：

            -   ``CreateShapeNode`` 方法在指定位置创建一个 ``ShapeNode`` 。
            -   ``CreateTableNode`` 方法在指定位置创建一个 ``TableNode`` 。
                表格（tables）的 ``AddRelation`` 方法可以将它们自己与其它表格连接起来。
            -   ``CreateContainerNode`` 方法在指定位置创建一个 ``ContainerNode``。
            -   ``CreateDiagramLink`` 方法有多个重载，
                允许连接相同类型或不同类型的两个节点（nodes）。

    -   绘制新的 Items

        用户可以用鼠标绘制（draw）图表元素（diagram elements）。
        ``Behavior`` 属性指定当用户开始绘制时应该创建什么类型的元素。
        当用户开始绘制时，将创建一个 item 并引发初始化事件，
        让您在将 item 显示在屏幕上之前自定义 item 的外观。
        初始化事件包括 InitializeNode 、InitializeLink 等。
        在绘制 item 时，控件会引发诸如 ``NodeCreating`` 之类的验证事件，
        以让您验证操作并防止在特定位置创建 items 。
        当用户释放鼠标按钮时，item 将被添加到 ``Nodes`` 或 ``Links`` 集合中，
        并引发相关的事件，例如 ``NodeCreated`` 。

    -   删除 Items

        调用 ``Nodes`` 或 ``Links`` 集合的 ``Remove`` 方法
        从图表（diagram）中删除一个 item 。
        ``ClearAll`` 方法通过删除所有 items 来清除图表中的内容。
        ``BreakRelation`` 方法提供了删除两个表格（tables）之间链接（link）的快捷方式。

#.  访问 Items

    使用该组件时最常见的任务之一是遍历图表文档（diagram document）中的所有 items
    或浏览 items 之间的连接（connections） —— 从节点（node）到传入或传出链接（links），
    或从链接到其源节点（origin）和目标（destionation）节点。
    要枚举（enumerate）图表的 items ，
    请使用 ``Items`` 、 ``Links`` 或 ``Nodes`` 集合。
    一个链接所连接的节点（nodes）由其 ``Destination`` 和 ``Origin`` 属性引用。
    要访问连接到（connected to）节点的链接，
    请使用其 ``IncomingLinks`` 和 ``OutgoingLinks`` 集合。
    链接可以连接到表格的行（rows of a table），要查找此类链接，
    请使用表格的 ``Rows`` 集合以及 **IncomingLinks** 和 **OutgoingLinks** 集合。
    ``Row`` 类的 ``RelatedOneToMany`` 和 ``RelatedManyToOne`` 属性
    提供了访问实体关系图中关系另一端的快捷方式。

    -   选中的 Items

        如果仅选择一个 item ，则它将被视为 active item,
        并可使用 ``ActiveItem`` 属性进行获取。
        这个属性的类型是 ``DiagramItem`` ；
        您可以通过 .NET 反射获取所选 item 的实际类型。
        在同时按下 CTRL 键的情况下单击或拖动时，可以选择多个 items 。
        多选由 ``Diagram`` 类的 ``Selection`` 属性表示。
        ``Selection`` 对象提供集合以访问选定的 ``Links`` 和 ``Nodes`` 。

    -   查找 Items

        您可以使用 ``FindLink`` 、 ``FindNode`` 、 ``FindLinkById``
        和 ``FindNodeById`` 方法按 **Tag** 或 ``Id`` 搜索 diagram items 。 
        Tag 和 id 对象通过调用 **System.Object** 类的 Equals 方法进行比较。
        因此，如果 tags 是值类型，则它们按值进行比较（即按位相等）。
        如果它们是引用类型，则使用它们的 **Equals** 方法。
        如果有多个相同 tag 的 items ，将返回第一个。
        如果不存在具有指定 tag 的 item，则将返回空引用（ **null** ）。
        也可以使用 ``FindGroup`` 方法根据 tag 搜索组（groups）。

    -   关系查询

        ``Query`` 方法通过跟踪节点（node）/链接（link）的连接（connections）和
        组（group）的父/子关系来遍历图（graph），以查找与当前项具有特定关系的 items 。
        该方法接收由选择器和可选谓词组成的字符串参数。
        查询分几个步骤执行。
        在每一步中，结果集都是根据当前选择器指定的关系从前一个结果集构建的。
        如果在选择器标识符之后指定谓词，则结果集将被过滤以仅包括谓词评估为真的 items 。

#.  附加（Attaching）、组合（Grouping） Items

    WpfDiagram 允许将节点（node）附加（attaching to）到另一个图表元素（diagram element），
    在两个 items 之间建立 从属-主 关系（subordinate - master relationship）。
    附加节点的最简单的方式是调用 ``AttachTo`` 方法。
    当主元素被移动或调整大小时，任何从属节点都会跟随它，
    因此两个 items 之间的初始距离保持不变。
    当用户移动主 item 时，以及使用方法或属性更改 item 位置时，都会发生这种情况。

    -   可能的使用场景

        -   将一个透明的（ ``Transparent`` ）形状节点（shape node）
            附加到另一个 item 并设置其 ``Text`` ，
            这样就可以使形状节点充当分配给主 item 的附加标签（additional label）。
        -   将一个形状节点附加到另一个 item 上，并设置该节点的 ``Image`` ，
            使其作为显示在主 item 内部或附近的附加图标（additional icon）。
        -   将一个形状节点或表格（table）附加到另一个 item 上，
            并处理 ``NodeClicked`` 或类似事件，以对主 item 执行某些操作。
            这使得从属节点充当一个按钮或附加到主 item 的另一种类型的 UI 元素。
            对于更复杂的 UI 需求，可以使用附加的（attached） ``DiagramNodeAdapter``
            并处理由它所托管的（host）控件引发的事件。
        -   在之前的所有情况下，可以为附加节点（attached nodes）设置 ``Locked`` 属性，
            这些节点仅用作修饰主 item 的装饰。
            这可以防止用户选择、修改或绘制指向从属 items 的链接（links）。
        -   将树分支中的子元素附加到分支根上，以便当用户移动树节点时，
            该节点的子元素与该节点同时移动。
            修改这样的分层组（hierarchical group）中的一个 item
            将使修改遍及所有从属 items 。

    -   组合（Hierarchical Grouping）

        一个附加项目单元（A unit of attached items）由 ``Group`` 类的一个实例表示。
        要创建一个组 ，实例化一个 ``Group`` 对象并将其添加到图表的 ``Groups`` 集合中，
        或者调用 ``CreateGroup`` 方法将主 item 作为参数传递。
        可以使用各种 **Group** 方法将 items 附加（attach）到组。
        节点（nodes）的 ``AttachTo`` 方法是创建组并向其附加一个 item 的快捷方式。

        一个组的每个成员都可以是另一个组的主项（master item），
        即一个项可以从属（subordinate）于一个组，同时又可以是另一个组的主项（master）。
        WpfDiagram 不会对以这种方式构建的组层次结构的深度和宽度施加任何限制。
        但是，不可能将一个项作为从属项放在多个组中，因为这样会使层次关系会变得不明确。

    -   Unions

        可以创建这样的组，如果层次结构中的任何项被修改，所有其他项也会被更新。
        这可以通过将项放在依赖关系的循环链中来实现——即 item1 附加到 item2
        item2 附加到 item3 …… itemN 附加到 item1。
        如果这些项中的任何一项被修改，则更改将通过链传播，直到到达其发起者。

    -   附加（Attaching） Items 到 Group

        链接（Links）不能附加到组，但可以是组的主项。
        如果一个组的主项是一个链接（link），则节点（nodes）可以附加到
        链接的控制点（control points）或段（segments）。
        有关详细信息，请参阅 ``AttachToLinkPoint`` 和 ``AttachToLinkSegment`` 方法。
        如果主项是一个节点（node），那么其他节点可以附加到它的任何角落，
        或者附加到指定为主节点边界矩形百分比的区域。
        查看 ``AttachToCorner`` 和 ``AttachProportional`` 了解详细信息。
        ``DiagramNode`` 类的 **AttachTo** 方法提供了创建 ``Group`` 实例
        和调用适当的 AttachTo\* 方法的快捷方式。
 
    -   访问 Group 中的 Items

        可以使用 ``MainItem`` 属性和 ``AttachedNodes`` 集合访问组中的成员。
        要获取项参与了哪些组，请使用其 ``MasterGroup`` 和 ``SubordinateGroup`` 属性。

    -   销毁 Groups

        如果用户删除一个组的主项（master item），
        该组将自动销毁并引发 ``GroupDestroyed`` 事件。
        如果启用 ``AutoDeleteItems`` ，则组中的从属项也会被删除。
        如果 ``AutoDeleteItems`` 被禁用，则从属项将与它们的主项分离并保持完整。
        可以通过从图表的 ``Groups`` 集合中删除组来以编程方式销毁组。

#.  图层（Layers）

    -   说明

        Items 可以分配给图层（assigned to layers），图层可以作为一个组一起被
        隐藏、锁定或按 Z 轴顺序上下移动。
        ``Layer`` 对象提供 ``Visible`` 、 ``Locked`` 和 ``ZIndex`` 属性，
        这些属性将影响相应图层中的所有 items。
        图层还提供了可以显示在 ``LayerListView`` 控件中的 ``Title`` 属性。
        新绘制的 items 被添加到通过 ``Diagram.ActiveLayer`` 指定的图层。

        设置 item 的 ``LayerIndex`` 属性以将它们与 ``Diagram.Layers`` 集合中的
        图层相关联。如果 ``LayerIndex`` 的值为默认值 -1，
        则该 item 不与任何图层关联，
        其可见性仅取决于 item 自己的 ``Visible`` 属性。

    -   Layer list 控件

        ``LayerListView`` 控件提供用于处理 ``Layer`` 对象的用户界面。
        该控件显示一个指定图表的图层列表，显示它们的标题和每个图层中对象的概览图像，
        还允许编辑图层的 ``Visible`` 和 ``Locked`` 属性
        和设置 **Diagram** 的当前活动图层。
        单击 + 按钮可以将新图层添加到 **Diagram** 中，单击 - 按钮可以删除图层。

#.  树型分支的折叠展开

    如果图表（diagram）表示树结构，
    则可以折叠或展开从节点（from a node）开始的树分支（tree branch），
    以隐藏或显示层次结构详细信息（hierarchy details）。 
    使用节点（node）的 ``Collapse`` 和 ``Expand`` 方法以编程方式执行此操作。
    要确定子树（subtree）是展开还是折叠，请检查其根（root）的 ``Expanded`` 属性。

    -   显示展开/折叠按钮

        如果节点（node）的 ``Expandable`` 属性设置为 **true** ，
        则该节点旁边会显示一个 [±] 按钮，以允许用户从该节点处折叠或展开树枝。
        可以通过图表的 ``ExpandButtonPosition`` 属性自定义按钮位置。
        默认情况下，按下该按钮会自动调用 ``Collapse`` 和 ``Expand`` 方法
        并引发 ``TreeExpanded`` 或 ``TreeCollapsed`` 事件。

    -   Defining Tree Direction

        一个节点（node）可以通过传出和传入链接（outgoing and incoming links）
        连接到（connected to）其他节点。
        设置 ``ExpandOnIncoming`` 属性指定连接到节点的哪些项将被视为其后代（descendants）。
        如果 **ExpandOnIncoming** 为 **false** （默认值），
        则每个节点都将被视为其传出链接和附加到（attached to）它们的 items 的父节点。
        如果 **ExpandOnIncoming** 设置为 **true** ，则节点的传入链接被定义为其子节点。
        因此该属性指定了图表 items 之间的父子关系的方向以及折叠/展开的整体方向。

    -   递归地展开分支

        使用 ``RecursiveExpand`` 属性指定展开时是显示从节点开始的整个树分支，
        还是仅显示第一级后代（descendants）。
        一个相关的属性是 ``Group`` 类的 ``Expandable`` 属性，
        它指定展开和折叠是否通过组成员传播。

    -   HtmlBuilder 的支持

        ``HtmlBuilder`` 类可以为显示在 ``Expandable`` 节点旁边的 [±] 按钮
        生成地图区域（map areas）。
        要启用它，请为 ``ExpandBtnHyperLink`` 属性分配一个 URL。
        该 URL 可以包含一些格式说明符（format specifiers），
        这些说明符会自动替换为节点的 **Tag** 或 ``ZIndex`` 属性的值。
        在服务器端，您可以识别被点击了 [±] 按钮的节点。

    -   自定义展开/折叠功能

        通过使用 ``ExpandButtonAction`` 属性，您可以覆盖 [±] 按钮的标准功能。
        如果您需要实现自己的展开/折叠逻辑，请将此属性设置为 ``RaiseEvents``
        并处理 ``ExpandButtonClicked`` 事件。


#.  多个 Diagram Pages

    ``DiagramDocument`` 类表示由 ``DiagramPage`` 对象表示的
    一组图表页面或工作表（diagram pages or sheets）。
    新页面（pages）可以添加到文档（document）中，
    已有的页面可以通过 ``Pages`` 集合进行删除和重新排序。
    **DiagramDocument** 的 ``SaveToXml`` 方法将所有页面保存在一个文件中，
    相应的 ``LoadFromXml`` 方法则从文件中加载所有页面。
    **DiagramDocument** 还可以加载由 ``Diagram`` 的序列化方法创建的文件，
    并将它们显示在单个页面中。
    注意，相反的情况是不正确的：**Diagram** 不能直接加载 **DiagramDocument** 文件。

    **DiagramPage** 派生自 **Diagram** 并且只添加了 ``Title`` 属性，
    因此任何处理 **Diagram** 对象的代码也可以与 **DiagramPage** 对象一起使用。
    图表文档（diagram document）转发其页面（pages）引发的每个事件，
    让您有机会对不同页面引发的事件使用相同的处理程序。
    如果页面应该实现不同的用户交互或验证逻辑，
    也可以将处理程序附加到（attach handlers to）
    由 **DiagramPage** 继承的 **Diagram** 中的事件。

    **DiagramDocument** 可以导出到 PDF 和 Visio，
    并使用 ``PdfExporter`` 、 ``VisioExporter`` 和 ``VisioImporter`` 类中
    可用的新重载的方法从 Visio 导入。 
    其他导出类目前不支持多页导出（multi-page export），
    但仍可通过它们的 Export(Diagram) 方法导出单个页面。

    可以将单个 **DiagramPage** 分配给 ``DiagramView`` 的 ``Diagram`` 属性，
    这样您就可以创建自己的用户界面，用于向用户显示页面列表（a list of pages）并选择当前页面。
    该软件包还包括一个 ``TabbedDiagramView`` ，
    它以选项卡式用户界面中显示文档的所有页面（all pages of a document），
    其中每个选项卡对应一个页面。
    活动选项卡中显示的页面由 **TabbedDiagramView** 的 **CurrentPage** 属性公开。 
    活动页面可以通过激活其关联的选项卡以交互方式进行更改。
    可以通过选项卡托盘中的按钮在文档中添加和删除新页面，
    并且可以通过用鼠标拖动相关选项卡来重新排列页面。

4.3 用户交互
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  控制用户交互

    有多种方法可以控制用户对整个图表（diagram）或
    图表中单个项目（individual items）的操作。

    -   禁用交互

        通过将 ``Diagram`` 的 **Enabled** 属性设置为 **false** ，
        您可以使图表内容完全不可修改。
        因此，它只不过是一个静态图像，您可以用来向用户呈现一些数据。
        但是，图仍然可以通过编程方式进行修改。

    -   指定如何解释用户的操作

        ``Behavior`` 属性提供了几组预定义的规则，指定如何解释用户使用鼠标/键盘的输入。
        如果将 **Behavior** 设置为 ``LinkShapes`` ，
        则从文档中未被占用的点开始的鼠标拖动将被处理为 ``ShapeNode`` 创建请求，
        并在节点上拖动时创建链接（link）。
        请注意，在创建重叠（overlaying ）节点时，这种行为会导致一些额外的工作 —— 用户
        需要在空白区域绘制第二个节点，然后将其移到第一个节点上。
        如果您想避免这种情况，请使用 **DrawShapes** 行为（behavior）。
        如果设置为 **LinkTables** ，则在空白区域上拖动鼠标会创建一个表格，
        而在表格上拖动会创建一个链接。行为（behaviod）选项还包括 
        **DrawLinks** 、 **DrawTables** 和 **Modify** 。

    -   设置 diagram 的边界（Bounds）

        可以使用 ``Bounds`` 属性获取或设置文档大小。
        默认情况下，用户可以将 items 移动到图表边界（diagram bounds）之外。
        为防止出现这种情况，请启用 ``RestrictItemsToBounds`` 属性。
        它提供了三个选项来限制 item 的位置：

            -   他们可能根本不受限制。
            -   最严格的选项是将 item 完全保留在文档区域内。
            -   另一个选项允许 item 部分位于文档区域之外，但至少有一个小的可见部分在内部。

    -   Item 的约束（Constraints）

        通过 ``Constraints`` 和 ``EnabledHandles`` 属性设置对用户如何修改节点的限制。
        前者可用于约束移动方向、节点大小和纵横比。
        后者启用或禁用节点的特定操作句柄（handles）。
        这允许使节点不可移动、不可调整大小或仅在水平/垂直方向上调整大小。

        可以通过 ``Locked`` 属性锁定 item。
        锁定的 item 被排除在选择之外，用户无法选择、移动或修改它们。

    -   控制链接（Links）如何连接到节点（Nodes）

        ``DiagramNode`` 类的 ``AllowIncomingLinks`` 属性指定是否可以
        将传入（incoming）链接绘制到节点。
        ``AllowOutgoingLinks`` 属性指定是否允许绘制节点的传出（outgoing）链接。

        锚点（anchor points）定义当用户将链接（link）附加（attach）到节点（node）时
        链接的末端放置的位置。
        可以通过设置节点的 ``AnchorPattern`` 将锚点模板赋值给节点。
        ``SnapToAnchor`` 属性指定在创建或修改链接时链接末端是否与锚点对齐。

        链接被创建后，用户仍然可以将其端点移动到不同的位置，
        除非将 ``LinkEndsMovable`` 属性设置为 **false** 。
        这也可以通过 ``AllowMoveEnd`` 和 ``AllowMoveStart`` 属性
        在每个链接上进行控制。
        您可以使用 ``LinkModifying`` 事件动态验证链接端点的移动。

        ``AllowSelfLoops`` 属性启用或禁用自反（reflexive）链接的绘制。
        默认情况下这是被允许的，但如果您认为它们对应用程序毫无意义，则可以禁用它们。
        ``AllowLinksRepeat`` 控制两个节点（nodes）是否可以在同一方向上多次连接。

    -   In-place Text Editing

        节点（nodes）和表格的文本可以通过双击相应的 items 就地编辑（in-place）。
        要启用该功能，请将 ``AllowInplaceEdit`` 属性设置为 **true** 。
        对于表格，标题和单元格都可以通过这种方式进行编辑。
        处理 ``CellTextEditing`` 事件以启用/禁用每个单元格的就地编辑。
        根据正在编辑的 item 的类型，在编辑完成时触发以下事件之一：
        ``NodeTextEdited`` 、 ``CellTextEdited`` 。
        当用户在文本输入控件外单击时，将退出就地编辑模式。
        如果分别启用了 ``InplaceEditAcceptOnEnter`` 和 ``InplaceEditCancelOnEsc`` ，
        则按 ENTER 或 ESC 将退出就地编辑模式。

    -   验证事件

        当用户尝试创建、删除或选择项目（item）时，会引发以下事件之一。
        要禁止该操作，请将相应事件中的 bool 类型的参数设置为 **false** ：

        ========================    ============================================
        事件                         描述
        ========================    ============================================
        NodeCreating                当用户绘制新节点（node）时引发。
        LinkCreating                当用户绘制新链接（link）时引发。
        NodeSelecting               当用户试图选择节点时引发。
        LinkSelecting               当用户试图选择链接时引发。
        NodeDeleting                当用户试图删除节点时引发。
        LinkDeleting                当用户试图删除链接时引发。
        NodeModifying               在用户修改现有节点时引发。
        LinkModifying               当用户修改现有链接时引发。
        ========================    ============================================

        有关可由用户操作触发的更多事件，请参阅文档的 `事件 <https://www.mindfusion.eu/onlinehelp/wpfdiagram/T_MindFusion_Diagramming_Wpf_DiagramBase_Events.htm>`_ 部分。

    -   杂项

        -   将 ``SelectAfterCreate`` 属性设置为 **true** 会自动选择每个新创建的 item，
            因此用户可以立即对其进行修改。
        -   ``ModifierKeyActions`` 属性允许为 CTRL、ALT 和 SHIFT 键分配不同的功能。
        -   ``AllowMultipleResize`` 指定用户是否可以同时调整多个选定 items 的大小。

#.  事件的处理

    大多数事件仅在响应用户操作时才引发。
    如果您需要在用户操作和 API 调用之后执行相同的代码，请将公共代码移动到一个方法中，
    并在相应的事件处理程序中以及在 API 方法或属性设置器调用之后调用该方法。
    一个值得注意的例外是 \*Deleted 事件集，当以编程方式删除 items 时也会引发这些事件，
    因为在某些情况下删除 items 可能会删除与其相关的其他 items 。

    当用户开始使用鼠标绘制新 item 时，控件会引发一个初始化事件，
    让您可以设置 item 的外观属性。
    也就是说，对于一个节点（node），控件引发 ``InitializeNode`` 事件。

    当用户按住鼠标按钮并绘图时，将引发一个验证事件，
    允许您取消 item 的创建(例如， ``NodeCreating`` )。
    如果没有取消该操作，将引发一个创建事件，
    以让应用程序了解新项 item (例如 ``NodeCreated`` )。
    当用户修改 item 时，会引发事件，例如 ``NodeModifying`` 和 ``NodeModified`` 。
    在节点（nodes）或链接（links）引发的 \*Modifying 或 \*Creating 事件中
    调用 **CancelDrag** 方法可以取消对 item 的修改或创建。

    当用户按下 DEL 键时，会引发一个验证事件，
    让您确认是否删除一个 item（例如， ``NodeDeleting`` ），如果没有取消，
    则会引发一个 item 删除事件（例如， ``NodeDeleted`` ）。

    还有许多与用户可以在图表上执行的各种活动相关的其他事件。
    所有的事件都可以在这里找到： `Diagram Events <https://www.mindfusion.eu/onlinehelp/wpfdiagram/T_MindFusion_Diagramming_Wpf_DiagramBase_Events.htm>`_

#.  单选、多选

    -   Items 的选取和编辑

        为了移动或修改图表元素（diagram element），
        用户需要拖动其调整手柄（adjustment handles）。
        当 item 被选中时，调整手柄会出现在 item 的周围。
        可以拖动每个手柄以对 item 执行特定转换。
        可以通过 ``HandlesStyle`` 属性修改手柄的外观和行为。
        根据分配给 ``ModificationStart`` 的值，当鼠标指针悬停在 item 上时，
        这些手柄也可以自动出现。

    -   Active Item

        如果仅选择了一个 diagram item，则它被视为是 "active" 的 item。 
        多选择中的一个 item 也被视为是 "active" —— 通常是最后选择的那个 item 。
        在 active item 周围绘制了白色修改手柄，而多选中的其他 items 则带有灰色手柄。
        active item 可能是用户在编辑图表时最感兴趣的，
        您的程序可以根据此更新其状态和用户界面。
        使用 ``Diagram`` 类的 ``ActiveItem`` 属性可以访问到 active item 。

    -   多选

        WpfDiagram 中图表项（diagram items）的选择由 ``Selection`` 类的一个实例表示。
        此类提供了以编程方式选择或取消选择 items 的方法，
        和可以指定选择的外观和行为方式（behaves）的属性。
        ``Diagram`` 类的一个属性（也称为 ``Selection`` ），
        暴露了当前文档中选择的 items 。
        可以选择多个 items ，从而同时移动。
        要以编程方式在多选中添加或删除 items ，
        请调用 ``AddItem`` 、 ``Toggle`` 和 ``RemoveItem`` 方法之一。
        ``Clear`` 方法取消选择所有 items ，
        ``Change`` 方法选择单个 item ，同时取消选择所有其他 items 。
        将 ``AllowMultipleSelection`` 设置为 **false** 将禁用多选。

    -   绘制选中套索（Lasso）

        要选择多个 items ，用户必须在按住 CTRL 键的同时用鼠标左键绘制选择套索或矩形。
        为了启用自由形式套索模式（free-form lasso mode），
        请将 ``FreeFormMode`` 设置为 **true** 。
        ``MiddleButtonActions`` 和 ``RightButtonActions`` 属性
        允许您使用鼠标中键或右键来绘制选择套索。

    -   外观

        多选的视觉样式由 ``Selection`` 类的 ``Style`` 属性定义。
        例如，选区可能被绘制为虚线矩形或半透明填充矩形。
        可以通过设置 selection 的 ``Pen`` 和 ``Brush`` 属性来更改选择矩形的颜色。
        与选择可视化相关的另一个属性是图表的 ``SelectionOnTop`` ，
        它指定所选 items 是必须根据其 Z 轴顺序绘制还是在未选择 items 的顶部进行绘制。

    -   枚举 or 遍历（Enumerating）Items

        ``Selection`` 类将所选的 items 公开为 .NET 集合。
        ``Items`` 集合引用所有选中的 items ，将它们作为 ``DiagramItem`` 实例进行解析。
        ``Nodes`` 和 ``Links`` 集合保留对相应类的选定 items 的引用。
        或者，您可以枚举图中的所有 items 并检查它们的 ``Selected`` 属性。

    -   自动选取

        将 ``SelectAfterCreate`` 属性设置为 **true** 会自动选择每个新创建的 item ，
        因此用户可以立即对其进行修改。

#.  自动对齐

    以下特性帮助用户以交互方式对齐 items 。


    -   对齐网格

        当启用 ``AlignToGrid`` 时，项目将与网格对齐。
        更多信息可以在 `Alignment Grid  <https://www.mindfusion.eu/onlinehelp/wpfdiagram/CC_Alignment_Grid_0.htm>`_
        主题中找到。

    -   节点（nodes）对齐到节点（ nodes ）

        如果启用 ``AutoAlignNodes`` ，
        当前正在绘制或调整大小的节点（node）将与另一个节点对齐，
        以便它们的一对垂直或水平边成为共线。
        要指定节点对齐的最大距离，请设置 ``AutoAlignDistance`` 属性。
        通过使用分配给 ``AlignmentGuidePen`` 的笔绘制对齐参考线，
        可以直观地指示这对对齐的节点。

    -   将链接吸附（snap）到附近的节点（nodes）

        设置 ``AutoSnapLinks`` 后，当前绘制或修改的链接（links）可以
        自动捕捉（snap to）到最近节点的最近边界点（border point）。
        链接连接到附近节点的最大距离是通过 ``AutoSnapDistance`` 设置的。


#.  剪贴板操作

    可以将单个 diagram item 或一组选中的 items 复制或剪切到 Windows 剪贴板。
    这是使用 ``CopyToClipboard`` 和 ``CutToClipboard`` 方法以编程方式完成的。
    要将剪贴板内容粘贴到当前 diagram 中，请调用 ``PasteFromClipboard`` 方法。

    WpfDiagram 不为剪贴板操作提供键盘接口。
    您可以将标准的 CTRL+C、CTRL+X 和 CTRL+V 快捷方式分配给菜单项，
    并通过调用相应的方法来处理它们。

#.  滚动和缩放

    为了使用滚动，您必须将 ``Diagram`` 控件放置在 **ScrollViewer** 、 ``Ruler`` 或
    ``DiagramView`` 中。

    -   自动滚动

        ``AutoScroll`` 属性控制自动滚动。
        如果启用它并且用户在操作一个 item 时
        拖动 ``Diagram`` 边缘（edges）附近的调整手柄（adjustment handles），
        则控件将向鼠标位置滚动视口（viewport）。
        ``ScrollZoneSize`` 属性定义了
        触发自动滚动的视图边框附近区域（area near the view borders）的大小。

    -   Diagram 尺寸

        图表（diagram）的尺寸是通过 ``Bounds`` 属性设置的。
        它的值是一个 **Rect** 实例，它指定了图表坐标系的原点（origin）和图表尺寸。

    -   编程方式控制滚动

        为了以编程方式滚动文档内容（document content），
        您可以调用 ``ScrollTo`` 方法或设置 ``ScrollX`` 和 ``ScrollY`` 属性。
        后者还可用于在需要时访问当前滚动位置。
        ``BringIntoView`` 方法滚动视口（viewport）以确保
        可以在视图（view）中看到特定的 diagram item 。

    -   滚动表格

        表格行也可以滚动。 如果 ``Scrollable`` 属性设置为 **true** ，
        则在表格的标题区域中会显示一个向上/向下滚动按钮。
        通过该按钮，用户可以滚动表格的行。
        滚动也可以使用 ``CurrentScrollRow`` 属性以编程方式完成。

    -   缩放（Zooming）

        缩放由 ``ZoomFactor`` 属性、 ``ZoomIn`` 和 ``ZoomOut`` 方法控制。
        缩放系数（zoom factor）以百分比表示，100% 表示不缩放。
        高于 100% 使图表项目在屏幕上看起来更近和更大 - 放大（zoom in）。
        低于 100% 使项目在屏幕上看起来更远和更小 - 缩小（zoom out）。
        ``ZoomIn`` 方法将缩放系数增加 10%。
        ``ZoomOut`` 方法将缩放系数降低 10%。
        要缩放和滚动视图（view）以使图表内容适合控件的工作区（client area），
        请调用 ``ZoomToFit`` 。
        要缩放和滚动视图（view）以使其适合控件工作区中指定的矩形文档区域，
        请调用 ``ZoomToRect`` 。

    -   套索（Lasso）缩放工具

        该控件支持多种使用套索工具进行缩放的方法：
        
            -   将 ``Behavior`` 属性设置为 ``Zoom`` 将会始终绘制缩放套索。
            -   为 ``ModifierKeyActions`` 中的一个键设置 ``Zoom`` 标志，
                让用户可以在按下相应的修饰键（modifier key）和鼠标左键的情况下
                绘制缩放套索。
            -   将 ``Zoom`` 值分配给 ``RightButtonActions`` 或
                ``MiddleButtonActions`` 属性以使用相应的鼠标按钮进行缩放。

    -   放大（Magnifying）

        ``Diagram`` 提供了通过放大镜工具（magnifier tool）放大（或缩小）图表部分的功能。
        通过将 ``MagnifierEnabled`` 设置为 **true** ，可以永久激活放大镜工具。
        或者，可以通过鼠标右键或按一个修饰键（modifier key）来在需要时进行放大，
        分别为 ``RightButtonActions`` 或 ``ModifierKeyActions`` 属性设置适当的值。

        放大系数可以通过 ``MagnifierFactor`` 属性指定。
        可以通过 ``MagnifierWidth`` 和 ``MagnifierHeight`` 属性设置工具的大小。

    -   平移（Panning）

        按住 ALT 键同时按住鼠标左键拖动，可以平移图表视图（diagram view）。
        通过 ``ModifierKeyActions`` 可以设置另一个修饰键（modifier key）来进行平移。
        ``MiddleButtonActions`` 和 ``RightButtonActions`` 属性允许您
        使用鼠标中键或右键开始平移。
        WpfDiagram 在平移时显示 ``PanCursor`` 。

#.  Tooltips

    Tool-tips 是当鼠标指针悬停在图表项目（diagram item）上一段时间时显示的简短文本消息。
    要启用 tool-tips，请将 ``ShowToolTips`` 属性设置为 **true** 。
    Tool-tips 出现之前的延迟由 ``ToolTipDelay`` 属性设置。

    可以为每个图表元素（diagram element）和整个文档（document）定义 tool-tips 。
    如果鼠标指针静止不动并且指向一个 item ，则显示该 item 的 tool-tips 。
    如果光标下没有任何 item，或者如果有一个 item 但没有为其定义任何 tool-tips 文本，
    则会显示 diagram 的 tool-tips 。
    分配给节点的锚点（anchor points）也提供一个 ``ToolTip`` 属性。

    Tool-tip 的文字也作为 items 对应的图片区域的 ALT 属性的值；
    有关更多信息，请参阅 `HtmlBuilder <https://www.mindfusion.eu/onlinehelp/wpfdiagram/T_MindFusion_Diagramming_Wpf_HtmlBuilder.htm>`_ 。


#.  In-place Editing the Contents of Items

    -   标准的 in-place 编辑

        要激活 WpfDiagram 对象文本的标准就地编辑，
        请将 ``AllowInplaceEdit`` 属性设置为 **true** 。
        ``AllowInplaceEdit`` 允许通过双击就地编辑图表元素的内容。
        通过单击文本字段外的任意位置，可以接受（编辑后的内容）和退出就地编辑模式。

        如果您想更改接受/拒绝更改的方式，
        以下 ``Diagram`` 属性允许使用 ENTER 和 ESC 键执行该操作：
        ``InplaceEditAcceptOnEnter`` 和 ``InplaceEditCancelOnEsc`` 。
        当 **InplaceEditAcceptOnEnter** 设置为 **true** 时，
        按 ENTER 键会导致接受更改并退出就地编辑模式。
        如果 **InplaceEditAcceptOnEnter** 设置为 **false** ，
        则在就地编辑模式下按 ENTER 会在文本中插入新行。
        如果 **InplaceEditCancelOnEsc** 设置为 **true** ，
        则按 ESC 键执行拒绝更改并退出就地编辑模式。

        就地编辑可应用于以下属性：

            -   ShapeNode.Text
            -   DiagramLink.Text
            -   TableNode.Cell.Text
            -   ``TableNode.Caption``
            -   ``ContainerNode.Caption``

        对于表格，标题和单元格都可以通过这种方式进行编辑。

        如果要启用/禁用特定表格单元格的就地编辑，请处理 ``CellTextEditing`` 事件。
        要启用/禁用节点（nodes）的就地编辑，请处理 ``NodeTextEditing`` 事件。
        对于 ``DiagramLink`` 对象，在就地编辑时会引发 ``LinkTextEditing`` 事件。
        这些验证事件可让您在必要时阻止用户编辑特定对象中的文本。

        节点（node）的就地编辑完成后，将引发 ``NodeTextEdited`` 事件。
        对于表格的单元格，可以处理 ``CellTextEdited`` 事件。
        当 ``DiagramLink`` 对象的就地编辑完成时引发 ``LinkTextEdited`` 事件。

        默认情况下，WpfDiagram 创建一个 **TextBox** 控件来让用户编辑 item 的文本。
        ``EnterInplaceEditMode`` 事件允许自定义该控件的属性，
        或将事件处理程序附加（attach）到该事件。
        ``InplaceEditFont`` 指定就地编辑文本框的字体。
        实际上，**InplaceEditFont** 被赋值给该文本框的 **Font** 属性

        离开就地编辑模式时，会引发 ``LeaveInplaceEditMode`` 事件。
        在关闭就地编辑控件的所有情况下都会引发此事件，例如，
        当用户接受或取消对 item 文本所做的更改时，或者当调用 ``EndEdit`` 方法时。

        要以编程方式进入就地编辑模式并让用户内联（inline）编辑 item 的文本，
        请调用 **Diagram** 的 ``BeginEdit`` 方法。 **EndEdit** 方法退出就地编辑模式。


    -   对自定义 Items 的 in-place 编辑

        ``InplaceEditable`` 接口允许为自定义的 item 实现标准的就地编辑。
        通过该接口的方法，您可以指定就地编辑文本框控件的位置，
        并将输入的文本复制到编辑项（edited item）的属性中。

        ``GetEditRect`` 返回就地编辑框的目标矩形。
        ``GetTextToEdit`` 表示就地编辑框的初始内容。
        ``SetEditedText`` 在完成就地编辑后将编辑后的文本赋给对象。

4.4 位置和布局
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  Items 的布局 —— 位置、尺寸和 Z-顺序

    -   测量单位（Measure Unit）

        ``MeasureUnit`` 属性指赋值给给 WpfDiagram 属性或作为参数传递给其方法的
        所有位置和尺寸相关值的度量单位。

    -   Nodes 的位置和尺寸

        使用 ``Bounds`` 属性获取或更改节点（node）的位置和大小。
        要移动节点而不改变其尺寸，请调用 ``Move`` 方法。
        要仅更改节点的尺寸，请调用 ``Resize`` 方法。
        ``ShapeNode.ResizeToFitImage`` 和 ``TableNode.ResizeToFitImage`` 方法
        设置节点的尺寸以适应其图片的尺寸。

    -   链接控制点（Link Control Points）

        链接（Links）有两个或多个控制点（control points），
        取决于它们的 ``Shape`` 和 ``SegmentCount`` 属性值。
        您可以通过链接的 ``ControlPoints`` 集合访问控制点。
        你必须在移动一个链接的控制点之后调用它的 ``UpdateFromPoints`` 方法，
        这是重新绘制链接和更新其内部状态变量所必须的。
        ``Bounds`` 属性是只读的。它返回能包围所有链接点的最小矩形。

    -   动态链接（Link Dynamic）

        如果连接到链接（link）的节点（nodes）被移动或调整大小，
        可以启用链接的 ``Dynamic`` 属性，使链接自动重新计算其端点位置；
        调整端点位置后，重新使链接指向连接到的节点的中心。
        一个相关的属性是 ``AutoSnapToNode`` ，当用户移动链接末端时，
        可以启用该属性使链接端点与链接的源（origin）或目标（destination）节点的
        边界（border）对齐。

        ``RetainForm`` 属性对于具有
        两个以上控制点（control points）的链接（links）很有用。
        如果一个链接所连接的节点（nodes）被移动，通常只更新该链接末端的段（segments），
        以便它们保持与各自节点的连接。在这种情况下，所有中间的控制点都保持在原来的位置。
        但是，如果启用了 ``RetainForm`` ，所有控制点将同时移动，以保持彼此的相对位置，
        从而保持链接的整体形式。

        链接有一个 ``AutoRoute`` 属性，可以启用或禁用链接的自动路由。
        路由链路（Routes links）通过在它们的起点（origin）和目的地（destionation）
        之间找到不跨越任何其他节点（nodes）的最短路径来避开其它节点。
        可以通过使用 ``RoutingOptions`` 公开的属性来调整链接路由算法。

    -   交互式移动或调整尺寸

        应用程序的最终用户可以移动或调整图表元素（diagram elements）的尺寸。
        用户通过选择一个 item 并拖动它的任何一个调整手柄（adjustment handles）、
        内部点、任何边或选择框来实现这一点。
        节点（nodes）的 ``HandlesStyle`` 属性控制如何执行交互。
        此外，它还定义了所选 item 在屏幕上如何显示。
        ``EnabledHandles`` 可以让您禁用允许用户在节点上执行的特定操作，
        例如水平调整 item 的尺寸或移动它。
        如果以交互方式修改 item ，
        则会引发 ``NodeModified`` 或 ``LinkModified`` 事件，
        具体取决于 item 的类型。

    -   控制 Z-顺序

        Z 轴顺序定义了项目在 Z 轴上的排序方式 - 以便一个看起来高于或低于另一个。
        ``DiagramItem`` 类的成员使您可以完全控制 Z 顺序。
        要将 item 向上或向下移动一级，请调用 ``ZLevelUp`` 或 ``ZLevelDown`` 方法。
        要将 item 移动到 Z 顺序的底部，请调用其 ``ZBottom`` 方法。
        要将 item 移动到所有其他 items 的前面，请调用其 ``ZTop`` 方法。
        您可以使用 ``ZIndex`` 属性来获取或设置 Z 轴顺序。

#.  对齐网格

    WpfDiagram 提供了一个对齐网格来帮助用户更精确地放置 diagram items 。
    要启用网格，请将 ``AlignToGrid`` 属性设置为 true。
    如果在创建或修改 items 时网格处于启用状态，则 item 的控制点将与最近的网格点对齐。
    相邻网格点之间的距离由 ``GridSizeX`` 和 ``GridSizeY`` 属性设置。
    ``GridOffsetX`` 和 ``GridOffsetY`` 属性允许指定对齐网格中第一个点的
    水平和垂直偏移。

    用户创建或修改的 items 会自动与网格对齐。
    但是，如果 item 是以编程方式放置在图表中，
    则它们的坐标将设置为指定位置而不进行对齐。
    在这种情况下，如果必须将 items 准确放置在网格点上，
    请使用 ``AlignPointToGrid`` 方法。

    网格是否可见，取决于 ``ShowGrid`` 的值是 **true** 还是 **false** 。
    如果可见，则按照 ``GridStyle`` 属性指定的方式，
    将网格绘制为一个点矩阵或一系列交叉线。 ``GridPen`` 定义用于绘制对齐点或线的笔。

#.  车道（Lanes）网格
#.  Diagram 的自动布局

    处理层次结构或更复杂实体关系数据的应用程序可能需要以一种美观和视觉上吸引人的方式
    将数据呈现给最终用户。

    这类应用程序将它们的数据存储为可能附加（attached）了附加（additional）信息
    的连接节点（connected nodes）的图（graph）。
    然而，节点（nodes）的位置和大小、坐标可能是不必要的和/或不可用的。
    WpfDiagram 提供了一种自动排列图表节点（nodes of diagram）的方法，
    在图表（diagram）的整体结构上应用有吸引力的布局。
    为了利用该功能，应用程序可以通过为其节点（nodes）分配通用坐标、实例化布局对象
    并调用布局的 ``Arrange`` 方法来创建图表。
    .NET 4.5 版本的 ``diagramming.dll`` 程序集提供了非阻塞的 ``ArrangeAsync`` 方法。
    通过将 items 的 ``IgnoreLayout`` 属性设置为 true，
    可以防止 ``Arrange`` 方法更改 individual items 的位置。

    实现自动布局算法的类位于 ``MindFusion.Diagramming.Wpf.Layout`` 命名空间中。
    以下部分列出了按其一般实现策略分类的可用算法：

        -   force-directed algorithms
        -   graph topology based algorithms
        -   semantics based algorithms

    -   Force-directed layout algorithms
    -   Topology based layout algorithms
    -   Semantics based layout algorithms
    -   Multi-level layout algorithms

#.  链接的路由

    路由链接（Routed links）通过找到不跨越任何其他节点的起点和目的地之间的最短路径
    来避开标记为障碍的节点。

    -   设置链接的路由器

        控件通过调用实现 ``ILinkRouter`` 接口的对象的方法
        来查找受附近节点修改影响的链接的路径。
        可以通过 ``Diagram`` 类的 ``LinkRouter`` 属性获取或设置此对象。
        WpfDiagram 提供了两个实现 **ILinkRouter** 的类 —— ``GridRouter`` 和
        ``QuickRouter`` 。
        默认情况下， **LinkRouter** 设置为 **QuickRouter** 的实例。

    -   自动式或显式路由（Automatic or Explicit Routing）

        可以调用 ``RouteAllLinks`` 方法以不跨节点的方式 **显式** 重新排列链接。
        此外，链接（links）有一个 ``AutoRoute`` 属性，可以启用或禁用链接的自动路由；
        该属性是从图表的 ``RouteLinks`` 成员初始化的。
        ``RoutingOptions`` 类的 ``TriggerRerouting`` 成员指定
        何时必须自动重新路由链接。

    -   调整（Tuning）路由算法

        当使用 ``GridRouter`` 时， ``RoutingOptions`` 类允许
        对路由算法的各个方面进行自定义。
        该算法对可能的路径进行评估，以找到成本最小的路径。
        ``LengthCost`` 、 ``TurnCost`` 、 ``CrossingCost`` 和
        ``NodeVicinityCost`` 的值被添加到路线的总成本中，
        并且对所选路径的形状有很大影响。
        ``StartOrientation`` 和 ``EndOrientation`` 属性指定
        路由链接（routed links）的第一段（segment）和最后一段的方向。

#.  锚点（Anchor points）和模版（Patterns）

    -   锚点

        对于每个节点（node），您可以定义连接到该节点时链接（links）
        必须停靠的一个或多个点（points）。这些点由 ``AnchorPoint`` 类的实例表示。
        锚点相对于节点边界矩形（bounding rectangle）的位置由 X 和 Y 属性指定。
        它们的值表示为节点宽度和高度的百分比，以适应移动和调整大小。
        锚点的最终位置由以下简单计算确定：

        ..  code-block :: C#

            return new PointF(
                nodeRect.X + nodeRect.Width * X / 100,
                nodeRect.Y + nodeRect.Height * Y / 100);

        点的位置也可以定义为距节点左上角的固定偏移量，
        让您可以定义不依赖于节点宽度或高度的锚点位置。
        这是通过 ``XUnit`` 和 ``YUnit`` 属性独立控制的 `X` 和 `Y` 坐标。

        您可以控制锚点是接受传入（incomming）链接还是传出（outgoing）链接，
        或者两者都接受。这是由 ``AllowIncoming`` 和 ``AllowOutgoing`` 属性完成的。
        当一个链接被绘制时，它的两端对齐到最近且相应类型（传入或传出）被允许的锚点。
        控制链接是否可以连接到锚点的另一种方法是处理 ``ValidateAnchorPoint`` 事件。

    -   锚点模板（Patterns）

        一个 ``AnchorPattern`` 实例定义了一组要一起使用的锚点。
        创建锚点模板时，将一个 ``AnchorPoint`` 对象数组传递给其构造函数。
        **AnchorPattern** 类公开了几个预定义的模板（pattern）作为静态属性。
        可以将现有模板作为单个实体赋值给节点（nodes）的 ``AnchorPattern`` 属性。
        以下示例创建了一个包含四个锚点的模板：

        ..  code-block :: C#

            apat1 = new AnchorPattern(new AnchorPoint[] {
                new AnchorPoint(50, 0, true, true),
                new AnchorPoint(100, 50, true, true),
                new AnchorPoint(50, 100, true, true),
                new AnchorPoint(0, 50, true, true)});

        这些点位于模板被赋值到的节点的边界矩形边的中间。
        所有四个点都接受传入和传出链接。

    -   锚点模板和表格

        可以为表格的每一行分配一个不同的锚点模板。
        当链接连接到一行时，链接的相应端点与分赋值给该行的最近的 ``AnchorPoint`` 对齐。
        如果一行没有关联的适当类型（传入/传出）的锚点，
        则链接将连接到定义了此类锚点的最近行。
        如果表的任何行都没有关联的适当的锚点模板，
        则链接将连接到所指行左侧或右侧的中间。

    -   锚点和用户交互

        默认情况下，链接仅在创建链接时附加（attached to）到锚点。
        之后，用户可以将链接的端点移动到节点（node）的任何部分。
        为确保即使在用户进行后续修改后链接始终保持附加到锚点，
        请将 ``SnapToAnchor`` 属性设置为 ``CreateOrModify`` 。
        您可以通过处理 ``ValidateAnchorPoint`` 事件来防止用户将特定链接附加到特定锚点。

    -   编程式设置锚点

        您可以通过将链接的 ``OriginAnchor`` 和 ``DestinationAnchor`` 属性设置为
        相应节点（node）的 ``AnchorPattern`` 中点的索引，将链接连接到特定的锚点。
        ``DiagramLink`` 的 ``ReassignAnchorPoints`` 方法
        会自动选择彼此靠近的源（origin）节点和目标（destination）节点的锚点，
        从而使链接在节点之间走更短的路径。
        ``DiagramNode`` 的 ``ReassignAnchorPoints`` 方法
        设置连接到节点的每个链接的锚点，以便链接在可用锚点之间均匀分布。

4.5 撤销重做
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  概述
    
    用户执行的交互操作和更改图表结构的编程命令都记录在历史队列中。
    当操作记录仍在该队列中时，可以撤消或重做操作。
    队列有一个固定的长度——如果它满了，记录一个新的动作会使最旧的一个从队列中删除。
    
    默认情况下，撤销功能是被禁用的。将 ``UndoEnabled`` 属性设置为 **true** 以启用。
    要撤消或重做一个操作，请调用 ``UndoManager`` 的 ``Undo`` 或 ``Redo`` 方法。
    WpfDiagram 组件没有提供用于撤消/重做的键盘快捷键。
    应用程序必须有自己的菜单项和/或键盘加速器来提供必要的用户接口，
    并调用相应的方法来响应 UI 事件。
    
    WpfDiagram 自动保存以下类型的操作，以供稍后的撤销/重做：
    
        -   向 Diagram 中添加一个 Item
        -   从 Diagram 中移除一个 Item
        -   移动或调整 Items 的尺寸
        -   创建一个 Group
        -   销毁一个 Group
        -   展开或折叠 Trees
        -   滚动表格的行
        -   添加或移除表格的行
    
    对属性值的更改不会自动保存在历史记录中。
    如果您的应用程序必须支持对属性更改的撤消/重做，请使用 ``ChangeItemCmd`` 命令。
    **ChangeItemCmd** 允许将多个属性的更改记录为一个可撤销的原子操作。

    在某些情况下，您可能需要创建自定义的操作或命令类型。
    例如，假设您需要对 Item 的 Tag 属性所做的更改或对嵌入在 ControlNode 类型的 Item 
    中的控件的更改实现撤消/重做。但是，WpfDiagram 无法检测到此类更改，因此无法撤消它们。
    这种情况下，为了实现撤消/重做，您必须创建 ``Command`` 的子类并实现
    ``Execute`` 、 ``Undo`` 、 ``Redo`` 方法。
    
#.  动作（Actions）和命令（Commands）

    WpfDiagram 可执行的可撤销交互操作和编程命令由 ``Command`` 子类表示。
    **Command** 类提供了 ``Execute`` 、 ``Undo`` 或 ``Redo`` 操作所需的接口。
    在某些情况下，必须在派生类中实现这些方法，但禁止直接调用它们。
    请使用 ``UndoManager`` 的 **Undo** 或 **Redo** 方法撤消或重做命令。
    使用 **UndoManager** 的方法将调用相应 **Command** 的方法，
    此外还更新命令历史和 Diagram 的状态。
    
    WpfDiagram 提供的以下这些类派生自 **Command** ：
    
    ========================    ================================================
    命令                        描述
    ========================    ================================================
    AddItemCmd                  向 diagram 中添加一个 Item
    RemoveItemCmd               从 diagram 中移除一个 Item
    AddGroupCmd                 创建一个 Group
    RemoveGroupCmd              销毁一个 Group
    GroupAttachCmd              附加（attach）一个 Item 到一个 Group
    GroupDetachCmd              从一个 Group 中分离（detach）一个 Item
    ModifyItemCmd               对一个 Item 进行移动或调整其尺寸
    RedimTableCmd               改变表的行数或列数
    ExpandItemCmd               Expands or collapses a tree of items.
    ScrollTableCmd              滚动表格的行
    ExpandHeaderRowCmd          Expands or collapses tables sections.
    ChangeItemCmd               处理 Item 属性更改的撤消/重做
    CompositeCmd                允许同时撤消和重做多个操作
    ========================    ================================================
    
    大多数这些类的实例都是由 WpfDiagram 隐式创建的，用以响应用户的操作或方法调用。
    您可能只需要显式实例化 **ChangeItemCmd** —— 用于撤消或重做属性更改；
    和 **CompositeCmd** —— 将多个操作表现为单个可撤消的操作。
    
    您的应用程序的数据可能紧密集成在 WpfDiagram 图表中，
    例如通过嵌入在 ControlNode Items 中的 Tag 对象或 .NET 控件。
    在这些情况下，WpfDiagram 无法检测、撤消或重做对数据的更改。
    要实现对这些更改的撤销，必须继承 **Command** 类,
    并实现 **Execute** 、 **Undo** 和 **Redo** 方法。
    要在撤消/重做历史记录中记录您自己的操作，
    请调用 **Diagram** 类的 ``ExecuteCommand`` 方法。
    
#.  Undo Manager

    Undo Manager 充当命令、图表和命令历史记录之间的中介。
    它由 ``UndoManager`` 类表示，
    该类的唯一实例可以通过 ``Diagram`` 的 ``UndoManager`` 属性访问。

    默认情况下，撤消功能是被禁用的 —— 命令被执行，但不会记录在历史中，
    以便以后撤消或重做。要启用撤消功能，请将 ``UndoEnabled`` 设置为 **true** 。
    在执行不希望被用户撤消的操作之前（例如创建特殊的开始/结束节点），您可能需要禁用撤消。
    另一种可能需要禁用撤销的情况是，
    以编程方式创建大量 diagram items —— 比如数百或数千项。
    WpfDiagram 为每个 Item 的创建创建一个撤销记录；
    如果历史记录的 ``Capacity`` 小于创建的 items 的数目，
    则在添加新 items 时，大多数记录将从历史队列中删除。
    这将浪费处理能力和内存来创建不会被使用的记录。

    作为一种替代方法，您可以通过调用 ``StartComposite`` 方法来创建组合记录。
    所有后续的 item 创建操作都保存在这个组合记录中。
    该组合记录以单个记录的形式保存在历史记录中，
    该组合记录允许将其中包含的所有操作作为单个操作进行撤消或重做。
    **StartComposite** 创建并返回一个 ``CompositeCmd`` 的实例，
    该实例在 undo manager 中标记为 active composite。
    当有一个 active composite 时，所有执行的操作都会添加到其中。
    调用 active composite 的 ``Execute`` 方法停止继续向其中添加子命令，
    并将其作为可撤销的原子操作保存在历史记录中。
    
    使用 undo manager 的 ``Undo`` 和 ``Redo`` 方法来撤消或重做操作。
    不要调用 ``Command`` 类的相应方法 —— 它们由 undo manager 在内部调用，
    此外当前历史记录的位置也会更新并重新绘制图表视图。
    
#.  历史记录

    撤消/重做历史记录由一个 ``CommandHistory`` 的实例表示。
    该实例由 ``UndoManager`` 创建，可以通过其 ``History`` 属性访问。

    Undo manager 在执行命令后将它们添加到历史记录中。
    如果历史队列已满，则在添加新命令记录时删除最旧的命令记录。
    使用 **CommandHistory** 的 ``Capacity`` 属性指定队列中可以保留多少操作记录。

    历史记录有一个当前命令指针，指示哪些是下一个要撤消或重做的命令。
    如果命令被撤消，历史队列中的当前指针将往后移动，并允许撤消更旧的操作。
    如果当前指针不在最后一条记录上，则可以再次重做任何较新的命令。
    每次撤消或重做操作时，都会分别触发 ``ActionUndone`` 或 ``ActionRedone`` 事件。

    要查询下一个要撤消或重做的命令，请使用 ``NextUndo`` 和 ``NextRedo`` 只读属性。
    它们返回队列中包含的由当前指针引用的 ``Command`` 实例。
    如果无法进一步撤消或重做，则属性返回 **null** 。
    您可以使用它们向用户指示要撤消/重做的下一个命令是什么。

    .. code-block:: C#

        if (diagram.UndoManager.History.NextUndo == null)
        {
            // Everything has been undone
            miUndo.Enabled = false;
            miUndo.Text = "Undo";
        }
        else
        {
            if (diagram.UndoManager.History.NextUndo is AddItemCmd)
            {
                // The next action to undo is item-creation
                miUndo.Enabled = true;
                miUndo.Text = "Undo Create";
            }
        }

    要禁止用户撤消上一个命令，请通过调用 ``Clear`` 方法清除命令历史记录。
    可以通过处理 ``ActionRecording`` 事件来过滤一些命令，
    以便它们不会被记录在历史记录中。

#.  关于属性更改的撤销重做

    不会自动记录对 Item 属性的更改以供以后撤消。
    要支持对属性更改的撤消，您必须显式创建 ``ChangeItemCmd`` 实例并将其添加到历史队列。

    **ChangeItemCmd** 的构造函数需要一个 item 的引用作为参数，
    并保存 item 的初始状态以供以后通过调用 ``Undo`` 方法来恢复。
    在对 item 的属性进行一次或多次赋值后调用 ``Execute`` 方法。
    **Execute** E记录了后面调用 ``Redo`` 方法是要恢复的 item 的最终状态。
    这允许将对 item 的多个属性的更改保存在单条记录中，
    这些更改可以作为单个操作进行撤消或重做：
    
    .. code-block:: C#

        // Save item state
        ChangeItemCmd propChange = new ChangeItemCmd(diagram.Nodes[0], "Change");

        // Change properties
        ShapeNode shape = (ShapeNode)diagram.Nodes[0];
        shape.Text = "new text";
        shape.Brush = new SolidBrush(Color.Blue);
        shape.Shape = Shape.FromId("Ellipse");

        // Add to history
        propChange.Execute();

    您可能需要将对多个 item 的更改作为一个原子操作。
    为此，请创建一个 ``CompositeCmd`` 的实例，
    并通过 ``AddSubCmd`` 方法将 **ChangeItemCmd** 命令添加到 composite 中：

    .. code-block:: C#

        if (diagram.Selection.Nodes.Count == 0)
            return;
         
        // Make all changes seem like a single operation by
        // putting them in composite Command
        CompositeCmd composite = new CompositeCmd(diagram, "Change selection");
         
        foreach (DiagramNode node in diagram.Selection.Nodes)
        {
            ShapeNode shape = node as ShapeNode;
            if (shape == null)
                continue;
         
            // Save item state
            ChangeItemCmd propChange = new ChangeItemCmd(shape, "Change");
         
            // Change properties
            shape.Text = "new text";
            shape.Brush = new SolidBrush(Color.Blue);
         
            // Add to the composite
            composite.AddSubCmd(propChange);
        }

        // Store final state of all contained commands
        composite.Execute();

#.  组合（composite）命令

    有时您可能更希望将一组操作作为单个原子操作进行撤消和重做。
    WpfDiagram 提供了 ``CompositeCmd`` 类来解决这个问题。
    **CompositeCmd** 对象充当其他 ``Command`` 派生类对象的容器。
    当在组合命令上调用 ``Undo`` 或 ``Redo`` 时，
    它的所有子命令都将分别被撤消或重做。

    要将命令添加到复合命令中，调用 ``AddSubCmd`` 方法。
    调用 ``Execute`` 以执行组合中包含的所有子命令。
    子命令按照其被添加到容器的顺序执行或重做，并以相反的顺序撤消。

    通常 WpfDiagram 会隐式生成 **Command** 对象以响应用户操作或方法调用，
    并自动将它们记录在历史队列中。
    您无法直接访问这些命令，也无法通过 **AddSubCmd** 将它们添加到组合命令中。
    为了在这种情况下创建一个组合命令，
    undo manager 提供了活动组合命令（active composite）的概念。
    活动组合命令是通过调用 ``UndoManager`` 的 ``StartComposite`` 函数创建的。
    在此之后执行的每个操作都成为组合命令的一部分，而不是直接将其添加到命令历史记录中。
    调用当前组合命令的 ``Execute`` 方法完成它并将其保存在历史队列中。
    
    .. code-block:: C#

        // Implicitly created undo records will be saved here
        CompositeCmd composite = diagram.UndoManager.StartComposite("Create group");

        // Call methods that create undo records
        ShapeNode node1 = diagram.Factory.CreateShapeNode(0, 0, 30, 30);
        ShapeNode node2 = diagram.Factory.CreateShapeNode (0, 0, 15, 15);
        Group g = diagram.Factory.CreateGroup(node1);
        g.AttachToCorner(node2, 0);

        // This goes to the active composite too
        ChangeItemCmd change = new ChangeItemCmd(node2, "");
        node2.Locked = true;
        change.Execute();

        // Save the active composite in history
        composite.Execute();

#.  派生 Command 类

    WpfDiagram 组件的 diagram 可能只是应用程序数据模型的一部分，
    应用程序可能已经为其原生数据实现了撤消/重做功能。
    要将 WpfDiagram 的撤消功能集成到应用程序的撤消机制中，
    请使用 ``ActionRecorded`` 事件。
    当该事件被触发时，在事件处理程序中将相应记录的包装器添加到应用程序的历史记录中。
    包装器可以调用 ``UndoManager`` 的 ``Undo`` 和 ``Redo`` 方法。
    在这种情况下，
    请确保 WpfDiagram 的命令历史记录的 ``Capacity`` 至少与您的应用程序的一样大。
    
    一个您不得不派生 Command 类的简单场景是：
    使用复杂对象作为 tags 或在 ControlNode 实例中嵌入控件。
    WpfDiagram 无法自动检测和处理对这些对象或控件进行更改的操作。
    要将此类操作集成到 diagram 的撤消历史记录中，
    您必须创建一个知道如何执行、撤消或重做该操作的 **Command** 实例。

    **Command** 的派生类必须实现 ``Execute`` 、 ``Undo``  和 ``Redo`` 方法。
    您的子类表示的操作必须通过调用 **Diagram** 的 **ExecuteCommand** 方法来执行。
    **ExecuteCommand** 在作为参数传递的命令上调用 ``Execute`` ，
    然后将该命令添加到历史记录中，
    该命令的 **Undo** 和 **Redo** 方法可以在稍后由 undo manager 多次调用。
    通常可以将 **Redo** 实现为对 **Execute** 的调用，
    但是如果 **Execute** 比较耗时，则可以将其结果状态保存在一个实例成员中，
    并通过 **Redo** 进行恢复。

    不要直接调用你的类的 **Undo** 和 **Redo** 方法，只需实现它们，
    它们会在必要时被 **UndoManager** 的 **Undo** 或 **Redo** 方法调用。
    
    下面的示例显示了 **Command** 派生类的简单实现：
    
    .. code-block:: C#

        public class PersonTag
        {
            public string Name;
            public string Address;

            // And so on
            ...
        }

        public class AddressChangeCmd : Command
        {
            public AddressChangeCmd(PersonTag p, string address) : base("Address change")
            {
                this.p = p;
                this.oldAddress = p.Address;
                this.newAddress = address;
            }

            public override void Execute(bool undoEnabled)
            {
                p.Address = newAddress;
            }

            public override void Undo()
            {
                p.Address = oldAddress;
            }

            public override void Redo()
            {
                // Undo manager is enabled if Redo is called
                // so pass true for the undoEnabled argument
                Execute(true);
            }

            private PersonTag p;
            private string oldAddress;
            private string newAddress;
        }

        ...

        // Somewhere in later code
        PersonTag tag = (PersonTag)diagram. ActiveItem.Tag;
        AddressChangeCmd cc = new AddressChangeCmd(tag, "far far away");
        diagram.ExecuteCommand(cc);

4.6 序列化和输出
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  序列化 Diagram

    -   XML 序列化
    
        可以将一个 diagram 保存为 XML 文档。
        调用 ``Diagram`` 类的 ``SaveToXml`` 方法即可。
        要将 diagram 从其 XML 表示中反序列化回来，请调用 ``LoadFromXml`` 方法。

        自定义的 item 类可以通过重写 ``SaveToXml`` 和 ``LoadFromXml`` 方法
        为其附加的属性实现 XML 序列化。
        此外，此类必须通过调用 ``RegisterItemClass`` 指定一个字符串
        以用作该类在 XML 文档中的标识符。
        
        The control raises ``SerializeTag`` and ``DeserializeTag`` to
        enable serialization of complex `Id <https://www.mindfusion.eu/onlinehelp/wpfdiagram/P_MindFusion_Diagramming_Wpf_DiagramItem_Id_0.htm>`_
        and **Tag** objects without overriding the item classes.
        The `PropertyName <https://www.mindfusion.eu/onlinehelp/wpfdiagram/P_MindFusion_Diagramming_Wpf_SerializeTagEventArgs_PropertyName_0.htm>`_
        event argument specifies which property is being serialized.

    -   JSON 序列化

        要将 diagram 序列化为 JSON 字符串，请调用其 ``SaveToJson`` 方法。
        要将 diagram 从其 JSON 表示反序列化回来，调用 ``LoadFromJson`` 方法。
        ``SaveToJsonFile`` 方法将 JSON 字符串序列化为文件;
        ``LoadFromJsonFile`` 方法从文件加载 JSON 字符串。
        
        自定义 item 类可以通过重写 ``SaveToJson`` 和 ``LoadFromJson`` 方法
        为其附加的属性实现 JSON 序列化。
        必须通过调用 ``RegisterItemClass`` 方法并为 *clientClass* 参数
        提供字符串标识符来注册此类以进行序列化。
        
        The control raises `JsonSerializeTag <https://www.mindfusion.eu/onlinehelp/wpfdiagram/E_MindFusion_Diagramming_Wpf_DiagramBase_JsonSerializeTag.htm>`_
        and `JsonDeserializeTag <https://www.mindfusion.eu/onlinehelp/wpfdiagram/E_MindFusion_Diagramming_Wpf_DiagramBase_JsonDeserializeTag.htm>`_
        to enable serialization of complex **Id** and **Tag** objects
        without overriding the item classes.
        The `PropertyName <https://www.mindfusion.eu/onlinehelp/wpfdiagram/P_MindFusion_Diagramming_Wpf_JsonSerializeTagEventArgs_PropertyName_0.htm>`_
        event argument specifies which property is being serialized.

        JSON 序列化由 ``MindFusion.Json.Wpf`` 命名空间中的类在内部处理。
        ``JsonValue`` 类表示一个属性值。
        属性名称和值存储在 ``JsonObject`` 字典类的实例中。
        ``JsonContext`` 类处理 ``Diagram`` 属性的序列化。
        ``Serialize`` 方法是 ``Serializer`` 类的 ``Serialize`` 方法的的包装器。
        它接受一个 **JsonObject** 并将其序列化为一个字符串。
        ``Parse`` 方法是 ``Parser`` 类的 ``ReadJsonObject`` 方法的包装器。
        它接受一个 JSON 格式的字符串并返回一个带有解析后数据的 **JsonObject** 。

#.  导出 Diagram

    -   导出图片

        您可以使用 ``CreateImage`` 方法创建一个代表当前图表的静态图像。
        该方法返回 **BitmapSource** 类的一个实例。
        以下示例展示了在点击菜单项后使用 **SaveFileDialog** 控件选择导出位置
        并输入图像文件的名称，然后导出图表到 Png 图像文件：
        
        .. code-block:: C#

            private void OnExportImage(object sender, RoutedEventArgs e)
            {
                // Configure save file dialog box
                var dlg = new SaveFileDialog
                {
                    FileName = "Diagram",
                    DefaultExt = ".png",
                    Filter = "Diagram Files (.png)|*.png"
                };

                // Show save file dialog box
                var result = dlg.ShowDialog();

                // Process save file dialog box results
                if (result == true)
                {
                    var encoder = new PngBitmapEncoder();
                    encoder.Frames.Add(BitmapFrame.Create(diagram.CreateImage(100)));

                    using (var stream = new FileStream(dlg.FileName, FileMode.Create))
                        encoder.Save(stream);
                }
            }

        ``MindFusion.Diagramming.Wpf.Export`` 命名空间包含
        用于导出为 Dxf、Pdf、Svg 和 Visio 格式的类。

    -   导出 PDF

        将 *MindFusion.Diagramming.Wpf.PdfExport.dll* 和 *MindFusion.Pdf.dll*
        程序集的引用添加到项目中。
        创建一个 ``PdfExporter`` 实例并调用其 ``Export`` 方法
        ``Margins`` 属性指定文档中所有页面的页边距。
        如果需要设置页面大小和方向，请使用 ``PageSize`` 和 ``PageOrientation`` 属性。
        ``AutoScale`` 属性允许缩放图表以适应一个或多个 PDF 页面。
        如果应该在 PDF 中显示不可见的 items，请使用 ``InvisibleItems`` 属性。
        以下示例显示了如何响应按下按钮事件并使用 **SaveFileDialog** 控件
        将图表导出到 Pdf 文件，其中选择了位置并输入了 Pdf 文件的名称：
        
        .. code-block:: C#

            private void OnExportPdf(object sender, RoutedEventArgs e)
            {
                // Configure save file dialog box
                var dlg = new SaveFileDialog
                {
                    FileName = "Diagram",
                    DefaultExt = ".pdf",
                    Filter = "Diagram Files (.pdf)|*.pdf"
                };

                // Show save file dialog box
                var result = dlg.ShowDialog();

                // Process save file dialog box results
                if (result == true)
                {
                    PdfExporter pdfex = new PdfExporter();
                    pdfex.PageSize = MindFusion.Pdf.PageSize.DiagramSize;
                    pdfex.PageOrientation = MindFusion.Pdf.PageOrientation.Portrait;
                    pdfex.Margins = new Thickness(48, 48, 48, 48);

                    pdfex.Export(diagram, dlg.FileName);
                }
            }

    -   导出 SVG

        将 *MindFusion.Diagramming.Wpf.SvgExport.dll* 和 *MindFusion.Svg.dll*
        程序集的引用添加到您的项目中。
        创建一个 ``SvgExporter`` 实例并调用它的 ``Export`` 方法，
        传递一个 ``Diagram`` 对象和 .svg 文件的完整路径作为参数。
        要将 diagram items 显示的图像导出到外部（external）文件，
        请启用 ``ExternalImages`` 属性。

        .. code-block:: C#
        
            var svgExp = new SvgExporter();
            svgExp.ExternalImages = false;
            svgExp.Export(diagram, dlg.FileName);

    -   导出 WMF 图片

        向您的项目添加对 *MindFusion.Diagramming.Wpf.WmfExport.dll* 程序集的引用。
        创建 ``WmfExporter`` 实例并调用其 ``Export`` 方法，
        传递一个 ``Diagram`` 对象和 .wmf 文件的完整路径作为参数。

    -   导出 Visio

        为了支持 Visio 格式的导出，
        请将 *MindFusion.Diagramming.Wpf.VisioExport.dll* 的引用添加到您的项目中。
        创建 ``VisioExporter`` 类的实例，并调用其 ``Export`` 方法，
        传递一个 ``Diagram`` 对象和文件的完整路径（\*.vdx）作为参数。
        Visio 页面的 dimension 和 item size 的度量单位
        被设置为图表的 ``MeasureUnit`` 属性。
        
        ``ShapeNode`` 对象被映射到与其最接近的 Visio 对象；
        ``TableNode`` 对象导出为 Visio shapes。
        ``DiagramLink`` 实例导出为类似样式的 Visio 连接（connectors）。
        此外，diagram items 的大部分属性，
        如文本、文本格式、填充和线条颜色和样式都保留了下来。
        
        导出器对象（exporter object）要求应用程序目录中存在 VisioExport.vxt 文件。
        此文件包含该组件用于生成 Visio 文档的 XML 模板数据。

        要从 WpfDiagram 组（groups）创建 Visio 组（groups），
        请启用 ``CreateVisioGroups`` 属性。
        如果应将包含图像的形状节点（shape node）导出为
        包含形状、图片和文本对象的 Visio 组，
        请使用默认设置为 true 的 ``ExportImagesAsGroups`` 属性。
        ``ExportInvisibleItems`` 允许导出不可见的 items 。
        如果 ``TableNode`` 对象应作为包含矩形形状 Visio 组导出，
        请启用 ``ExportTablesAsGroups`` 属性。

        下面的示例演示了如何将图表导出到 Visio 文件：

        .. code-block:: C#

            private void OnExportVisio(object sender, RoutedEventArgs e)
            {
                var dlg = new SaveFileDialog();
                dlg.Filter = "Visio files (*.vdx)|*.vdx|All files|*.*||";

                if (dlg.ShowDialog(this) == true)
                {
                    var visioExporter = new VisioExporter();
                    visioExporter.Export(diagram, dlg.FileName);
                }
            }

    -   导出 Excel

        *MindFusion.Diagramming.Wpf.ExcelExport.dll* 程序集中的 ``ExcelExporter``
        类将图表导出到 Excel Open XML 格式 (XLSX) 文件。
        图表导出为Excel AutoShapes图纸
        （Diagrams are exported as Excel AutoShapes drawings）。
        采用 ``DiagramDocument`` 参数的 ``Export`` 函数重载
        为文档中的每个 ``DiagramPage`` 创建一个工作表。
        ``Export(Diagram)`` 函数重载创建单个 Excel 工作表。

    -   导出 DXF

        向您的项目添加对 *MindFusion.Diagramming.Wpf.DxfExport.dll* 的引用。
        创建一个 ``DxfExporter`` 实例并调用它的 ``Export`` 方法，
        指定一个 ``Diagram`` 对象和一个文件路径作为参数。
        光栅（raster）图像可以通过引用外部（external）图像文件在 DXF 中使用。
        要导出图表元素中显示的图像，请启用 ``ExportImages`` 属性。
        如果您的目标应用程序支持 multiple-line text DXF entity - MTEX​​T，
        请使用 ``ExportTextAsMultiline`` 属性。
        下面的示例展示了如何创建 **DxfExporter** 实例,
        并通过传递 **Diagram** 对象和在 **SaveFileDialog** 中输入的文件名作为参数
        执行 **Export** 方法来导出图表。
        
        .. code-block:: C#

            var dxfExporter = new MindFusion.Diagramming.Wpf.Export.DxfExporter();
            dxfExporter.Export(diagram, dlg.FileName);

#.  打印和打印预览

    您可以使用标准 WPF 打印工具打印图表。
    ``DocumentPaginator`` 属性允许您打印多页的图表。
    以下示例显示了如何使用它：
    
    .. code-block:: C#

        PrintDialog pd = new PrintDialog();

        if (pd.ShowDialog())
            pd.PrintDocument(diagram.DocumentPaginator, "my diagram");

    作为一种快捷方式，WpfDiagram 提供了 ``Print`` 和 ``PrintPreview`` 方法，
    它们在内部使用 **DocumentPaginator** 来打印图表内容，或预览打印时的效果。

4.7 外观
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  样式和主题

    -   样式
    -   主题
    -   主题编辑器

#.  节点的效果（Effects）

    -   Aero Effect
    -   Glass Effect
    -   示例

#.  修改 Diagram 的外观

    您可以自定义大部分 WpfDiagram 的可视化效果。

    -    背景
    
        通过设置 ``BackBrush`` 属性，可以使用纯色、渐变、纹理或颜色图案（patterns）
        填充 diagram 的背景区域。
        背景主题也可以是由 ``BackgroundImage`` 属性设置的图像。
        图像可以是由 ``.NET System.Drawing.Image`` 支持的任何格式。
        景图像可以居中、对齐到控件或文档的角落、平铺或拉伸以覆盖绘图区域 ——
        取决于 ``BackgroundImageAlign`` 属性值。
        通过设置 ``ExteriorBrush`` 属性，
        可以使用一个独特的笔刷来绘制 ``Bounds`` 外的区域。
    
    -    阴影

        与 ActiveX 和 Windows Froms 版本的控件不同，WpfDiagram 不提供内置阴影渲染。
        相反，它依赖 WPF **Effect** 类来渲染阴影和其他视觉效果，例如模糊。
        要启用任何这些效果，
        请将 item 的 ``Effect`` 属性设置为 **Effect** 派生类的实例。

    -    选中效果

        可以通过 ``ActiveItemHandlesStyle`` 复合属性设置围绕 active item 绘制的
        选中手柄的样式。
        多选中的 items 使用 ``SelectedItemHandlesStyle`` 属性指定的样式
        绘制其选中手柄。
        当 ``ShowDisabledHandles`` 启用时（参考 ``EnabledHandles`` 属性），
        被禁用的操作手柄使用 ``DisabledHandlesStyle`` 指定的样式进行绘制。
        ``Selection`` 类的 ``Style`` 属性控制多选的显示方式。

    -    鼠标光标

        可以设置不同的鼠标光标图标来向用户提供上下文相关的反馈，
        提示他们是否可以创建/修改 diagram item 。

    -    网格设置

        如果 ``ShowGrid`` 设置为 **true** ，则会绘制对齐网格。
        ``GridPen`` 属性指定用于绘制网格点和线的笔。
        使用以下属性指定在不同情况下显示的光标：
        
            -   ``PointerCursor``
            -   ``MoveCursor``
            -   ``DisallowCursor``
            -   ``DrawLinkCursor``
            -   ``AllowLinkCursor``
            -   ``DisallowLinkCursor``
            -   ``HorizontalResizeCursor``
            -   ``VerticalResizeCursor``
            -   ``DiagonalResizeCursor``
            -   ``CounterDiagonalResizeCursor``

        WpfDiagram 在平移 diagram view 时显示 ``PanCursor`` 属性指定的光标样式。
        如果您需要设置不依赖于当前上下文的光标，请设置 ``OverrideCursor`` 属性。

#.  自定义 Item 的外观

    对于 WpfDiagram 每个 item，可以按照以下段落中的描述设置不同的视觉样式和属性。

    -   设计样式（Styling）

        可以使用 WPF 样式系统为 diagram items 设置样式。
        从 **FrameworkElement** 继承的 **Style** 属性
        可以设置为 **System.Windows.Style** 类的一个实例，
        该类设置 ``Brush`` 、 ``Stroke*`` 、 ``Text*`` 和 ``Font*`` 依赖项属性。
        如果没有显式地给某个 item 设置其样式属性，
        那么它可以使用应用程序或窗口资源字典中为某种类型定义的全局样式。
        例如，如果将此样式定义为窗口资源，则 ``ShapeNodes`` 将具有粗红色边框：

        .. code-block:: C#

            <Style TargetType="diag:ShapeNode" >
                <Setter Property="Stroke" Value="Red"/>
                <Setter Property="StrokeThickness" Value="5"/>
                <Setter Property="Brush" Value="LightYellow" />
            </Style>

        由于样式设置器（setters）的优先级低于本地属性值，
        因此这种样式仅适用于通过无参数构造函数创建的 item 。
        从文件加载或通过 ``DiagramItem(Diagram)`` 构造函数创建的 items 的属性
        可能具有本地值，可以通过 ``ClearStyleableProperties`` 方法清除这些值
        以使用全局样式。

    -   Pen 的宽度和样式

        节点（nodes）的边框和链接（links）的线条是使用笔绘制的，
        笔的颜色、宽度和样式可以通过 ``Stroke`` 、 ``StrokeThickness``
        和 ``StrokeDashStyle`` 属性进行自定义。

    -   Diagram 元素的颜色

        链接段（link segments）的颜色可以使用 ``Stroke`` 属性设置。
        ``Brush`` 属性指定如何填充封闭的箭头形状。
        节点（nodes）具有类似的用于自定义颜色的属性：
        节点边框的颜色通过 ``Stroke`` 属性指定；
        节点的内部的填充通过 ``Brush`` 属性指定。

    -   文本

        Diagram items 可以有关联的文本，显示在它们的内部或之上。
        文本可以通过基础 ``DiagramItem`` 类的 ``Text`` 属性进行设置。
        ``TextBrush`` 指定用于绘制 diagram item 文本的笔刷。

        形状节点（shape nodes）的文本可以在一个多边形轮廓内进行布局和渲染；
        这取决于 ``PolygonalTextLayout`` 属性的值。
        要使节点（node）足够大以显示其文本而不进行剪裁，
        请调用 ``ResizeToFitText`` 方法。
        链接（links）的文本水平绘制在中间段（middle segment）上方，
        或按照 ``TextStyle`` 属性指定的方式旋转。

        所有 diagram items 都公开 ``FontFamily`` 、 ``FontStyle``
        和 ``FontSize`` 属性，指定 diagram items 的文本的字体名称、样式和大小。
        文本通过 ``TextAlignment`` 、 ``TextTrimming``
        和 ``TextWrapping`` 等属性进行格式化。

    -   图像

        形状节点（Shape nodes）和表格可以在其中显示图像。
        使用 ``ShapeNode.Image`` 和 ``TableNode.Image`` 属性
        将图像加载到相应的 items 中。
        通过调用 ``ResizeToFitImage`` 方法，可以使一个节点与它所包含的图像大小相同。

        图像可以以不同的方式定位：
        它们可以平铺、拉伸或对齐到包含它们的容器节点的中心或边。
        使用 ``ShapeNode.ImageAlign`` 和 ``TableNode.ImageAlign`` 指定
        图像在相应节点内的放置方式。
        节点（node）内显示的图像根据该节点的形状（shape）进行剪裁。

        表格的单元格也可以设置 ``Image`` 和 ``ImageAlign`` 属性。
        例如，它可能用于显示数据库表的关键字段的图标。

    -   效果（Effects）

        WPF着色器效果，例如阴影和模糊，
        可以通过 **Effect** 属性应用到 diagram items 。
        **Effect** 依赖属性是在 ``DiagramItem`` 的基类 **UIElement** 中定义的。
        
        .. note ::

            ``Diagram`` 类的 ``DefaultEffect`` 属性允许指定
            必须赋值给所有新 item 的 effect。

    -   DiagramLink-specific Properties

        链接段（link segments）的形状和方向由 ``Shape`` 属性指定；
        段（segments）的数量由 ``SegmentCount`` 属性指定。
        使用 ``HeadShape`` 和 ``HeadShapeSize`` 属性
        设置箭头形状（arrowhead shape）的样式和大小。
        在链接（links）原点（origin）显示的形状（shapes）
        由 ``BaseShape`` 和 ``BaseShapeSize`` 定义。
        形状可以显示在段的中间，有助于跟踪长链接的路径。
        它们由 ``IntermediateShape`` 和 ``IntermediateShapeSize`` 属性定义。
        箭头形状的线条是使用 ``HeadPen`` 笔绘制的。
        可以为链接调用自定义绘制代码，如在 ``CustomDraw`` 中设置的那样。

    -   Rounded Links

        由直线段组成的链接（links），即 ``Shape`` 属性
        设置为折线（ ``Polyline`` ）或级联（ **Cascading** ）的链接，
        可以使用圆弧连接相邻的线段（segments）。

        要启用该功能，请将 ``RoundedLinks`` 设置为 **true** 。
        使用 ``RoundedLinksRadius`` 设置连接弧的半径。

    -   Link Crossings

        根据 ``LinkCrossings`` 所指定的值，链接（links）与其路径（paths）相交的交点
        可以渲染为弧线或断开。链接的 Z-order 属性决定哪些链接跳过其他链接，
        或者哪些链接看起来被其他链接切断。
        如果 **LinkCrossings** 设置为 ``Arcs`` ，
        则 **ZIndex** 较高的链接会跳过 **ZIndex** 较低的链接。
        如果设置为 **Cut** ，较低 **ZIndex** 的链接将被较高 **ZIndex** 的链接切断。
        可以通过设置 ``CrossingRadius`` 属性设置圆弧和中断的半径。

    -   ShapeNode-specific Properties

        节点的形状是使用其 ``Shape`` 属性定义的。
        形状模板（Shape templates）可以应用于形状节点（shape nodes），
        其方向为通过 ``ShapeOrientation`` 属性指定为 0/90/180/270 度。
        可能会为节点调用您自己的绘图代码，具体取决于 ``CustomDraw`` 属性的值。
        形状节点可以标记为 ``Transparent`` ，仅呈现其文本或图像。

    -   TableNode-specific Properties

        表格的轮廓可以是矩形或圆角矩形，由 ``Shape`` 属性指定。
        表格单元格的边框可以以不同的方式呈现，具体取决于 ``CellFrameStyle`` 属性的值。
        表格标题区域使用 ``CaptionBackBrush`` 笔刷绘制。
        设置 ``CustomDraw`` 和 ``CellCustomDraw`` 属性，
        可以对表格及其单元格执行自定义绘制。

#.  用户自定义的节点形状和自定义绘制

    WpfDiagram items 的外观可以通过如下所述的几种方式进行自定义。

    -   形状模板（Shape Templates）

        ``Shape`` 类提供了定义复杂节点形状（可以由直线、圆弧和贝塞尔曲线组成）的方法。
        一个形状模板必须总是包含一个轮廓，用于命中测试，剪切和寻找与其他 items 是否交叉。
        形状还可以包含装饰元素和文本区域的定义
        （Optionally shapes can contain decoration elements and text region definitions）。
        装饰是不参与命中测试和剪辑的视觉元素。
        文本区域是节点形状的一部分，用于布局和渲染节点的文本
        （Text regions are the parts of shapes in which node's
        text is laid out and rendered）。

        WpfDiagram 提供了一组 87 个预定义好的形状模板，
        可以通过 **Shape** 类的 ``Shapes`` 集合属性或 ``FromId`` 方法访问这些模板。
        每个预定义的形状（shape）都有一个分配给它的字符串标识符。
        使用 **FromId** 方法查找具有指定 id 的形状。
        形状模板可以赋值给形状节点的 ``Shape`` 成员。

    -   Dynamic Shapes

        通过 ``ElementTemplate`` 对象定义的形状（shapes）
        能够与节点（nodes）的大小成比例缩放。
        如果形状元素的缩放比例不一致，请调用 ``Shape(formula)`` 构造函数
        使用类似 Visio 的格式（formulas）来定义形状，这种格式考虑了节点的当前宽度和高度。
        ``Shape`` 类的另一个构造函数采用 ``CreatePathDelegate`` 类型的参数，
        该参数可用于通过 .NET 函数定义形状。

        可以通过将 ``ShapeControlPoint`` 对象
        添加到形状（shape）的 ``ControlPoints`` 集合来参数化公式形状（formula shape）。
        控制点（control point）位置作为参数传递给形状（shape）脚本，
        它们可以用于修改节点（node）的外观。
        例如，以下代码定义了一个圆角矩形形状，用户可以通过控制点修改其圆角半径。

        .. code-block :: C#

            // a rounded rectangle shape, with an arc at each corner
            string roundRect = @"
                r = Min(Width / 2, radius.X);
                MoveTo(r, 0);
                LineTo(Width - r, 0);
                ArcTo(Width, r, false, true, r, r);
                LineTo(Width, Height - r);
                ArcTo(Width - r, Height, false, true, r, r);
                LineTo(r, Height);
                ArcTo(0, Height - r, false, true, r, r);
                LineTo(0, r);
                ArcTo(r, 0, false, true, r, r);
                ";

            var myRect = new Shape(roundRect, "MyRect");

            // add a control point for the 'radius' parameter
            myRect.ControlPoints.Add(new ShapeControlPoint(
                "radius", 15, 5, 45, UnitType.Fixed, 0, 0, 0, UnitType.Fixed));

    -   Shape Libraries

        WpfDiagram 套件中包含的 ShapeDesigner 工具可让您绘制自定义形状（shapes）
        并将其存储在形状库中。
        可以使用 ``ShapeLibrary`` 类将库文件加载到您的应用程序中。
        从形状库加载的定义会自动添加到 ``Shapes`` 集合中，
        并且可以通过 ``FromId`` 方法访问，就像预定义形状一样。

    -   Custom Painting

        另一种自定义 item 外观的方法是通过在每次绘制 item 时引发事件来实现，
        让您可以选择将自己的绘制代码附加到 WpfDiagram 的渲染引擎。
        使用 item 关联的 **CustomDraw** 属性在您的应用程序中启用该功能。

        WpfDiagram 为自定义绘图提供了多个选项。
        如果您选择 ``Additional`` 绘制模式，
        您的绘图代码将在执行标准的 item 绘图代码并呈现图像之后，但在呈现文本之前执行。
        此外，您收到的用于绘制的 **DrawingContext** 对象
        已经应用了一个与节点形状相对应的裁剪区域。
        如果使用 ``Full`` 绘图模式，
        则不会执行标准的 WpfDiagram 绘图代码 —— 只执行您的代码。
        ``ShadowOnly`` 模式对 item 执行的标准绘制，但将阴影的绘制留给您的代码。

        将您自己的绘图代码放在 ``DrawNode`` 、 ``DrawCell`` 和 ``DrawLink`` 事件
        的处理程序中。这些事件为每个需要重新绘制的自定义绘制（custom-drawn）的 item 触发。

    -   Combining Custom Shapes with Custom Drawing

        最后，您可以同时结合使用用户自定义的形状（shapes）和 ``Additional`` 绘制模式。

    -   Shape control points

#.  文本属性和格式化

    ``ShapeNode`` 节点可以在其轮廓（outlines）内显示文本。
    文本位置和对齐方式取决于 ``TextAlignment`` 、 ``TextPadding`` 、
    ``TextWrapping`` 和 ``TextVerticalAlignment`` 属性的值。
    文本是用 ``TextBrush`` 中设置的颜色绘制的。
    可以通过 ``PolygonalTextLayout`` 和 ``EnableStyledText`` 启用
    更有用的布局和格式化相关的属性。

    -   Layout Text in Arbitrary Shapes

        ``ShapeNode`` 的实例可以具有各种形状（shapes），
        由其 ``Shape`` 和 ``ShapeOrientation`` 属性指定。
        要在非矩形形状（non-rectangular shapes）内布局文本，
        请启用 ``PolygonalTextLayout`` 。
        如果启用该功能，WpfDiagram 将使用一种格式算法（formatting algorithm），
        使文本的每一行正好符合多边形形状内的线条宽度（fits exactly each line
        of text within the width of a line inside a polygonal shape）。
        如果形状节点具有弯曲的轮廓（curved outlines），
        则格式化算法会将它们近似为折线（poly-lines）。

    -   Text Wrapping

        如果没有足够的可用空间来容纳整行文本，
        WpfDiagram 会在文本到达节点边缘时将文本换行到新行。
        您可以通过将 ``TextTrimming`` 设置为 **Word** 来
        指定文本应仅在单词边界处（word boundaries）换行。
        默认情况下，如果没有足够的空间容纳整个单词，则将单词分成多个部分。

        如果您更喜欢使用自己的换行符（line-breaks），
        可以通过将 ``TextWrapping`` 设置为 **None** 来禁用自动文本换行。
        如果自动换行被禁用并且没有足够的空间来容纳整行，文本将在节点边界处被剪裁（clipped）。

    -   Text in Tables

        ``TableNode`` 可以在其标题区域和每个单元格内显示文本。
        ``Caption`` 中的文本是用 ``TextBrush`` 绘制的，
        并按照 ``CaptionFormat`` 的指定进行对齐。
        单元格中的文本使用它们自己的 ``TextBrush`` 绘制，
        并根据它们自己的 ``TextFormat`` 对齐。
        ``EnableStyledText`` 属性可以启用更多有用的格式化相关的属性。

    -   Styled Text

        形状节点（shape nodes）的 ``ShapeNode.EnableStyledText`` 属性和
        表格的 ``TableNode.EnableStyledText`` 属性
        启用或禁用样式化文本呈现（styled text rendering）。
        样式化文本可以对其包含的字符应用各种属性。
        这些属性是通过在原始文本（raw text）中嵌入类似 HTML 的格式标签（tags）来指定的。
        仅当启用了 ``PolygonalTextLayout`` 时，形状节点才能显示样式化文本。
        使用 ``DrawStyledText`` 方法
        在自定义绘制项目（custom-drawn items）中显示样式化文本。

        下表列出了当前支持的样式标签：

        ====================================    ====================================
        标签（Tag）                              描述
        ====================================    ====================================
        \<i\>text\<\/i\>                        显示斜体文本。
        \<b\>text\<\/b\>                        显示粗体文本。
        \<u\>text\<\/u\>                        显示下划线文本。
        \<sub\>text\<\/sub\>                    显示下标。
        \<sup\>text\<\/sup\>                    显示上标。
        \<color=\#RRGGBB\>text\<\/color\>       更改文本的颜色。
        ====================================    ====================================

    -   Links' Text

        ``DiagramLink`` 的文本使用 ``TextBrush`` 中指定的颜色绘制，
        并按 ``TextStyle`` 中的设置定位。

    -   Fonts

        所有 items 都提供 ``FontFamily`` 、 ``FontSize`` 、 ``FontStyle`` 、
        ``FontWeight`` 和 ``FontStretch`` 属性，
        这些属性允许获取或设置用于呈现 item 文本的字体属性。

4.8 Initial Values of Item Properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    由用户或以编程方式创建的每个新 item 都使用某种默认属性值进行初始化。

    如果使用 new 运算符创建 items 并将它们添加到 diagram 的 ``Nodes`` 或
    ``Links`` 集合中，您可以通过将一个 ``Diagram`` 实例的引用传递给相应的构造函数
    或将另一个 item 作为参数调用复制构造函数来初始化这些 items 。
    在前一种情况下，item 的属性是从 **Diagram** 定义的默认属性值初始化的。
    在后一种情况下，属性是从原型 item 中复制的。

    当用户绘制新 items 时，这些 items 是从 **Diagram** 属性初始化的，
    但您可以通过处理 ``InitializeNode`` 和 ``InitializeLink`` 事件来更改默认值。

    通过 diagram 对象的 ``Factory`` 对象创建的 items
    总是从 ***Diagram** 中定义的默认属性值初始化。

    下面列出了 item 属性以及初始化它们的相应常量或 **Diagram** 属性：

    ====================    ============================
    DiagramItem 属性         初始化为
    ====================    ============================
    ``Brush``               ``ShapeBrush``
    
                            ``TableBrush``

                            ``LinkBrush``
    Font                    Font
    ``Locked``              **False**
    Pen                     ``ShapePen``
    
                            ``TablePen``

                            ``LinkPen``
    ``Selected``            ``SelectAfterCreate``
    Tag                     **null**
    ToolTip                 (empty string)
    ``Visible``             **true**
    ====================    ============================

    ====================    ============================
    ShapeNode 属性           初始化为
    ====================    ============================
    ``CustomDraw``          ``ShapeCustomDraw``
    ``EnabledHandles``      ``AdjustmentHandles.All``
    ``Expandable``          ``NodesExpandable``
    ``HandlesStyle``        ``ShapeHandlesStyle``
    ``Image``               **null**
    ``ImageAlign``          ``ImageAlign.Fit``
    Text                    ``ShapeText``
    TextColor               TextColor
    TextFormat              TextFormat
    ``Transparent``         **False**
    ====================    ============================

    ====================    ============================
    ContainerNode 属性       初始化为
    ====================    ============================
    ``AutoShrink``          **false**
    ``Caption``             ``ContainerCaption``
    ``CaptionBrush``        **Black**
    CaptionFormat           ``TextFormat``
    ``CaptionHeight``       ``ContainerCaptionHeight``
    ``Foldable``            ``ContainersFoldable``
    ``Folded``              **false**
    ``HighlightPen``        ``ContainerHighlightPen``
    ``Margin``              ``ContainerMargin``
    ``MinimumSize``         ``ContainerMinimumSize``
    ====================    ============================

    ====================    ============================
    TableNode 属性           初始化为
    ====================    ============================
    ``Caption``             ``TableCaption``
    ``CaptionColor``        Color.FromArgb(0, 0, 0)
    CaptionFormat           Centered horizontal
                            and vertical alignment
    ``CellCustomDraw``      ``CellCustomDraw``
    ``CellFrameStyle``      ``CellFrameStyle``
    ``ColumnWidth``         ``TableColumnWidth``
    ``CustomDraw``          ``TableCustomDraw``
    ``HandlesStyle``        ``TableHandlesStyle``
    ``Image``               **null**
    ``ImageAlign``          ``ImageAlign.Fit``
    ``ConnectionStyle``     ``TableConnectionStyle``
    ``RowHeight``           ``TableRowHeight``
    ``Scrollable``          ``TablesScrollable``
    ``Shape``               ``TableShape``
    TextColor               ``TextColor``
    ====================    ============================

    ============================    ============================
    DiagramLink 属性                 初始化为
    ============================    ============================
    ``BaseShape``                   ``LinkBaseShape``
    ``BaseShapeSize``               ``LinkBaseShapeSize``
    ``HeadShape``                   ``LinkHeadShape``
    ``HeadShapeSize``               ``LinkHeadShapeSize``
    ``AutoRoute``                   ``RouteLinks``
    ``CascadeOrientation``          ``LinkCascadeOrientation``
    ``CustomDraw``                  ``LinkCustomDraw``
    ``Dynamic``                     ``DynamicLinks``
    ``HeadPen``                     ``LinkPen``
    ``IntermediateShape``           ``LinkIntermediateShape``
    ``IntermediateShapeSize``       ``LinkIntermediateShapeSize``
    ``RetainForm``                  ``LinksRetainForm``
    ``SegmentCount``                ``LinkSegments``
    ``Shape``                       ``LinkShape``
    Text                            ``LinkText``
    TextColor                       ``TextColor``
    ``TextStyle``                   ``LinkTextStyle``
    ============================    ============================

4.9 杂项
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  Associate Custom Data with Items

    通过设置图表元素（diagarm items）的 **Tag** 和 ``Id`` 属性，
    您可以将任何数据类型的自定义值与图表元素关联起来。
    如果关联数据是值类型或可序列化类型
    （标记为 **[Serializable]** 并实现 **ISerializable** 接口），
    则在保存或加载 diagram 时，它会与 diagram items 一起保存和加载。
    ``FindNode`` 、 ``FindLink`` 、 ``FindNodeById`` 和 ``FindLinkById`` 方法
    让您可以找到与特定值关联的图表元素。

#.  Inspecting Items Geometry

    -   DiagramLink 的 ``Intersects`` 方法
        可让您测试链接（links）是否与其他链接或节点（nodes）相交。
    -   DiagramLink 类的 ``Length`` 方法返回链接的总长度。
    -   ``ContainsPoint`` 方法让您检查一个 item 是否包含指定的点。

#.  Fluent API

    ``MindFusion.Diagramming.Wpf.Fluent`` 和
    ``MindFusion.Diagramming.Wpf.Layout.Fluent`` 命名空间中的扩展方法
    允许您使用流畅的编程风格初始化对象：
    
    .. code-block:: C#

        using MindFusion.Diagramming.Wpf.Fluent;
        using MindFusion.Diagramming.Wpf.Layout.Fluent;
        //...

        diagram.Factory
            .CreateShapeNode(20, 20, 60, 40)
                .Brush(Colors.LightGray)
                .Font("Arial", 12)
                .EnableStyledText(true)
                .Text("Task <i>1</i>")
                .ToolTip("This is the task")
                .TextRotationAngle(15);

        new TreeLayout()
           .LevelDistance(20)
           .NodeDistance(20)
           .LinkStyle(TreeLayoutLinkType.Cascading3)
           .Arrange(diagram);

5. 教程
--------------------------------------------------------------------------------

5.1 加载数据
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

5.2 加载层次结构类型的数据
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

5.3 创建一个自定义节点类型
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

5.4 自定义节点的集成
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

开发笔记
================================================================================