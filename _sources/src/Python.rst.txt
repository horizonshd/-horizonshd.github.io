================================================================================
Python
================================================================================

.. :

    = - ` : ' " ~ ^ _ * + # < >

    ====================
    --------------------
    ~~~~~~~~~~~~~~~~~~~~
    ********************
    ++++++++++++++++++++
    ####################
    ::::::::::::::::::::
    >>>>>>>>>>>>>>>>>>>>
    <<<<<<<<<<<<<<<<<<<<

基础教程
================================================================================

环境搭建
--------------------------------------------------------------------------------

Python 环境变量
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

关于 Python 有一下几个重要的环境变量：

====================    ========================================================
变量名                   描述
====================    ========================================================
PYTHONPATH              Python 搜索路径，默认我们 import 的模块都会从 PYTHONPATH 里
                        面寻找。
PYTHONSTARTUP           Python 启动后，先寻找 PYTHONSTARTUP 环境变量，然后执行此变
                        量指定的文件中的代码。
PYTHONCASEOK            加入 PYTHONCASEOK 的环境变量, 就会使python 导入模块的时候不
                        区分大小写。
PYTHONHOME              另一种模块搜索路径。它通常内嵌于的 PYTHONSTARTUP 或
                        PYTHONPATH 目录中，使得两个模块库更容易切换。
====================    ========================================================


运行方式
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  交互式解释器

    可以通过命令行窗口进入 Python，并在交互式解释器中开始编写 Python 代码。

    可以在 Unix、DOS 或任何其他提供了命令行或者 shell 的系统进行 Python 编码工作。
    
    ::
    
        $ python # Unix/Linux

        或者

        C:>python # Windows/DOS

    以下为部分可能用到的 Python 命令行参数：
    
        -d      在解析时显示调试信息。
        -O      生成优化代码（.pyo 文件）。
        -S      启动时不引入查找 Python 路径的文件。
        -V      输出 Python 版本号。
        -c cmd  执行 Python 脚本，并将运行结果作为 cmd 字符串。
    
#.  命令行脚本

    在你的应用程序中通过引入解释器可以在命令行中执行 Python 脚本，如下所示： ::

        $ python script.py # Unix/Linux

        或者

        C:>python script.py # Windows/DOS

    .. note ::

        在执行脚本时，请检查脚本是否有可执行权限。

#.  集成开发环境

略。

中文编码
--------------------------------------------------------------------------------

Python 2.X 版本中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以
在读取中文时会报错。

解决方法为只要在文件开头加入 ``# -*- coding: UTF-8 -*-`` 或者 ``# coding=utf-8`` 。

Python 3.X 源码文件默认使用 utf-8 编码，所以可以正常解析中文，无需指定 UTF-8 编码。

如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8，否则会出现错误。


基础语法
--------------------------------------------------------------------------------

第一个 Python 程序
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

交互式编程
********************************************************************************

交互式编程不需要创建脚本文件，是通过 Python 解释器的交互模式进来编写代码。

::

	Microsoft Windows [版本 10.0.22000.160]
	(c) Microsoft Corporation。保留所有权利。

	C:\Users\horizonshd>python
	Python 3.9.6 (tags/v3.9.6:db3ff76, Jun 28 2021, 15:26:21) [MSC v.1929 64 bit (AMD64)] on win32
	Type "help", "copyright", "credits" or "license" for more information.
	>>> print("Hello,Python!")
	Hello,Python!
	>>>

脚本式编程
********************************************************************************

通过脚本参数调用解释器开始执行脚本，直到脚本执行完毕。当脚本执行完成后，解释器不再有效。

让我们写一个简单的 Python 脚本程序。所有 Python 文件将以 .py 为扩展名。将以下的源代码
拷贝至 test.py 文件中。

.. code-block:: python
	:caption: test.py
	
	print ("Hello, Python!")

输出结果： ::

	Hello, Python!

标识符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

标识符由字母、数字、下划线组成，但不能以数字开头。

标识符是区分大小写的。

以下划线开头的标识符是有特殊意义的：

	-	以单下划线开头 ``_foo`` 的代表不能直接访问的类属性，需通过类提供的接口进行访问，
		不能用 ``from xxx import *`` 而导入。
	-	以双下划线开头的 ``__foo`` 代表类的私有成员。
	-	以双下划线开头和结尾的 ``__foo__`` 代表 Python 里特殊方法专用的标识，如
		``__init__()`` 代表类的构造函数。

可以同一行显示多条语句，方法是用分号 ``;`` 分开，如： ::

	>>> print ('hello');print ('runoob');
	hello
	runoob

保留字符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

下面的列表显示了在 Python 中的保留字。这些保留字不能用作常数或变数，或任何其他标识符名
称。

所有 Python 的关键字只包含小写字母。

========    ========    ========    ========    ========    ========
and         exec        not         assert      finally     or
break       for         pass        class       from        print
continue    global      raise       def         if          return
del         import      try         elif        in          while
else        is          with        except      lambda      yield
========    ========    ========    ========    ========    ========

行和缩进
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python 的代码块不使用大括号 ``{}`` 来控制类，函数以及其他逻辑判断。python 最具特色的就
是用缩进来写模块。

缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。

以下实例缩进为四个空格:

    .. code-block:: python

        if True:
            print ("True")
        else:
            print ("False")
        
以下代码将会执行错误：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
        # 文件名：test.py

        if True:
            print ("Answer")
            print ("True")
        else:
            print ("Answer")
            # 没有严格缩进，在执行时会报错
          print ("False")

    执行以上代码，会出现如下错误提醒： ::

          File "test.py", line 11
            print ("False")
                          ^
        IndentationError: unindent does not match any outer indentation level
  
多行语句
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python 语句中一般以新行作为语句的结束符。

但是我们可以使用斜杠（ ``\`` ）将一行的语句分为多行显示，如下所示：

    .. code-block:: python

        total = item_one + \
                item_two + \
                item_three

语句中包含 ``[]`` , ``{}`` 或 ``()`` 就不需要使用多行连接符。如下实例：

    .. code-block:: python

        days = ['Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday']

引号
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python 可以使用引号( ``'`` )、双引号( ``"`` )、三引号( ``'''`` 或 ``"""`` ) 来表示
字符串，引号的开始与结束必须是相同类型的。

其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被
当做注释。

    .. code-block:: python

        word = 'word'
        sentence = "这是一个句子。"
        paragraph = """这是一个段落。
        包含了多个语句"""

注释
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

python中单行注释采用 ``#`` 开头：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
        # 文件名：test.py

        # 第一个注释
        print ("Hello, Python!")  # 第二个注释
        
python 中多行注释使用三个单引号( ``'''`` )或三个双引号( ``"""`` )：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
        # 文件名：test.py


        '''
        这是多行注释，使用单引号。
        这是多行注释，使用单引号。
        这是多行注释，使用单引号。
        '''

        """
        这是多行注释，使用双引号。
        这是多行注释，使用双引号。
        这是多行注释，使用双引号。
        """

空行
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分
隔，以突出函数入口的开始。

空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运
行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。

记住：空行也是程序代码的一部分。

等待用户输入
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

下面的程序执行后就会等待用户输入，按回车键后就会退出：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-

        raw_input("按下 enter 键退出，其他任意键显示...\n")

以上代码中 ，``\n`` 实现换行。一旦用户按下 enter(回车) 键退出，其它键显示。

一行多条语句
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python 可以在同一行中使用多条语句，语句之间使用分号( ``;`` )分割，以下是一个简单的实例：

    .. code-block:: python
    
        #!/usr/bin/python

        import sys; x = 'runoob'; sys.stdout.write(x + '\n')

执行以上代码，输入结果为： ::

    $ python test.py
    runoob

print 输出
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 ``,`` ： 

    .. code-block:: python
    
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-

        x="a"
        y="b"
        # 换行输出
        print x
        print y

        print '---------'
        # 不换行输出
        print x,
        print y,

        # 不换行输出
        print x,y

以上实例执行结果为： ::

    a
    b
    ---------
    a b a b

多个语句构成代码组
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

缩进相同的一组语句构成一个代码块，我们称之代码组。

像 ``if`` 、``while`` 、``def`` 和 ``class`` 这样的复合语句，首行以关键字开始，以冒
号( ``:`` )结束，该行之后的一行或多行代码构成代码组。

我们将首行及后面的代码组称为一个子句(clause)。

如下实例：

    .. code-block:: python
    
        if expression : 
           suite 
        elif expression :  
           suite  
        else :  
           suite 




命令行参数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

很多程序可以执行一些操作来查看一些基本信息，Python 可以使用 ``-h`` 参数查看各参数帮助
信息： ::

    $ python -h 
    usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ... 
    Options and arguments (and corresponding environment variables): 
    -c cmd : program passed in as string (terminates option list) 
    -d     : debug output from parser (also PYTHONDEBUG=x) 
    -E     : ignore environment variables (such as PYTHONPATH) 
    -h     : print this help message and exit 
     
    [ etc. ] 

变量类型
--------------------------------------------------------------------------------

变量中的值存储在内存中，这就意味着在创建变量时会在内存中开辟一个空间。

基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。

因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。

变量赋值
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python 中的变量赋值不需要类型声明。

每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。

每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。

等号 ``=`` 用来给变量赋值，左边是一个变量名，右边是存储在变量中的值。例如：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        counter = 100 # 赋值整型变量
        miles = 1000.0 # 浮点型
        name = "John" # 字符串
         
        print counter
        print miles
        print name

以上实例中，100，1000.0 和 "John" 分别赋值给counter，miles，name变量。
执行以上程序会输出如下结果： 

    ::

        100
        1000.0
        John

Python允许你同时为多个变量赋值。例如：

    .. code-block:: python
    
        a = b = c = 1

以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。

您也可以为多个对象指定多个变量。例如：

    .. code-block:: python
    
        a, b, c = 1, 2, "john"

以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 "john" 分配给变量 c。

标准数据类型
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在内存中存储的数据可以有多种类型。
Python 定义了一些标准类型，用于存储各种类型的数据。
Python有五个标准的数据类型：

    -   :ref:`src/Python:Numbers（数字）`
    -   :ref:`src/Python:String（字符串）`
    -   :ref:`src/Python:List（列表）`
    -   :ref:`src/Python:Tuple（元组）`
    -   :ref:`src/Python:Dictionary（字典）`


Numbers（数字）
********************************************************************************

数字数据类型用于存储数值。

他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。
当你指定一个值时，Number 对象就会被创建：

    .. code-block:: python

        var1 = 1
        var2 = 10

您也可以使用 del 语句删除一些对象的引用。
del 语句的语法是：

    .. code-block:: python

        del var1[,var2[,var3[....,varN]]]

例如：

    .. code-block:: python
        
        del var
        del var_a, var_b

Python 支持四种不同的数字类型：

    -   int（有符号整型）
    -   long（长整型，也可以代表八进制和十六进制）
    -   float（浮点型）
    -   complex（复数）

一些数值类型的实例：

========    ========================    ================    ================
int         long                        float               complex
========    ========================    ================    ================
10          51924361L                   0.0                 3.14j
100         -0x19323L                   15.20               45.j
-786        0122L                       -21.9               9.322e-36j
080         0xDEFABCECBDAECBFBAEl       32.3e+18            .876j
-0490       535633629843L               -90.                -.6545+0J
-0x260      -052318172735L              -32.54e100          3e+26J
0x69        -4721885298529L             70.2E-12            4.53e-7j
========    ========================    ================    ================

-   长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。
    Python使用 L 来显示长整型。
-   Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,
    或者 complex(a,b) 表示，复数的实部 a 和虚部 b 都是浮点型。

.. note ::

    long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动
    转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。

String（字符串）
********************************************************************************

字符串是编程语言中表示文本的数据类型。
python 的字串列表有 2 种取值顺序:

    -   从左到右索引默认 0 开始的，最大范围是字符串长度少 1
    -   从右到左索引默认 -1 开始的，最大范围是字符串开头
    
如果你要实现从字符串中获取一段子字符串的话，可以使用 ``[头下标:尾下标]`` 来截取相应的字
符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。
获取的子字符串包含头下标的字符，但不包含尾下标的字符。比如： ::

    >>> s = 'abcdef'
    >>> s[1:5]
    'bcde'
    
*当使用以冒号分隔的字符串，python 返回一个新的对象。*

加号（ ``+`` ）是字符串连接运算符，星号（ ``*`` ）是重复操作。如下实例：

    .. code-block:: python
    
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        str = 'Hello World!'
         
        print str           # 输出完整字符串
        print str[0]        # 输出字符串中的第一个字符
        print str[2:5]      # 输出字符串中第三个至第六个之间的字符串
        print str[2:]       # 输出从第三个字符开始的字符串
        print str * 2       # 输出字符串两次
        print str + "TEST"  # 输出连接的字符串
        
    以上实例输出结果： ::

        Hello World!
        H
        llo
        llo World!
        Hello World!Hello World!
        Hello World!TEST

Python 列表截取可以接收第三个参数，参数作用是截取的步长。

List（列表）
********************************************************************************

List（列表）是 Python 中使用最频繁的数据类型。
列表可以完成大多数集合类的数据结构实现。
它支持字符、数字、字符串甚至可以包含列表（即嵌套）。
列表用 ``[ ]`` 标识，是 python 最通用的复合数据类型。

列表中值的切割也可以用到变量 ``[头下标:尾下标]`` ，就可以截取相应的列表，从左到右索引默
认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。

加号 ``+`` 是列表连接运算符，星号 ``*`` 是重复操作。如下实例：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
        tinylist = [123, 'john']
         
        print list               # 输出完整列表
        print list[0]            # 输出列表的第一个元素
        print list[1:3]          # 输出第二个至第三个元素 
        print list[2:]           # 输出从第三个开始至列表末尾的所有元素
        print tinylist * 2       # 输出列表两次
        print list + tinylist    # 打印组合的列表

    以上实例输出结果： ::
    
        ['runoob', 786, 2.23, 'john', 70.2]
        runoob
        [786, 2.23]
        [2.23, 'john', 70.2]
        [123, 'john', 123, 'john']
        ['runoob', 786, 2.23, 'john', 70.2, 123, 'john']

Tuple（元组）
********************************************************************************

元组是另一个数据类型，类似于 List（列表）。
元组用 ``()`` 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。

    .. code-block:: python
    
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )
        tinytuple = (123, 'john')
         
        print tuple               # 输出完整元组
        print tuple[0]            # 输出元组的第一个元素
        print tuple[1:3]          # 输出第二个至第四个（不包含）的元素 
        print tuple[2:]           # 输出从第三个开始至列表末尾的所有元素
        print tinytuple * 2       # 输出元组两次
        print tuple + tinytuple   # 打印组合的元组
        
    以上实例输出结果： ::

        ('runoob', 786, 2.23, 'john', 70.2)
        runoob
        (786, 2.23)
        (2.23, 'john', 70.2)
        (123, 'john', 123, 'john')
        ('runoob', 786, 2.23, 'john', 70.2, 123, 'john')

以下元组是无效的，因为元组是不允许更新的。而列表是允许更新的：

    .. code-block:: python
    
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )
        list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
        tuple[2] = 1000    # 元组中是非法应用
        list[2] = 1000     # 列表中是合法应用

Dictionary（字典）
********************************************************************************

字典（dictionary）是除列表以外 python 之中最灵活的内置数据结构类型。
列表是有序的对象集合，字典是无序的对象集合。

两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。

字典用 ``{ }`` 标识。字典由索引（key）和它对应的值（value）组成。

.. code-block:: python

    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
     
    dict = {}
    dict['one'] = "This is one"
    dict[2] = "This is two"
     
    tinydict = {'name': 'runoob','code':6734, 'dept': 'sales'}
     
     
    print dict['one']          # 输出键为'one' 的值
    print dict[2]              # 输出键为 2 的值
    print tinydict             # 输出完整的字典
    print tinydict.keys()      # 输出所有键
    print tinydict.values()    # 输出所有值

输出结果为： ::

    This is one
    This is two
    {'dept': 'sales', 'code': 6734, 'name': 'runoob'}
    ['dept', 'code', 'name']
    ['sales', 6734, 'runoob']

数据类型转换
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即
可。以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。

========================    ====================================================
函数                         描述
========================    ====================================================
int(x [,base])              将 x 转换为一个整数
long(x [,base])             将 x 转换为一个长整数
float(x)                    将 x 转换到一个浮点数
chr(x)                      将一个整数转换为一个字符
unichr(x)                   将一个整数转换为 Unicode 字符
str(x)                      将对象 x 转换为字符串
complex(real [,imag])       创建一个复数
repr(x)                     将对象 x 转换为表达式字符串
eval(str)                   用来计算在字符串中的有效 Python 表达式,并返回一个对象
list(s)                     将序列 s 转换为一个列表
tuple(s)                    将序列 s 转换为一个元组
dict(d)                     创建一个字典。d 必须是一个序列 (key,value)元组。
set(s)                      转换为可变集合
frozenset(s)                转换为不可变集合
ord(x)                      将一个字符转换为它的整数值
hex(x)                      将一个整数转换为一个十六进制字符串
oct(x)                      将一个整数转换为一个八进制字符串
========================    ====================================================


运算符
--------------------------------------------------------------------------------

Python 语言支持以下类型的运算符:

    -   :ref:`src/Python:算术运算符`
    -   :ref:`src/Python:比较（关系）运算符`
    -   :ref:`src/Python:赋值运算符`
    -   :ref:`src/Python:逻辑运算符`
    -   :ref:`src/Python:位运算符`
    -   :ref:`src/Python:成员运算符`
    -   :ref:`src/Python:身份运算符`

算术运算符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

以下假设变量： a=10，b=20：

========    ========================================    ================================
运算符       描述                                        实例
========    ========================================    ================================
\+           加 - 两个对象相加                            a + b = 30
\-           减 - 得到负数或是一个数减去另一个数            a - b = -10
\*           乘 - 两个数相乘或是返回一个被重复若            a \* b = 200
             干次的字符串
/            除 - x 除以 y                                b / a = 2
%            取模 - 返回除法的余数                         b % a = 0
\*\*         幂 - 返回 x 的 y 次幂                        a\*\*b = 100000000000000000000
//           取整除 - 返回商的整数部分（向下取整）          9//2 = 4; -9//2 = -5
========    ========================================    ================================

.. note ::

    Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数
    即可。 ::
    
        >>> 1/2
        0
        >>> 1.0/2
        0.5
        >>> 1/float(2)
        0.5
    

比较（关系）运算符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

以下假设变量 a=10 ，b=20：

========    ========================================    ========================
运算符       描述                                        实例
========    ========================================    ========================
\=\=        等于 - 比较对象是否相等                       (a == b) 返回 False
!\=         不等于 - 比较两个对象是否不相等                (a != b) 返回 True
<>          不等于 - 比较两个对象是否不相等                (a <> b) 返回 True
            *python3 已废弃*
>           大于 - 返回 x 是否大于 y                      (a > b) 返回 False
<           小于 - 返回 x 是否小于 y                      (a < b) 返回 True
>\=         大于等于 - 返回 x 是否大于等于 y               (a >= b) 返回 False
<\=         小于等于 - 返回 x 是否小于等于 y               (a <= b) 返回 True
========    ========================================    ========================

.. note ::

    所有比较运算符返回 1 表示真，返回 0 表示假。这分别与特殊的变量 True 和 False 等价。

赋值运算符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

========    ======================================== 
运算符       描述 
========    ======================================== 
\=          c = a + b 将 a + b 的运算结果赋值为 c
+\=         c += a 等效于 c = c + a
-\=         c -= a 等效于 c = c - a
\*\=        c \*= a 等效于 c = c \* a
/\=         c /= a 等效于 c = c / a
%\=         c %= a 等效于 c = c % a
\*\*\=      c \*\*= a 等效于 c = c \*\* a
//\=        c //= a 等效于 c = c // a
========    ======================================== 


逻辑运算符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

以下假设变量 a=10, b=20:

========    ================    ========================================    ============================
运算符       逻辑表达式           描述                                        实例
========    ================    ========================================    ============================
and         x and y             布尔与 -                                       (a and b) 返回 20
                                如果 x 为 False，x and y 返回 False；
                                否则它返回 y 的计算值。
or          x or y              布尔或 -                                       (a or b) 返回 10
                                如果 x 是非 0，它返回 x 的计算值；
                                否则它返回 y 的计算值。
not         not x               布尔非 -                                       not(a and b) 返回 False
                                如果 x 为 True，返回 False；
                                如果 x 为 False，它返回 True。
========    ================    ========================================    ============================

位运算符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

以下假设变量 a=60 ，b=13，二进制格式如下： ::

    a = 0011 1100

    b = 0000 1101

    -----------------

    a&b = 0000 1100

    a|b = 0011 1101

    a^b = 0011 0001

    ~a  = 1100 0011

========    ========================================    ========================
运算符       描述                                        实例
========    ========================================    ========================
&           按位与运算符：参与运算的两个值,如果两个         (a & b) = 12 ，
            相应位都为1,则该位的结果为 1，否则为 0          二进制：0000 1100
|           按位或运算符：只要对应的二个二进位有一          (a | b) = 61 ，
            个为 1 时，结果位就为 1                       二进制：0011 1101
\^          按位异或运算符：当两对应的二进位相异时，         (a \^ b) = 49 ，
            结果为 1                                      二进制：0011 0001
\~          按位取反运算符：对数据的每个二进制位取          (\~a) = \-61 ，
            反,即把 1 变为 0，把 0 变为 1。                二进制：1100 0011，
            \~x 类似于 -x-1                               有符号二进制数的补码形式
\<\<        左移动运算符：运算数的各二进位全部左移           a \<\< 2 = 240 ，
            若干位，由 \<\< 右边的数字指定了移动的            二进制：1111 0000
            位数，高位丢弃，低位补 0
\>\>        右移动运算符：把 \>\> 左边的运算数的各二        a \>\> 2 = 15 ，
            进位全部右移若干位，\>\> 右边的数字指定         二进制：0000 1111
            了移动的位数
========    ========================================    ========================


成员运算符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

除了以上的一些运算符之外，Python 还支持成员运算符，测试实例中包含了一系列的成员，
包括字符串，列表或元组。

========    ====================================================================
运算符       描述                                        
========    ====================================================================
in          如果在指定的序列中找到值返回 True，否则返回 False。
not in      如果在指定的序列中没有找到值返回 True，否则返回 False。
========    ====================================================================

.. code-block:: python

    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
     
    a = 10
    b = 20
    list = [1, 2, 3, 4, 5 ];
     
    if ( a in list ):
       print "1 - 变量 a 在给定的列表中 list 中"
    else:
       print "1 - 变量 a 不在给定的列表中 list 中"
     
    if ( b not in list ):
       print "2 - 变量 b 不在给定的列表中 list 中"
    else:
       print "2 - 变量 b 在给定的列表中 list 中"
     
    # 修改变量 a 的值
    a = 2
    if ( a in list ):
       print "3 - 变量 a 在给定的列表中 list 中"
    else:
       print "3 - 变量 a 不在给定的列表中 list 中"
       
以上实例输出结果： ::

    1 - 变量 a 不在给定的列表中 list 中
    2 - 变量 b 不在给定的列表中 list 中
    3 - 变量 a 在给定的列表中 list 中

身份运算符
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

身份运算符用于比较两个对象的存储单元。

========    ========================================    ================================================================================================
运算符       描述                                        实例
========    ========================================    ================================================================================================
is          判断两个标识符是不是引用自一个对象             x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False
is not      判断两个标识符是不是引用自不同对象             x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。
========    ========================================    ================================================================================================

**注:** ``id()`` 函数用于获取对象内存地址。

.. code-block:: python

    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
     
    a = 20
    b = 20
     
    if ( a is b ):
       print "1 - a 和 b 有相同的标识"
    else:
       print "1 - a 和 b 没有相同的标识"
     
    if ( a is not b ):
       print "2 - a 和 b 没有相同的标识"
    else:
       print "2 - a 和 b 有相同的标识"
     
    # 修改变量 b 的值
    b = 30
    if ( a is b ):
       print "3 - a 和 b 有相同的标识"
    else:
       print "3 - a 和 b 没有相同的标识"
     
    if ( a is not b ):
       print "4 - a 和 b 没有相同的标识"
    else:
       print "4 - a 和 b 有相同的标识"

以上实例输出结果： ::

    1 - a 和 b 有相同的标识
    2 - a 和 b 有相同的标识
    3 - a 和 b 没有相同的标识
    4 - a 和 b 没有相同的标识

.. warning::

    is 与 == 区别：
    
    is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。
    
    >>> a = [1, 2, 3]
    >>> b = a
    >>> b is a 
    True
    >>> b == a
    True
    >>> b = a[:]
    >>> b is a
    False
    >>> b == a
    True

运算符优先级
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

暂略。

条件语句
--------------------------------------------------------------------------------

Python 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。

Python 程序语言指定 **任何非 0 和 非空（null）值为 True，0 或者 null 为 False** 。

Python 编程中 if 语句用于控制程序的执行，基本形式为： ::

    if 判断条件：
        执行语句……
    else：
        执行语句……
        
判断条件为多个值时，可以使用以下形式： ::

    if 判断条件1:
        执行语句1……
    elif 判断条件2:
        执行语句2……
    elif 判断条件3:
        执行语句3……
    else:
        执行语句4……

由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现。
如果需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；
使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。

if 简单语句组
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

你也可以在同一行的位置上使用 if 条件判断语句，如下实例：

    .. code-block:: python
        :emphasize-lines: 6
        
        #!/usr/bin/python 
        # -*- coding: UTF-8 -*-
         
        var = 100 
         
        if ( var  == 100 ) : print "变量 var 的值为100" 
         
        print "Good bye!"
        
    以上代码执行输出结果如下： ::

        变量 var 的值为100
        Good bye!

循环语句
--------------------------------------------------------------------------------

本章节将向大家介绍 Python 的循环语句，程序在一般情况下是按顺序执行的。
编程语言提供了各种控制结构，允许更复杂的执行路径。
循环语句允许我们执行一个语句或语句组多次。

Python 提供了 for 循环和 while 循环（在 Python 中没有 do..while 循环）:

================    ============================================================
循环类型             描述
================    ============================================================
while 循环           在给定的判断条件为 true 时执行循环体，否则退出循环体。
for 循环             重复执行语句
嵌套循环              可以在 while 循环体中嵌套 for 循环
================    ============================================================

while 循环
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重
复处理的相同任务。其基本形式为： ::

    while 判断条件(condition)：
        执行语句(statements)……

.. code-block:: python

    #!/usr/bin/python
     
    count = 0
    while (count < 9):
       print 'The count is:', count
       count = count + 1
     
    print "Good bye!"

while 循环中使用 else 语句
********************************************************************************

在 python 中，while … else 在循环条件为 false 时执行 else 语句块：

    .. code-block:: python

        #!/usr/bin/python
         
        count = 0
        while count < 5:
           print count, " is  less than 5"
           count = count + 1
        else:
           print count, " is not less than 5"

    以上实例输出结果为： ::
    
        0 is less than 5
        1 is less than 5
        2 is less than 5
        3 is less than 5
        4 is less than 5
        5 is not less than 5

while 简单语句组
********************************************************************************

类似 if 语句的语法，如果你的 while 循环体中只有一条语句，你可以将该语句与while写在同一
行中， 如下所示：

    .. code-block:: python

        #!/usr/bin/python
         
        flag = 1
         
        while (flag): print 'Given flag is really true!'
         
        print "Good bye!"
        
for 循环
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python for 循环可以遍历任何序列的项目，如一个列表或者一个字符串。语法格式如下： ::

    for iterating_var in sequence:
       statements(s)

.. code-block:: python
    
    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
     
    for letter in 'Python':     # 第一个实例
       print("当前字母: %s" % letter)
     
    fruits = ['banana', 'apple',  'mango']
    for fruit in fruits:        # 第二个实例
       print ('当前水果: %s'% fruit)
     
    print ("Good bye!")

以上实例输出结果: ::

    当前字母: P
    当前字母: y
    当前字母: t
    当前字母: h
    当前字母: o
    当前字母: n
    当前水果: banana
    当前水果: apple
    当前水果: mango
    Good bye!

通过序列索引迭代
********************************************************************************

另外一种执行循环的遍历方式是通过索引，如下实例：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        fruits = ['banana', 'apple',  'mango']
        for index in range(len(fruits)):
           print ('当前水果 : %s' % fruits[index])
         
        print ("Good bye!")
        
    以上实例输出结果： ::
    
        当前水果 : banana
        当前水果 : apple
        当前水果 : mango
        Good bye!

以上实例我们使用了内置函数 ``len()`` 和 ``range()`` 。
函数 ``len()`` 返回列表的长度，即元素的个数。 
``range()`` 返回一个序列的数。

for 循环中使用 else 语句
********************************************************************************

在 python 中，for … else 表示这样的意思: 
for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完
（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。

    .. code-block:: python
    
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        for num in range(10,20):  # 迭代 10 到 20 之间的数字
           for i in range(2,num): # 根据因子迭代
              if num%i == 0:      # 确定第一个因子
                 j=num/i          # 计算第二个因子
                 print ('%d 等于 %d * %d' % (num,i,j))
                 break            # 跳出当前循环
           else:                  # 循环的 else 部分
              print ('%d 是一个质数' % num)

    以上实例输出结果： ::
    
        10 等于 2 * 5
        11 是一个质数
        12 等于 2 * 6
        13 是一个质数
        14 等于 2 * 7
        15 等于 3 * 5
        16 等于 2 * 8
        17 是一个质数
        18 等于 2 * 9
        19 是一个质数

嵌套循环
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python 语言允许在一个循环体里面嵌入另一个循环。

Python for 循环嵌套语法： ::

    for iterating_var in sequence:
       for iterating_var in sequence:
          statements(s)
       statements(s)

Python while 循环嵌套语法： ::

    while expression:
       while expression:
          statement(s)
       statement(s)

你可以在循环体内嵌入其他的循环体，如在 while 循环中可以嵌入 for 循环；
反之，你可以在 for 循环中嵌入 while 循环。

以下实例使用了嵌套循环输出2~100之间的素数：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        i = 2
        while(i < 100):
           j = 2
           while(j <= (i/j)):
              if not(i%j): break
              j = j + 1
           if (j > i/j) : print i, " 是素数"
           i = i + 1
         
        print "Good bye!"

    以上实例输出结果: ::
    
        2 是素数
        3 是素数
        5 是素数
        7 是素数
        11 是素数
        13 是素数
        17 是素数
        19 是素数
        23 是素数
        29 是素数
        31 是素数
        37 是素数
        41 是素数
        43 是素数
        47 是素数
        53 是素数
        59 是素数
        61 是素数
        67 是素数
        71 是素数
        73 是素数
        79 是素数
        83 是素数
        89 是素数
        97 是素数
        Good bye!

循环控制语句
--------------------------------------------------------------------------------

循环控制语句可以更改语句执行的顺序。Python 支持以下循环控制语句：

================    ============================================================
控制语句             描述
================    ============================================================
break 语句           语句块执行过程中终止循环，并且跳出整个循环。
continue 语句        在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。
pass 语句            pass是空语句，是为了保持程序结构的完整性。
================    ============================================================

函数
--------------------------------------------------------------------------------

函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。

函数能提高应用的模块性，和代码的重复利用率。
你已经知道Python提供了许多内建函数，比如print()。
但你也可以自己创建函数，这被叫做用户自定义函数。

自定义函数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

你可以定义一个由自己想要功能的函数，以下是简单的规则：

    -   函数代码块以 ``def`` 关键词开头，后接函数标识符名称和圆括号 ``()`` 。
    -   任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。
    -   函数的第一行语句可以选择性地使用文档字符串——用于存放函数说明。
    -   函数内容以冒号起始，并且缩进。
    -   ``return [表达式]`` 结束函数，选择性地返回一个值给调用方。
        不带表达式的 return 相当于返回 None。

语法 ::

    def functionname( parameters ):
       "函数_文档字符串"
       function_suite
       return [expression]

默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。

以下为一个简单的Python函数，它将一个字符串作为传入参数，再打印到标准显示设备上：

    .. code-block:: python
    
        def printme( str ):
           "打印传入的字符串到标准显示设备上"
           print str
           return

匿名函数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

python 使用 lambda 来创建匿名函数。

    -   lambda 只是一个表达式，函数体比 ``def`` 简单很多。
    -   llambda 的主体是一个表达式，而不是一个代码块。
        仅仅能在 lambda 表达式中封装有限的逻辑进去。
    -   lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。
    -   虽然 lambda 函数看起来只能写一行，却不等同于C或C++的内联函数，
        后者的目的是调用小函数时不占用栈内存从而增加运行效率。

语法 ::

    lambda [arg1 [,arg2,.....argn]]:expression

如下实例：

    .. code-block:: python
    
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        # 可写函数说明
        sum = lambda arg1, arg2: arg1 + arg2
         
        # 调用sum函数
        print "相加后的值为 : ", sum( 10, 20 )
        print "相加后的值为 : ", sum( 20, 20 )

    以上实例输出结果： ::

        相加后的值为 :  30
        相加后的值为 :  40

函数调用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。
这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 提示符执行。

如下实例调用了 printme（）函数：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        # 定义函数
        def printme( str ):
           "打印任何传入的字符串"
           print str
           return
         
        # 调用函数
        printme("我要调用用户自定义函数!")
        printme("再次调用同一函数")

    以上实例输出结果： ::

        我要调用用户自定义函数!
        再次调用同一函数

参数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

以下是调用函数时可使用的正式参数类型：

    -   :ref:`src/Python:必备参数`
    -   :ref:`src/Python:关键字参数`
    -   :ref:`src/Python:默认参数`
    -   :ref:`src/Python:不定长参数`

必备参数
********************************************************************************

必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。

调用printme()函数，你必须传入一个参数，不然会出现语法错误：

    .. code-block:: python
        :emphasize-lines: 5,11

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        #可写函数说明
        def printme( str ):
           "打印任何传入的字符串"
           print str
           return
         
        #调用printme函数
        printme()
        
    上实例输出结果： ::

        Traceback (most recent call last):
          File "test.py", line 11, in <module>
            printme()
        TypeError: printme() takes exactly 1 argument (0 given)

关键字参数
********************************************************************************

关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。

使用关键字参数允许函数调用时参数的顺序与声明时不一致，
因为 Python 解释器能够用参数名匹配参数值。

以下实例在函数 printme() 调用时使用参数名：

    .. code-block:: python
        :emphasize-lines: 5,11
        
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        #可写函数说明
        def printme( str ):
           "打印任何传入的字符串"
           print str
           return
         
        #调用printme函数
        printme( str = "My string")

    以上实例输出结果： ::

        My string

下例能将关键字参数顺序不重要展示得更清楚：

    .. code-block:: python
        :emphasize-lines: 5,12
        
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        #可写函数说明
        def printinfo( name, age ):
           "打印任何传入的字符串"
           print "Name: ", name
           print "Age ", age
           return
         
        #调用printinfo函数
        printinfo( age=50, name="miki" )

    以上实例输出结果： ::

        Name:  miki
        Age  50

默认参数
********************************************************************************

调用函数时，默认参数的值如果没有传入，则被认为是默认值。
下例中如果 age 没有被传入，则会打印默认的 age ：

    .. code-block:: python
        :emphasize-lines: 5,11,12
        
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        #可写函数说明
        def printinfo( name, age = 35 ):
           "打印任何传入的字符串"
           print "Name: ", name
           print "Age ", age
           return
         
        #调用printinfo函数
        printinfo( age=50, name="miki" )
        printinfo( name="miki" )

    以上实例输出结果： ::

        Name:  miki
        Age  50
        Name:  miki
        Age  35


不定长参数
********************************************************************************

你可能需要一个函数能处理比当初声明时更多的参数。
这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下： ::

    def functionname([formal_args,] *var_args_tuple ):
       "函数_文档字符串"
       function_suite
       return [expression]

加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：

    .. code-block:: python
        :emphasize-lines: 5,14,15

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        # 可写函数说明
        def printinfo( arg1, *vartuple ):
           "打印任何传入的参数"
           print "输出: "
           print arg1
           for var in vartuple:
              print var
           return
         
        # 调用printinfo 函数
        printinfo( 10 )
        printinfo( 70, 60, 50 )

    以上实例输出结果： ::

        输出:
        10
        输出:
        70
        60
        50

参数传递
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在 python 中，对象才有类型，变量是没有类型的： 

    .. code-block:: python

        a=[1,2,3]
        a="Runoob"

    以上代码中， ``[1,2,3]`` 是 List 类型，``"Runoob"`` 是 String 类型，
    而变量 ``a`` 是没有类型，它仅仅是一个对象的引用（一个指针），
    可以是 List 类型对象，也可以指向 String 类型对象。

可更改（mutable）与不可更改（immutable）对象
********************************************************************************

在 python 中， strings、tuples 和 numbers 是不可更改的对象，
而 list 和 dict 等则是可以修改的对象。

-   **不可变类型：**

        变量赋值 a=5 后，再赋值 a=10。这里实际是新生成一个 int 值对象 10，
        再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a 。

-   **可变类型：**

        变量赋值 la=[1,2,3,4] 后，再赋值 la[2]=5 。这里则是将作为 list 类型的 la 的
        第三个元素值更改，la 本身没有动，只是其内部的一部分值被修改了。

python 函数的参数传递：

    -   **不可变类型：**

            类似 c++ 的值传递，如 整数、字符串、元组。
            如 fun（a），传递的只是 a 的值，没有影响 a 对象本身。
            比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。

    -   **可变类型：**

            类似 c++ 的引用传递，如 列表，字典。
            如 fun（la），则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响。

.. note ::

    python 中一切都是对象，严格意义我们不能说值传递还是引用传递，
    我们应该说传不可变对象和传可变对象。

传不可变对象实例
********************************************************************************

.. code-block:: python
    
    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
     
    def ChangeInt( a ):
        a = 10
     
    b = 2
    ChangeInt(b)
    print b # 结果是 2

实例中有 int 对象 2，指向它的变量是 ``b`` ，在传递给 ``ChangeInt`` 函数时，
按传值的方式复制了变量 ``b`` ， ``a`` 和 ``b`` 都指向了同一个 Int 对象，在 a=10 时，
则新生成一个 int 值对象 ``10``，并让 ``a`` 指向它。

传可变对象实例
********************************************************************************

.. code-block:: python

    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
     
    # 可写函数说明
    def changeme( mylist ):
       "修改传入的列表"
       mylist.append([1,2,3,4])
       print "函数内取值: ", mylist
       return
     
    # 调用changeme函数
    mylist = [10,20,30]
    changeme( mylist )
    print "函数外取值: ", mylist

实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下： ::

    函数内取值:  [10, 20, 30, [1, 2, 3, 4]]
    函数外取值:  [10, 20, 30, [1, 2, 3, 4]]

return 语句
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``return [表达式]`` 语句退出函数，选择性地向调用方返回一个表达式。
不带参数值的 return 语句返回 None 。之前的例子都没有示范如何返回数值，
下例便告诉你怎么做：

    .. code-block:: python
        :emphasize-lines: 9,12

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        # 可写函数说明
        def sum( arg1, arg2 ):
           # 返回2个参数的和."
           total = arg1 + arg2
           print "函数内 : ", total
           return total
         
        # 调用sum函数
        total = sum( 10, 20 )

    以上实例输出结果： ::

        函数内 :  30

变量作用域
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。

变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：

    -   全局变量
    -   局部变量

定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。

局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。
调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：

    .. code-block:: python
        :emphasize-lines: 4,8,14

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        total = 0 # 这是一个全局变量
        # 可写函数说明
        def sum( arg1, arg2 ):
           #返回2个参数的和."
           total = arg1 + arg2 # total在这里是局部变量.
           print "函数内是局部变量 : ", total
           return total
         
        #调用sum函数
        sum( 10, 20 )
        print "函数外是全局变量 : ", total

    以上实例输出结果： ::

        函数内是局部变量 :  30
        函数外是全局变量 :  0

模块
--------------------------------------------------------------------------------

Python 模块（Module），是一个 Python 文件，以 .py 结尾，
包含了 Python 对象定义和 Python 语句。

模块让你能够有逻辑地组织你的 Python 代码段。
把相关的代码分配到一个模块里能让你的代码更好用，更易懂。

模块能定义函数，类和变量，模块里也能包含可执行的代码。
下例是个简单的模块 support.py：

.. code-block:: python
    :caption: support.py

    def print_func( par ):
       print "Hello : ", par
       return

模块的引入
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

模块定义好后，我们可以使用 import 语句来引入模块，语法如下： ::

    import module1[, module2[,... moduleN]]

比如要引用模块 math，就可以在文件最开始的地方用 ``import math`` 来引入。
在调用 math 模块中的函数时，必须这样引用： ::

    模块名.函数名

.. note ::

    一个模块只会被导入一次，不管你执行了多少次 import 。
    这样可以防止导入模块被一遍又一遍地执行。

from...import 语句
********************************************************************************

Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下： ::

    from modname import name1[, name2[, ... nameN]]

例如，要导入模块 fib 的 fibonacci 函数，使用如下语句： ::

    from fib import fibonacci

这个声明不会把整个 fib 模块导入到当前的命名空间中，
它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。

from…import* 语句
********************************************************************************

把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： ::

    from modname import *

这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。
例如我们想一次性引入 math 模块中所有的东西，语句如下： ::

    from math import *

搜索路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。
搜索路径是一个解释器会先进行查找的所有目录的列表。

当你导入一个模块，Python 解析器对模块位置的搜索顺序是：

    #.  当前目录。
    #.  如果不在当前目录，Python 则搜索在 shell 变量 ``PYTHONPATH`` 下的每个目录。
    #.  如果都找不到，Pytho n会查看默认路径。
        UNIX下，默认路径一般为 ``/usr/local/lib/python/`` 

.. note ::

    模块搜索路径存储在 system 模块的 sys.path 变量中。
    变量里包含: 
        
        -   当前目录
        -   PYTHONPATH
        -   由安装过程决定的默认目录

PYTHONPATH 环境变量
********************************************************************************

作为环境变量， ``PYTHONPATH`` 是一个由许多目录组成的列表。
PYTHONPATH 的语法和 shell 变量 PATH 的一样。

在 Windows 系统，典型的 PYTHONPATH 如下： ::

    set PYTHONPATH=c:\python27\lib;

在 UNIX 系统，典型的 PYTHONPATH 如下： ::

    set PYTHONPATH=/usr/local/lib/python

命名空间和作用域
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的
对象们（值）的字典。

一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。
如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。

每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。
Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。

因此，如果要在函数内给全局变量赋值，必须使用 global 语句。
global VarName 的表达式会告诉 Python， VarName 是一个全局变量，
这样 Python 就不会在局部命名空间里寻找这个变量了。

例如，我们在全局命名空间里定义一个变量 Money。
我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。
然而，我们并没有在访问前声明一个局部变量 Money，
结果就是会出现一个 UnboundLocalError 的错误。
取消 global 语句前的注释符就能解决这个问题。

    .. code-block:: python
        :emphasize-lines: 7
    
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        Money = 2000
        def AddMoney():
           # 想改正代码就取消以下注释:
           # global Money
           Money = Money + 1
         
        print Money
        AddMoney()
        print Money
        
dir() 函数
********************************************************************************

``dir()`` 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。
返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例：

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        # 导入内置math模块
        import math
         
        content = dir(math)
         
        print content;

    以上实例输出结果： ::
    
        ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos',
        'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'comb',
        'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp',
        'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',
        'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt',
        'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan',
        'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin',
        'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc', 'ulp']

    在这里，特殊字符串变量 ``__name__`` 指向模块的名字， ``__file__`` 指向该模块的导
    入文件名。

globals() 和 locals() 函数
********************************************************************************

根据调用地方的不同， ``globals()`` 和 ``locals()`` 函数可被用来返回全局和局部命名空
间里的名字。

    -   如果在函数内部调用 ``locals()`` ，返回的是所有能在该函数里访问的命名。
    -   如果在函数内部调用 ``globals()`` ，返回的是所有在该函数里能访问的全局名字。

两个函数的返回类型都是字典。所以名字们能用 ``keys()`` 函数摘取。

reload() 函数
********************************************************************************

当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。

因此，如果你想重新执行模块里顶层部分的代码，可以用 ``reload()`` 函数。
该函数会重新导入之前导入过的模块。语法如下： ::

    reload(module_name)

在这里，module_name 要直接放模块的名字，而不是一个字符串形式。
比如想重载 hello 模块，如下： ::

    reload(hello)

包
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

包是一个分层次的文件目录结构，它定义了一个由模块及子包，
和子包下的子包等组成的 Python 的应用环境。

简单来说，包就是文件夹，但该文件夹下必须存在 ``__init__.py`` 文件, 
该文件的内容可以为空。 ``__init__.py`` 用于标识当前文件夹是一个包。

考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、__init__.py 文件，
test.py 为测试调用包的代码，目录结构如下：

    ::

        test.py
        package_runoob
        |-- __init__.py
        |-- runoob1.py
        |-- runoob2.py

    .. code-block:: python
        :caption: package_runoob/runoob1.py

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        def runoob1():
           print "I'm in runoob1"

    .. code-block:: python
        :caption: package_runoob/runoob2.py

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        def runoob2():
           print "I'm in runoob2"

    .. code-block:: python
        :caption: package_runoob/__init__.py

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        if __name__ == '__main__':
            print '作为主程序运行'
        else:
            print 'package_runoob 初始化'

然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包：
    
    .. code-block:: python
        :caption: test.py

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        # 导入 Phone 包
        from package_runoob.runoob1 import runoob1
        from package_runoob.runoob2 import runoob2
         
        runoob1()
        runoob2()

以上实例输出结果： ::

    package_runoob 初始化
    I'm in runoob1
    I'm in runoob2

如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。
你也可以在这些文件里定义 Python 的类，然后为这些类建一个包。

高级教程
================================================================================

面向对象
--------------------------------------------------------------------------------

-   **类(Class)：** 用来描述具有相同的属性和方法的对象的集合。
    它定义了该集合中每个对象所共有的属性和方法。
    对象是类的实例。
-   **类变量：** 类变量在整个实例化的对象中是公用的。
    类变量定义在类中且在函数体之外。
    类变量通常不作为实例变量使用。
-   **数据成员：** 类变量或者实例变量, 用于处理类及其实例对象的相关的数据。
-   **方法重写：** 如果从父类继承的方法不能满足子类的需求，可以对其进行改写，
    这个过程叫方法的覆盖（override），也称为方法的重写。
-   **局部变量：** 定义在方法中的变量，只作用于当前实例的类。
-   **实例变量：** 在类的声明中，属性是用变量来表示的。
    这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。
-   **继承：** 即一个派生类（derived class）继承基类（base class）的字段和方法。
    继承也允许把一个派生类的对象作为一个基类对象对待。
    
    例如，有这样一个设计：
    一个 Dog 类型的对象派生自 Animal 类，这是模拟 "是一个（is-a）"关系（Dog是一个Animal）。
-   **实例化：** 创建一个类的实例，类的具体对象。
-   **方法：** 类中定义的函数。
-   **对象：** 通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。

创建类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

使用  ``class`` 语句来创建一个新类，``class`` 之后为类的名称并以冒号结尾: ::

    class ClassName:
       '类的帮助信息'   #类文档字符串
       class_suite  #类体

类的帮助信息可以通过 ``ClassName.__doc__`` 查看。
``class_suite`` 由类成员，方法，数据属性组成。

以下是一个简单的 Python 类的例子:

    .. code-block:: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        class Employee:
           '所有员工的基类'
           empCount = 0
         
           def __init__(self, name, salary):
              self.name = name
              self.salary = salary
              Employee.empCount += 1
           
           def displayCount(self):
             print "Total Employee %d" % Employee.empCount
         
           def displayEmployee(self):
              print "Name : ", self.name,  ", Salary: ", self.salary

    -   ``empCount`` 变量是一个类变量，它的值将在这个类的所有实例之间共享。
        可以在内部类或外部类使用 ``Employee.empCount`` 访问。
    -   第一个方法 ``__init__()`` 方法是一种特殊的方法，被称为类的构造函数或初始化方法，
        当创建这个类的实例时就会调用该方法。
    -   ``self`` 代表类的实例，``self`` 在定义类的方法时是必须有的，
        虽然在调用时不必传入相应的参数。

self 代表类的实例，而非类
********************************************************************************

类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称, 
按照惯例它的名称是 ``self`` 。

    .. code-block:: python

        class Test:
            def prt(self):
                print(self)
                print(self.__class__)
         
        t = Test()
        t.prt()

    以上实例执行结果为： ::

        <__main__.Test instance at 0x10d066878>
        __main__.Test

    从执行结果可以很明显的看出， ``self`` 代表的是类的实例，代表当前对象的地址，
    而 ``self.__class__`` 则指向类。

    ``self`` 不是 python 关键字，我们把他换成其他标识符也是可以正常执行的。

创建实例对象
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

实例化类其他编程语言中一般用关键字 ``new`` ，但是在 Python 中并没有这个关键字，
类的实例化类似函数调用方式。

以下使用类的名称 ``Employee`` 来实例化，并通过 ``__init__`` 方法接收参数。

    .. code-block:: python

        "创建 Employee 类的第一个对象"
        emp1 = Employee("Zara", 2000)
        "创建 Employee 类的第二个对象"
        emp2 = Employee("Manni", 5000)

访问属性
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

使用点号 ``.`` 来访问对象的属性。使用如下类的名称访问类变量:

    .. code-block :: python
        :emphasize-lines: 23,24,25

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        class Employee:
           '所有员工的基类'
           empCount = 0
         
           def __init__(self, name, salary):
              self.name = name
              self.salary = salary
              Employee.empCount += 1
           
           def displayCount(self):
             print "Total Employee %d" % Employee.empCount
         
           def displayEmployee(self):
              print "Name : ", self.name,  ", Salary: ", self.salary
         
        "创建 Employee 类的第一个对象"
        emp1 = Employee("Zara", 2000)
        "创建 Employee 类的第二个对象"
        emp2 = Employee("Manni", 5000)
        emp1.displayEmployee()
        emp2.displayEmployee()
        print "Total Employee %d" % Employee.empCount

    执行以上代码输出结果如下： ::

        Name :  Zara ,Salary:  2000
        Name :  Manni ,Salary:  5000
        Total Employee 2

你可以添加，删除，修改类的属性，如下所示：

    .. code-block :: python

        emp1.age = 7  # 添加一个 'age' 属性
        emp1.age = 8  # 修改 'age' 属性
        del emp1.age  # 删除 'age' 属性

你也可以使用以下函数的方式来访问属性：

    -   ``getattr(obj, name[, default])`` : 访问对象的属性。
    -   ``hasattr(obj,name)`` : 检查是否存在一个属性。
    -   ``setattr(obj,name,value)`` : 设置一个属性。如果属性不存在，会创建一个新属性。
    -   ``delattr(obj, name)`` : 删除属性。

    .. code-block :: python

        hasattr(emp1, 'age')    # 如果存在 'age' 属性返回 True。
        getattr(emp1, 'age')    # 返回 'age' 属性的值
        setattr(emp1, 'age', 8) # 添加属性 'age' 值为 8
        delattr(emp1, 'age')    # 删除属性 'age'

类属性与方法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   **类的私有属性**

    ``__private_attrs`` ：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。
    在类内部的方法中使用时 ``self.__private_attrs`` 。

-   **类的方法**

    在类的内部，使用 ``def`` 关键字可以为类定义一个方法，与一般函数定义不同，
    类方法必须包含参数 ``self`` ，且为第一个参数。

-   **类的私有方法**

    ``__private_method`` ：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。
    在类的内部调用 ``self.__private_methods``

.. code-block :: python
    :emphasize-lines: 5,17

    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
     
    class JustCounter:
        __secretCount = 0  # 私有变量
        publicCount = 0    # 公开变量
     
        def count(self):
            self.__secretCount += 1
            self.publicCount += 1
            print self.__secretCount
     
    counter = JustCounter()
    counter.count()
    counter.count()
    print counter.publicCount
    print counter.__secretCount  # 报错，实例不能访问私有变量

Python 不允许实例化的类访问私有数据，但你可以使用 ``object._className__attrName``
（ **对象名._类名__私有属性名** ）访问属性，参考以下实例：

    .. code-block :: python
        :emphasize-lines: 5,8

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-

        class Runoob:
            __site = "www.runoob.com"

        runoob = Runoob()
        print runoob._Runoob__site

    执行以上代码，执行结果如下： ::

        www.runoob.com


单下划线、双下划线、头尾双下划线说明
********************************************************************************

-   ``__foo__`` : 定义的是特殊方法，一般是系统定义名字 ，类似 ``__init__()`` 之类的。

-   ``_foo`` : 以单下划线开头的表示的是 protected 类型的变量，
    即保护类型只能允许其本身与子类进行访问，不能用于 ``from module import *``

-   ``__foo`` : 双下划线的表示的是私有类型（private）的变量, 只能是允许这个类本身进行访问了。

内置类属性
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   ``__dict__`` : 类的属性（包含一个字典，由类的数据属性组成）
-   ``__doc__`` :类的文档字符串
-   ``__name__`` : 类名
-   ``__module__`` : 类定义所在的模块（类的全名是'__main__.className'，
    如果类位于一个导入模块 mymod 中，那么 ``className.__module__`` 等于 mymod ）
-   ``__bases__`` : 类的所有父类构成元素（包含了一个由所有父类组成的元组）

Python内置类属性调用实例如下：

    .. code-block :: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        class Employee:
           '所有员工的基类'
           empCount = 0
         
           def __init__(self, name, salary):
              self.name = name
              self.salary = salary
              Employee.empCount += 1
           
           def displayCount(self):
             print "Total Employee %d" % Employee.empCount
         
           def displayEmployee(self):
              print "Name : ", self.name,  ", Salary: ", self.salary
         
        print "Employee.__doc__:", Employee.__doc__
        print "Employee.__name__:", Employee.__name__
        print "Employee.__module__:", Employee.__module__
        print "Employee.__bases__:", Employee.__bases__
        print "Employee.__dict__:", Employee.__dict__

    执行以上代码输出结果如下： ::

        Employee.__doc__: 所有员工的基类
        Employee.__name__: Employee
        Employee.__module__: __main__
        Employee.__bases__: ()
        Employee.__dict__: {'__module__': '__main__', 'displayCount': <function displayCount at 0x10a939c80>, 'empCount': 0, 'displayEmployee': <function displayEmployee at 0x10a93caa0>, '__doc__': '\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb', '__init__': <function __init__ at 0x10a939578>}

类的继承
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。
通过继承创建的新类称为 **子类** 或 **派生类** ，被继承的类称为 **基类** 、**父类** 或 **超类** 。

继承语法： ::

    class 派生类名(基类名):
        ...

在 python 中继承中的一些特点：

    #.  如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，
        或者不重写父类的构造方法。
        详细说明可查看： `python 子类继承父类构造函数说明 <https://www.runoob.com/w3cnote/python-extends-init.html>`_ 。
    #.  在调用基类的方法时，需要加上基类的类名前缀，且需要带上 ``self`` 参数变量。
        区别在于类中调用普通函数时并不需要带上 ``self`` 参数
    #.  Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，
        它才开始到基类中逐个查找。

如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" 。多重继承语法： ::

    class SubClassName (ParentClass1[, ParentClass2, ...]):
        ...

.. code-block :: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        class Parent:        # 定义父类
           parentAttr = 100
           def __init__(self):
              print "调用父类构造函数"
         
           def parentMethod(self):
              print '调用父类方法'
         
           def setAttr(self, attr):
              Parent.parentAttr = attr
         
           def getAttr(self):
              print "父类属性 :", Parent.parentAttr
         
        class Child(Parent): # 定义子类
           def __init__(self):
              print "调用子类构造方法"
         
           def childMethod(self):
              print '调用子类方法'
         
        c = Child()          # 实例化子类
        c.childMethod()      # 调用子类的方法
        c.parentMethod()     # 调用父类方法
        c.setAttr(200)       # 再次调用父类的方法 - 设置属性值
        c.getAttr()          # 再次调用父类的方法 - 获取属性值

以上代码执行结果如下： ::

    调用子类方法
    调用父类方法
    父类属性 : 200

可以继承多个类： ::

    class A:        # 定义类 A
    .....

    class B:         # 定义类 B
    .....

    class C(A, B):   # 继承类 A 和 B
    .....

可以使用 ``issubclass()`` 或者 ``isinstance()`` 方法来检测。

    -   ``issubclass()`` - 布尔函数，判断一个类是另一个类的子类或者子孙类，语法：``issubclass(sub,sup)``
    -   ``isinstance(obj, Class)`` - 布尔函数，如果 obj 是 Class 类的实例对象或者是一个 Class 子类的实例对象则返回 True 。

方法重写
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法：

    .. code-block :: python

        #!/usr/bin/python
        # -*- coding: UTF-8 -*-
         
        class Parent:        # 定义父类
           def myMethod(self):
              print '调用父类方法'
         
        class Child(Parent): # 定义子类
           def myMethod(self):
              print '调用子类方法'
         
        c = Child()          # 子类实例
        c.myMethod()         # 子类调用重写方法

    执行以上代码输出结果如下： ::

        调用子类方法

基础方法重载
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

下表列出了一些通用的功能，你可以在自己的类重写：

============================    ============================    ====================================
方法                             描述                            简单调用
============================    ============================    ====================================
__init__(self [,args...])       构造函数                          obj = className(args)
__del__( self )                 析构方法                          del obj
__repr__( self )                转化为供解释器读取的形式            repr(obj)
_str__( self )                  将值转化为适于人阅读的形式          str(obj)
__cmp__ ( self, x )             对象比较                          cmp(obj, x)
============================    ============================    ====================================


运算符重载
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python同样支持运算符重载，实例如下：

    .. code-block :: python

        #!/usr/bin/python
         
        class Vector:
           def __init__(self, a, b):
              self.a = a
              self.b = b
         
           def __str__(self):
              return 'Vector (%d, %d)' % (self.a, self.b)
           
           def __add__(self,other):
              return Vector(self.a + other.a, self.b + other.b)
         
        v1 = Vector(2,10)
        v2 = Vector(5,-2)
        print v1 + v2

    以上代码执行结果如下所示： ::

        Vector(7,8)

对象销毁（垃圾回收）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

正则表达式
--------------------------------------------------------------------------------

多线程
--------------------------------------------------------------------------------

基础技能
================================================================================

入门知识
--------------------------------------------------------------------------------

1. 设置环境变量（可同时安装 2.x 和 3.x 两个版本的 Python） ::

        ...\Python27
        ...\Python27\Scripts
        ...\Python37
        ...\Python37\Scripts

2. 如何指定使用哪个版本的 Python ? ::

        安装 Python3 (>=3.3) 时，会同时安装一个启动器 Py.exe，默认在 C:\\Windows\ 路径下。

            该启动器允许我们指定使用 Python2 还是 Python3 来运行代码：

                py -2 test.py
                py -3 test.py

            或者直接在源代码文件中指定要使用的 Python 版本：

                #! python2
                #! python3

                运行代码：
                py test.py

3. 存在多个 Python 版本时，如何正确使用 pip ? ::

        同样使用启动器 py.exe 来指定 Python 版本：

            py -2 -m pip install <package_name>
            py -3 -m pip install <package_name>

            说明： -m pip 表示运行 pip 模块

国内镜像源
--------------------------------------------------------------------------------

镜像源列表：

-   清华大学：https://pypi.tuna.tsinghua.edu.cn/simple
-   中国科技大学：https://pypi.mirrors.ustc.edu.cn/simple/
-   华中理工大学：http://pypi.hustunique.com/
-   山东理工大学：http://pypi.sdutlinux.org/
-   豆瓣：http://pypi.douban.com/simple/
-   阿里云：http://mirrors.aliyun.com/pypi/simple/

使用方式：

    命令行中使用：
    
        pip install <package name> -i <mirror url> 

    修改配置文件:
        
        修改或创建配置文件 pip.conf 或 pip.ini
        
        文件内容：
        
            [global] 
            index-url = https://pypi.tuna.tsinghua.edu.cn/simple
        
        linux 下文件路径:    ~/.pip/pip.conf
        
        windows 下文件路径:  %userprofile%pip/pip.ini


常用 pip 命令
--------------------------------------------------------------------------------

#.  python -m pip install --upgrade pip   # 更新 pip
#.  pip install <packagename>
#.  pip install -i <index_url> <package_name>    # 使用镜像安装，或如后面修改全局配置文件
#.  pip install --upgrade <package_name>    # 更新指定的包
#.  pip uninstall <packagename>
#.  pip list
#.  pip freeze     # 显示所有依赖
#.  pip freeze > requirement.txt    # 生成 requirement.txt 文件
#.  pip install -r requirement.txt  # 根据 requirement.txt 生成相同的环境
#.  pip uninstall -r requirement.txt -y # 根据 requirement.txt 卸载包
#.  修改或创建配置文件（ linux 在 `~/.pip/pip.conf`，windows 在 `%HOMEPATH%\pip\pip.ini`） ::
        
        [global]
        index-url = https://pypi.tuna.tsinghua.edu.cn/simple

VirtualEnv 使用
--------------------------------------------------------------------------------

1. 安装 ::
    
        pip install virtualenv

2. 创建虚拟环境 ::

        virtualenv <work_folder_name>
        virtualenv <work_folder_name> -p <PYTHON_EXE> # 指定在虚拟环境中使用的 python 解释器，如 `-p python3.5`

3. 激活虚拟环境 ::

        cd <work_folder_name>
        Scripts\activate

4. 关闭虚拟环境 ::

        Scripts\deactivate


`Matplotlib Tutorials <https://matplotlib.org/stable/tutorials/index.html>`_
================================================================================

入门
--------------------------------------------------------------------------------

`教程一 <https://matplotlib.org/stable/tutorials/introductory/usage.html#sphx-glr-tutorials-introductory-usage-py>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Matplotlib 在 ``matplotlib.figure.Figure`` s 对象（如 windows, Jupyter widgets等）
上绘制数据，每个可以包含一个或多个 ``matplotlib.axes.Axes`` （一个 Axes 表示为一个区
域，可以在里面指定在 x-y 坐标，或在 theta-r 极坐标，或在 x-y-z 3D图中的点数据)。
使用 ``matplotlib.pyplot.subplots`` 方法可以创建一个包含一个 axes 的 figure。
然后我们可以使用 ``matplotlib.axes.Axes.plot`` 方法在 axes 上绘制数据。

.. plot:: pyplots/matplot_001.py
    :include-source:

图表的组成
********************************************************************************

#.  Figure ( ``matplot.figure.Figure`` )

    一个 Figure 对象代表了整个图表。Figure 对象对其中所有 Axes ，部分特殊的 Artist
    (titles, figure legends,etc) 和 **canvas** （它是非常重要的，因为它是实际绘制图形
    的对象，但作为用户，它对你来说或多或少是不可见的） 进行维护。
    
    一个 Figure 对象可以包含任意数量的 Axes ，但通常至少有一个。
    创建一个新的 Figure 对象的方式是使用 ``matplotlib.pyplot`` :

    .. code-block :: python

        fig = plt.figure( )  # an empty figure with no Axes
        fig, ax = plt.subplots()  # a figure with a single Axes
        fig, axs  = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes

    与 Figure 一起创建 Axes 很方便，但是也可以稍后再添加 Axes ，
    以实现更复杂的 Axes 布局。

#.  Axes ( ``matplot.axes.Axes`` )

    Axes 就是你所认为的一个“绘图”，它是包含数据的图像区域。一个 Figure 中可以包含多个
    Axes 对象，但是一个 Axes 对象只能在一个 Figure 中。
    
    一个 Axes 包含 2 个（3D 绘图中是 3 个） Axis 对象，它们负责对数据进行限制（也可以
    通过使用 ``matplotlib.axes.Axes.set_xlim()``
    和 ``matplotlib.axes.Axes.set_ylim`` 进行控制）。
    
    每一个 Axes 对象都包含：
    
        -   一个 title（通过 ``matplot.axes.Axes.set_title()`` 进行设置）
        -   一个 x-label（通过 ``matplot.axes.Axes.set_xlabel()`` 进行设置）
        -   一个 y-label（通过 ``matplot.axes.Axes.set_ylabel()`` 进行设置）
    
    
    
#.  Axis ( ``matplot.axis.Axis`` )

    它们是像数轴一样的对象。它们负责设置图形限制并生成刻度（轴上的标记）和
    刻度标签（标记刻度的字符串）。刻度的位置由 ``matplotlib.ticket.Locator`` 对象决定，
    而刻度标签则通过一个 ``matplot.ticker.Formatter`` 进行格式化。
    正确的 Locator 和 Formatter 的组合可以很好地控制刻度的位置和刻度标签。

#.  Artist ( ``matplot.artist.Artist`` )

    基本上，在图上看到的所有东西都是一个 Artist（甚至包括 Figure、Axes 和 Axis 等对象）。
    这包括以下常见的对象：
    
    -   ``matplotlib.text.Text``
    -   ``matplotlib.lines.Line2D``
    -   ``matplotlib.collections``
    -   ``matplotlib.patches.Patch``
    -   ...

    当一个 Figure 被渲染的时候，所有的 Artist 对象都被绘制到 **canvans** 上。
    大多数 Artist 对象是关联到 Axes 对象的，这种 Artist 对象就不能在多个 Axes 对象间
    共享，也不能从一个 Axes 对象中移到另一个 Axes 对象中。

绘制函数的输入参数类型
********************************************************************************

所有的绘制函数都使用 ``numpy.array`` 或者 ``numpy.ma.masked_array`` 类型的对象作为
输入参数。使用类似数组的 ``pandas`` 或者 ``numpy.matrix`` 对象作为输入参数可能会或
可能不会像预期那样正常运行。因此在绘制前最好将这类数据转换为 ``numpy.array`` 类型的对象。

例如，转换一个 ``pandas.DataFrame`` 类型的对象：

.. code-block :: python

    a = pandas.DataFrame(np.random.rand(4, 5), columns = list('abcde'))
    a_asarray = a.values

转换一个 ``numpy.matrix`` 类型的对象：

.. code-block :: python

    b = np.matrix([[1, 2], [3, 4]])
    b_asarray = np.asarray(b)

面向对象的接口和 pyplot 接口
********************************************************************************

就像在前面提到的那样，实际上有两种使用 Matplotlib 的方式：

    -   显示创建 Figure 和 Axes 对象，然后调用这些对象上的方法（面向对象的风格）
    -   依赖 pyplot 去自动创建和管理 Figure 和 Axes 对象，然后使用 pyplot 提供的函数绘制

因此，我们可以使用两种风格的代码：

.. plot:: pyplots/matplot_002.py
    :include-source:
    :caption: OO-style
    

.. plot:: pyplots/matplot_003.py
    :include-source:
    :caption: pyplot-style

此外，还有第三种方法，用于在 GUI 应用程序中嵌入 Matplotlib，
更多信息参考 `Embedding Matplotlib in graphical user interfaces <https://matplotlib.org/stable/gallery/index.html#user-interfaces>`_ 。

Matplotlib 的文档和示例同时使用面向对象和 pyplot 风格（它们同样强大），
您可以随意使用它们（但是，最好选择其中一种并坚持使用，而不是混合使用）。
一般来说，我们建议在交互式绘制（例如，在Jupyter笔记本中）使用 pyplot 风格，
对于非交互式绘制（在打算作为更大项目的一部分重用的函数和脚本中）使用面向对象风格。

.. note ::

    在以前的例子中，你可能会发现使用所谓的 pylab 接口的例子，
    使用 ``form pylab import *`` 。
    这将从 pyplot 和 numpy 模块中导入所有内容，
    因此可以使用以下更类似于MATLAB 风格的代码：

    .. code-block :: python

        x = linspace(0, 2, 100)
        plot(x, x, label='linear')

    现在强烈反对并弃用这种方法。这里只提到它，因为你可能仍然在其它地方遇到。

通常情况下，人们会发现自己一次又一次地绘制相同的图，但使用不同的数据集，
这导致需要编写专门的函数来进行绘制。建议的函数签名类似于：

.. code-block :: python

    def my_plotter(ax, data1, data2, param_dict):
        """
        A helper function to make a graph

        Parameters
        ----------
        ax : Axes
            The axes to draw to

        data1 : array
           The x data

        data2 : array
           The y data

        param_dict : dict
           Dictionary of kwargs to pass to ax.plot

        Returns
        -------
        out : list
            list of artists added
        """
        out = ax.plot(data1, data2, **param_dict)
        return out

然后你可以这样使用：

.. code-block :: python

    data1, data2, data3, data4 = np.random.randn(4, 100)
    fig, ax = plt.subplots(1, 1)
    my_plotter(ax, data1, data2, {'marker': 'x'})

.. plot:: pyplots/matplot_004.py

或者如果你想有两个图：

.. code-block :: python

    data1, data2, data3, data4 = np.random.randn(4, 100)
    fig, ax = plt.subplots(1, 1)
    my_plotter(ax, data1, data2, {'marker': 'x'})

.. plot:: pyplots/matplot_005.py

对于这些简单的例子来说，这种方式似乎有点过犹不及，
但是一旦图表变得稍微复杂一点，就会体会到它的方便之处。

后端 Backends
********************************************************************************

#.  什么是一个 backend

    网上许多文档都提到了 "backend"，许多新用户对这个术语感到困惑。 
    Matplotlib 允许不同的用例和输出格式。
    有些人从 python shell 交互式地使用 Matplotlib，并在他们键入命令时弹出绘图窗口。 
    有些人运行 Jupyter notebook 并绘制内联图以进行快速数据分析。
    其他人将 Matplotlib 嵌入到 PyQt 或 PyGObject 等图形用户界面中以构建丰富的应用程序。
    有些人在批处理脚本中使用 Matplotlib 从数值模拟中生成 postscript 图像，
    还有一些人运行 Web 应用程序服务器来动态提供图形。

    为了支持所有这些用例，Matplotlib 可以有不同的输出，每一个都被称为 backend;
    "frontend" 是面向用户的代码，即绘图代码;
    而 "backend" 则完成所有幕后的艰苦工作来生成图形。
    有两种类型的后端:
    
        -   用户界面后端（用于PyQt/PySide, PyGObject, Tkinter, wxPython，或macOS/Cocoa)
            ，也被称为“交互式后端”。
        -   硬拷贝后端用于制作图像文件（PNG, SVG, PDF, PS），也被称为“非交互式后端”。

#.  选择一个 backend

    有三种方法类配置 backend ：
    
        #.  通过 matplotlibrc 文件中的 `rcParams["backend"] <https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=backend#a-sample-matplotlibrc-file>`_ 参数
        #.  `MPLBACKEND <https://matplotlib.org/stable/faq/environment_variables_faq.html#envvar-MPLBACKEND>`_ 环境变量
        #.  使用 ``matplotlib.use()`` 方法
    
    如果存在多个这样的配置，则列表中的最后一个优先。
    例如，调用 ``matplotlib.use()`` 将重写 matplotlibrc 文件中的设置。

    如果没有显式设置 backend ，Matplotlib 会根据系统上可用的内容和GUI事件循环是否已经
    在运行，自动检测可用后端。
    在Linux上，如果没有设置环境变量 ``DISPLAY`` ，则“事件循环”被标识为“headless”，
    这将导致回退到非交互后端(agg)。
    在所有其他情况下，首选交互式后端(通常，至少tkagg是可用的)。

    下面是配置方法的详细说明：
    
        #.  在 matplotlibrc 文件中设置 ``rcParams["backend"]`` 参数：
        
            ::
            
                backend : qt5agg   # use pyqt5 with antigrain (agg) rendering
            
            更多其它详细信息，请参考 `Customizing Matplotlib with style sheets and rcParams <https://matplotlib.org/stable/tutorials/introductory/customizing.html>`_ 。
        #.  设置 ``MPLBACKEND`` 环境变量：
        
            您可以为当前shell或单个脚本设置环境变量。
            
            在 Unix 系统中： ::
            
                > export MPLBACKEND=qt5agg
                > python simple_plot.py

                > MPLBACKEND=qt5agg python simple_plot.py
            
            在 Windows 系统中，只能使用第一种方式： ::
            
                > set MPLBACKEND=qt5agg
                > python simple_plot.py
            
            设置此环境变量将覆盖任何 matplotlibrc 文件中的 backend 参数设置，
            即使当前工作目录中存在 matplotlibrc 文件。
            因此，设置全局的 ``MPLBACKEND`` 环境变量，例如在 .bashrc 或 .profile 中，
            是不鼓励的，因为它可能会导致反直觉的行为。
            
        #.  如果脚本依赖于一个特定的 backend ，可以使用函数 ``matplotlib.use()`` ：
        
            .. code-block :: python
            
                import matplotlib
                matplotlib.use('qt5agg')

            这应该在创建任何图形之前完成，否则 Matplotlib 可能无法切换 backend 并引发
            ImportError 。
            
            如果用户想要使用不同的 backend ，使用这种方式将需要更改代码。
            因此，除非绝对必要，否则应该避免在脚本中显式调用 ``matplotlib.use()`` 方法。
    
#.  内置的 backends

    默认情况下，Matplotlib 应该自动选择一个默认的 backend ，
    使它能够在交互模式和从脚本绘图的情况下正常工作，并输出到屏幕和/或文件。
    所以至少在最开始的时候，不需要考虑 backend 的设置。最常见的异常是，
    如果您的 Python 发行版没有 `tkinter <https://docs.python.org/3/library/tkinter.html#module-tkinter>`_ ，
    并且您没有安装其他 GUI 工具包。
    这种情况发生在某些 Linux 发行版上，
    您需要安装一个名为 python-tk(或其它类似) 的 Linux 包。
    
    但是，如果您是以下情况，请继续阅读：
    
        -   想要编写图形用户界面
        -   想要编写web应用服务器（ `Embedding in a web application server (Flask) <https://matplotlib.org/stable/gallery/user_interfaces/web_application_server_sgskip.html>`_ ）
        -   需要更好地理解正在发生的事情
    
    为了让图形用户界面更易于定制，Matplotlib 将渲染器（实际进行绘图的东西）与 canvans 
    （绘图的地方）的概念分离。用户界面的典型渲染器是 ``Agg`` ，它使用 
    `Anti-Grain Geometry <http://antigrain.com/>`_ C++ 库来制作 Figure 的光栅（像素）图像。
    它被 Qt5Agg, Qt4Agg, GTK3Agg, wxAgg, TkAgg 和 macosx 的 backend 使用。
    另一种渲染器基于 ``Cairo`` 库，由 Qt5Cairo、Qt4Cairo 等使用。
    
    对于渲染引擎，还可以分为 **矢量渲染器** 和 **光栅渲染器** 。
    矢量图形语言发出像“从这一点到这一点画一条线”这样的绘图命令，因此是 scale free 的；
    光栅后端生成线的像素表示，其准确性取决于 DPI 设置。
    
    下面是 Matplotlib 渲染器的概要（每个渲染器都有一个同名的 backend ；
    这些是非交互式 backend，能够写入文件）：
    
    ========    ================    ============================================
    渲染器       文件类型             描述
    ========    ================    ============================================
    AGG         png                 光栅图——使用 ``Anti-Grain Geometry``
                                    引擎渲染的高质量图像
    PDF         pdf                 向量图——Portable Document Format
    PS          ps,eps              向量图——Postscript 
    SVG         svg                 向量图——Scalable Vector Graphics
    PGF         pgf,pdf             向量图——使用 `pgf <https://ctan.org/pkg/pgf>`_ 包
    Cairo       png,ps,pdf,svg      光栅图、向量图——使用 ``Cairo`` 库
    ========    ================    ============================================
    
    使用 ``matplotlib.pyplot.savefig('filename')`` 方法以非交互式 backend 保存图表。
    
    下面是支持的用户界面和渲染器组合。这些是交互式 backend，能够将图表显示到屏幕上，
    并使用上表中的适当的渲染器将其写入到文件：
    
    ================    ========================================================
    Backend             描述
    ================    ========================================================
    Qt5Agg              
    ipympl              
    GTK3Agg
    macosx
    TkAgg
    nbAgg
    WebAgg
    GTK3Cairo
    Qt4Agg
    wxAgg
    ================    ========================================================
    
    .. note ::
    
        内置 backend 的名称不区分大小写。例如，"Qt5Agg" 和 "Qt5Agg" 是等价的。
    
#.  使用非内置的 backends

    更一般地，任何可导入的 backend 都可以通过使用上面的任何方法来选择。
    如果 ``name.of.the.backend`` 是包含 backend 的模块，
    使用 ``module://name.of.the.backend`` 作为 backend 的名称，
    例如：
    
    .. code-block :: python

        matplotlib.use('module://name.of.the.Backend')
    
什么是交互式模式
********************************************************************************

#.  交互式案例

    在普通的 python 提示符中，或者在没有设置额外选项的情况下调用 ipython 之后，
    测试以下代码：
    
    .. code-block:: python
    
        import matplotlib.pyplot as plt
        plt.ion()
        plt.plot([1.6, 2.7])
    
    这将弹出一个绘图窗口。您的终端提示符将保持活动状态，以便您可以键入其他命令，例如：
    
    .. code-block:: python

        plt.title("interactive test")
        plt.xlabel("index")

    在大多数交互式 backend 中，如果您通过面向对象接口更改 figure ，窗口也将被更新。
    例如，获取一个 Axes 实例的引用，并调用该实例的一个方法：
    
    .. code-block:: python

        ax = plt.gca()
        ax.plot([3.1, 2.2])
    
    如果您正在使用某些 backend （如 macosx ）或较老版本的 Matplotlib ，
    您可能不会立即看到新添加到图表中的线条。
    在这种情况下，您需要显式地调用 ``draw()`` 来更新图表：
    
    .. code-block:: python

        plt.draw()
    
#.  非交互式案例

    像前面的例子一样启动一个新的会话，但是现在关闭交互模式：
    
    .. code-block:: python
        :emphasize-lines: 2

        import matplotlib.pyplot as plt
        plt.ioff()
        plt.plot([1.6, 2.7])
    
    什么都没有发生——或者至少什么都没有显示在屏幕上（除非您正在使用了反常的 macosx backend）。
    为了让图表出现，你需要这样做：
    
    .. code-block:: python
    
        plt.show()

    现在您看到了这个图，但是您的终端命令行没有响应。
    ``matplotlib.pyplot.show()`` 方法会阻止其他命令的输入，直到您手动杀死绘图的窗口。
    
    这有什么好处——被迫使用阻塞函数？
    假设您需要一个脚本来将文件的内容绘制到屏幕上。你想看一下图表，然后结束脚本。
    如果没有 ``show()`` 这样的阻塞命令，脚本就会弹出图表，然后立即结束，
    在屏幕上什么也不留下。

    此外，非交互模式会延迟所有绘制，直到调用 ``show()`` 。
    这样比每次脚本中的新添加一行新功能时就重新绘制更有效。

    在 1.0 版本之前， ``show()`` 方法通常不能在单个脚本中调用多次（尽管有时可以使用它）。
    对于版本 1.0.1 及更高版本，这个限制被取消，因此可以编写下面这样的脚本：
    
    .. code-block:: python
    
        import numpy as np
        import matplotlib.pyplot as plt

        plt.ioff()
        for i in range(3):
            plt.plot(np.random.rand(10))
            plt.show()
    
    这将产生三个图表，一次一个。
    也就是说，一旦第一个图表被关闭，第二个图表就会显示。

#.  总结

性能
********************************************************************************

无论是以交互模式处理数据，还是以编程方式保存大量图表，
渲染性能都可能是工作流中一个令人痛苦的瓶颈。Matplotlib 提供了几种方法，
可以大大减少渲染时间，但代价是在图表的外观上的一些细微改变（到一个可自行设定的容忍度）。
创建的绘图的类型决定了哪些方式是可用的。

#.  线段简化

    对于包含线段的图（e.g. typical line plots, outlines of polygons, etc.），
    渲染性能可以通过下面的设置来控制。
    例如可以在 matplotlibrc 文件中定义，
    更多细节参考 `Customizing Matplotlib with style sheets and rcParams <https://matplotlib.org/stable/tutorials/introductory/customizing.html>`_ 。

        -   ``rcParams["path.simplify"]`` (default: True)： 
            一个布尔值，指定是否对线段进行简化。
        
        -   ``rcParams["path.simplify_threshold"]`` (default: 0.111111111111)：
            控制简化多少线段，值越大渲染会更快。

    下面的脚本将首先显示未经任何简化的数据，然后显示经过简化的相同数据。
    
    .. code-block:: python
        :emphasize-lines: 9,11,15

        import numpy as np
        import matplotlib.pyplot as plt
        import matplotlib as mpl

        # Setup, and create the data to plot
        y = np.random.rand(100000)
        y[50000:] *= 2
        y[np.geomspace(10, 50000, 400).astype(int)] = -1
        mpl.rcParams['path.simplify'] = True

        mpl.rcParams['path.simplify_threshold'] = 0.0
        plt.plot(y)
        plt.show()

        mpl.rcParams['path.simplify_threshold'] = 1.0
        plt.plot(y)
        plt.show()

    Matplotlib 当前默认的简化阈值为比较保守的 1/9。如果要修改默认值，
    可以更改 matplotlibrc 文件。或者，您可以为交互式绘图（最大限度地简化）创建一种新样式，
    为出版物高质量绘图（最小限度地简化）创建另一种样式，并在必要时激活它们。
    关于如何实现请参考 `Customizing Matplotlib with style sheets and rcParams <https://matplotlib.org/stable/tutorials/introductory/customizing.html>`_ 。
    
    简化的方法是迭代地将线段合并为单个矢量，直到下一个线段与矢量的垂直距离
    （在显示坐标空间中测量）大于 "path.simplify_threshold" 参数。
    
    .. note ::

        在 2.1 版中对如何简化线段进行了更改。
        在 2.1 版本之前，这些参数仍然会提高渲染时间，
        但对某些类型数据的渲染时间将在 2.1 及更高版本中得到极大的改善。

#.  标记简化

    标记也可以简化，尽管不像线段那么强大。标记简化仅对 ``matplotlib.lines.Line2D``
    对象可用（通过 markevery 属性）。只要 Line2D 对象作为构造参数被传递，
    就可以使用 markevery 参数。
    比如 ``matplotlib.pyplot.plot()`` 和 ``matplotlib.axes.Axes.plot()`` 。
    
    .. code-block:: python
    
        plt.plot(x, y, markevery=10)
    
    markevery 参数允许简单的子采样，或尝试均匀间隔（沿 x 轴）采样。
    参考 `Markevery Demo <https://matplotlib.org/stable/gallery/lines_bars_and_markers/markevery_demo.html>`_ 以了解更多信息。
    
#.  分割线条为更小的块

    If you are using the Agg backend, then you can make use of 
    rcParams["agg.path.chunksize"] (default: 0).
    This allows you to specify a chunk size, and any lines with greater than 
    that many vertices will be split into multiple lines,
    each of which has no more than agg.path.chunksize many vertices. 
    (Unless agg.path.chunksize is zero, in which case there is no chunking.) 
    For some kind of data, 
    chunking the line up into reasonable sizes can greatly decrease rendering time.
    
    下面的脚本将首先在没有没有任何块大小限制的情况下显示数据；
    然后设置块大小为 10,000 ，显示相同的数据。
    当图形很大的时候，可以比较好地看到区别，尝试最大化 GUI ，然后与它们交互：
    
    .. code-block :: python

        import numpy as np
        import matplotlib.pyplot as plt
        import matplotlib as mpl
        mpl.rcParams['path.simplify_threshold'] = 1.0

        # Setup, and create the data to plot
        y = np.random.rand(100000)
        y[50000:] *= 2
        y[np.geomspace(10, 50000, 400).astype(int)] = -1
        mpl.rcParams['path.simplify'] = True

        mpl.rcParams['agg.path.chunksize'] = 0
        plt.plot(y)
        plt.show()

        mpl.rcParams['agg.path.chunksize'] = 10000
        plt.plot(y)
        plt.show()
    
#.  图例

    Axes 的默认图例行为试图找到覆盖最少数据点的位置（loc='best'）。
    如果有很多数据点，这可能是一个非常昂贵的计算。
    在这种情况下，您可能需要提供一个特定的位置。
    
#.  使用 fast style

    ``fast`` 样式可以用来自动地将简化和分块参数设置为合理的设置，
    以加快绘制大量数据的速度。它可以简单地通过以下设置来使用：
    
    .. code-blocK:: python

        import matplotlib.style as mplstyle
        mplstyle.use('fast')

    它是非常轻量的，所以它可以很好地与其它样式一起使用，
    只要确保 ``fast`` 样式是最后应用的，这样不会被其它样式所覆盖：
    
    .. code-blocK:: python

        mplstyle.use(['dark_background', 'ggplot', 'fast'])

`教程二 <https://matplotlib.org/stable/tutorials/introductory/pyplot.html#sphx-glr-tutorials-introductory-pyplot-py>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

pyplot 简介
********************************************************************************

``matplotlib.pyplot`` 模块提供了大量的函数，使得 matplotlib 能够以 MATLAB 类似的方式
进行使用。里面的每一个绘制函数都会对 Figure 对象进行一定的调整，
例如：创建图形，在图形中创建绘图区域，在绘图区域中绘制一些线，用标签修饰绘图等等。

在不同的函数被调用时， ``matplotlib.pyplot`` 对象中始终同步着各种状态，
以便跟踪许多事情，比如：当前图形和绘图区域等对象，
因此绘制函数将正确地指向当前的 Axes 对象。

.. note ::

    pyplot 风格的接口通常不如面向对象风格的接口灵活。
    这里看到的大多数函数调用也可以使用对 Axes 对象的方法调用。

使用 pyplot 生成可视化内容非常容易：

.. plot:: pyplots/matplot_006.py
    :include-source:

您可能想知道为什么 x 轴的范围是 0-3 ，y轴的范围是 1-4 。
如果您提供一个一维列表或数组来绘图，matplotlib 会假定它是一个 y 值序列，
并自动为您生成 x 值。
由于 python 的范围以 0 开始，默认的 x 向量与 y 长度相同，但以 0 开始。
因此 x 数据是 [0,1,2,3] 。

``matplotlib.pyplot.plot`` 是一个多功能函数，可以接受任意数量的参数。
例如，要绘制 x 与 y 的关系，可以编写：

.. plot:: pyplots/matplot_007.py
    :include-source:

图表样式设置
********************************************************************************

对于每一对 x, y 参数，都有一个可选的第三个参数，它是表示图表颜色和线条类型的格式字符串。
格式字符串的字母和符号来自 MATLAB ，您将一个颜色字符串与一个行样式字符串连接起来。
默认格式字符串是 'b-' ，它表示蓝色实线。例如，要用红色圆圈绘制上面的图：

.. plot:: pyplots/matplot_008.py
    :include-source:

上面示例中的 ``matplotlib.pyplot.aixs`` 函数接受 [xmin, xmax, ymin, ymax] 的一个列表，
以指定 Axes （即绘图区域）的视口。

.. code-block:: python
    
    matplotlib.pyplot.plot(*args, scalex=True, scaley=True, data=None, **kwargs)

调用方式： ::

    plot([x], y, [fmt], *, data=None, **kwargs)
    plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)

点或线节点的坐标由 x, y 给出。可选参数 fmt 是定义基本格式的一种方便方法。
fmt 的格式如下： ::

    fmt = '[marker][line][color]'

Each of them is optional. 
If not provided, the value from the style cycle is used. 
Exception: If line is given, but no marker, 
the data will be a line without markers.

Other combinations such as [color][marker][line] are also supported, 
but note that their parsing may be ambiguous.

#. Markers

================    ================================
character           description
================    ================================
\'.\'               point marker
\',\'               pixel marker
\'o\'               circle marker
\'v\'               triangle\_down marker
\'\^\'              triangle\_up marker
\'\<\'              triangle\_left marker
\'\>\'              triangle\_right marker
\'1\'               tri\_down marker
\'2\'               tri\_up marker
\'3\'               tri\_left marker
\'4\'               tri\_right marker
\'8\'               octagon marker
\'s\'               square marker
\'p\'               pentagon marker
\'P\'               plus (filled) marker
\'\*\'              star marker
\'h\'               hexagon1 marker
\'H\'               hexagon2 marker
\'\+\'              plus marker
\'x\'               x marker
\'X\'               x (filled) marker
\'D\'               diamond marker
\'d\'               thin\_diamond marker
\'|\'               vline marker
\'\_\'              hline marker
================    ================================

#.  Line Styles

================    ================================
character           description
================    ================================
\'\-\'              solid line style
\'\-\-\'            dashed line style
\'\-\.\'            dash-dot line style
\'\.\.\'            dotted line style
================    ================================

#.  Colors

================    ================================
character           description
================    ================================
\'b\'               blue
\'g\'               green
\'r\'               red
\'c\'               cyan
\'m\'               magenta
\'y\'               yellow
\'k\'               black
\'w\'               white
================    ================================

如果 matplotlib 仅限于处理列表类型的数据，那么它对于数字处理来说就是相当无用的。
通常，您将使用 numpy 数组。
事实上，所有序列都在内部转换为 numpy 数组。
下面的示例演示了在一个函数调用中使用数组作为参数传递来绘制具有不同样式的几条线：

.. plot:: pyplots/matplot_009.py
    :include-source:

使用关键字字符串绘制
********************************************************************************

在某些情况下，数据的格式允许您使用以字符串形式的关键字访问特定的数据。
例如，使用 ``numpy.recarray`` 或 ``pandas.DataFrame`` 。

Matplotlib 允许您使用 data 关键字参数提供这样一个对象。
如果提供了，那么您可以通过字符串关键字来使用相应的数据以生成图表。

.. plot:: pyplots/matplot_010.py
    :include-source:

Plotting with categorical variables
********************************************************************************

It is also possible to create a plot using categorical variables.
Matplotlib allows you to pass categorical variables directly to
many plotting functions. For example:

.. plot:: pyplots/matplot_011.py
    :include-source:


控制线条属性
********************************************************************************

线条有很多属性，你可以设置:线宽，破折号样式，抗锯齿，等等。
参考 `matplotlib.lines.Line2D <https://matplotlib.org/stable/api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D>`_ 。
有几种方法可以设置线条的属性：

    -   使用关键字参数：
    
        .. code-block:: python
        
            plt.plot(x, y, linewidth=2.0)

    -   使用 Line2D 对象的 setter 方法。plot 方法返回一个 Line2D 对象列表。
        例如，line1, line2 = plot(x1, y1, x2, y2)。
        在下面的代码中，我们假设只有一个 Line2D 对象，因此返回的列表长度为 1。
        我们使用 line 进行元组解包，以获得列表的第一个元素：
    
        .. code-block:: python
        
            line, = plt.plot(x, y, '-')
            line.set_antialiased(False) # turn off antialiasing
                
    -   使用 ``matplotlib.pyplot.setp()`` 方法：
    
        下面的示例使用 MATLAB 风格的函数在一个线条集合上设置多个属性。
        Setp 函数透明地对一个线条或多个线条对象进行处理。
        你可以使用 python 关键字参数或 MATLAB 风格的字符串键值对:
        
        .. code-block:: python
            
            lines = plt.plot(x1, y1, x2, y2)
            # use keyword args
            plt.setp(lines, color='r', linewidth=2.0)
            # or MATLAB style string value pairs
            plt.setp(lines, 'color', 'r', 'linewidth', 2.0)

下面是可用的 Line2D 对象的属性：

========================    ====================================================
属性                        值类型
========================    ====================================================
alpha                       float
animated                    [True | False]
antialiased or aa           [True | False]
clip_box                    a matplotlib.transform.Bbox instance
clip_on                     [True | False]
clip_path                   a Path instance and a Transform instance, a Patch
color or c                  any matplotlib color
contains                    the hit testing function
dash_capstyle               ['butt' | 'round' | 'projecting']
dash_joinstyle              ['miter' | 'round' | 'bevel']
dashes                      sequence of on/off ink in points
data                        (np.array xdata, np.array ydata)
figure                      a matplotlib.figure.Figure instance
label                       any string
linestyle or ls             [ '-' | '--' | '-.' | ':' | 'steps' | ...]
linewidth or lw             float value in points
marker                      [ '+' | ',' | '.' | '1' | '2' | '3' | '4' ]
markeredgecolor or mec      any matplotlib color
markeredgewidth or mew      float value in points
markerfacecolor or mfc      any matplotlib color
markersize or ms            float
markevery                   [ None | integer | (startind, stride) ]
picker                      used in interactive line selection
pickradius                  the line pick selection radius
solid_capstyle              ['butt' | 'round' | 'projecting']
solid_joinstyle             ['miter' | 'round' | 'bevel']
transform                   a matplotlib.transforms.Transform instance
visible                     [True | False]
xdata                       np.array
ydata                       np.array
zorder                      any number
========================    ====================================================

要获取可以进行设置的线条属性列表，
请使用一个或多个行作为参数调用 ``matplotlib.pyplot.setp()`` 函数： ::

    In [69]: lines = plt.plot([1, 2, 3])

    In [70]: plt.setp(lines)
      alpha: float
      animated: [True | False]
      antialiased or aa: [True | False]
      ...snip

使用多个 Figure 和 Axes
********************************************************************************

MATLAB 和 pyplot 都有当前 Figure 和 当前 Axes 的概念。
所有的绘图函数都是对当前 Axes 对象进行处理。
使用 ``matplotlib.pylot.gca()`` 函数可以返回当前的 Axes 对象；
使用 ``matplotlib.pylot.gcf()`` 函数可以返回当前的 Figure 对象。
通常情况下，你不必担心这个，因为所有这些都是在幕后处理的。

下面是创建两个图标的脚本：

.. plot:: pyplots/matplot_012.py
    :include-source:

这里 ``figure`` 函数的调用是可选的，因为在 Figure 对象实例不存在的时候，
将会自动创建一个 Figure 对象。就像不存在 Axes 对象时，将自动创建一个 Axes 对象
（相当于显式调用 ``subplot()`` 函数）一样。``subplot()`` 函数调用时指定
numrows, numcols, plot_number，其中 plot_number 的有效取值为 [1, numrows*numcols]。
如果 numrows*numcols < 10 , ``subplot()`` 函数调用中的逗号是可选的。
所以 ``subplot(211)`` 和 ``subplot(2, 1, 1)`` 是等价的。

You can create an arbitrary number of subplots and axes.
If you want to place an axes manually, i.e., not on a rectangular grid, use axes,
which allows you to specify the location as axes([left, bottom, width, height])
where all values are in fractional (0 to 1) coordinates.
See Axes Demo for an example of placing axes manually and Basic Subplot Demo
for an example with lots of subplots.

可以通过多次调用 ``matplotlib.pyplot.figure()`` 函数来创建多个 Figure 。
当然，每个 Figure 可以包含任意多的 axes subplots :

.. plot:: pyplots/matplot_013.py
    :include-source:

绘制文本
********************************************************************************

对数轴和其它非线性轴
********************************************************************************

`教程三 <https://matplotlib.org/stable/tutorials/introductory/sample_plots.html#sphx-glr-tutorials-introductory-sample-plots-py>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`教程四 <https://matplotlib.org/stable/tutorials/introductory/images.html#sphx-glr-tutorials-introductory-images-py>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`教程五 <https://matplotlib.org/stable/tutorials/introductory/lifecycle.html#sphx-glr-tutorials-introductory-lifecycle-py>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`教程六 <https://matplotlib.org/stable/tutorials/introductory/customizing.html#sphx-glr-tutorials-introductory-customizing-py>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

中级
--------------------------------------------------------------------------------

高级
--------------------------------------------------------------------------------

色彩
--------------------------------------------------------------------------------

文本
--------------------------------------------------------------------------------

工具包
--------------------------------------------------------------------------------

`NumPy Reference <https://numpy.org/doc/stable/reference/index.html>`_
================================================================================

数组对象
--------------------------------------------------------------------------------

NumPy 提供了一个 N-维 的数组类型 ``ndarray`` ，它描述了包含相同数据类型项的集合。
这些项可以使用例如 N 个整数进行索引。

每一个 ndarry 对象都是同构的：
其中每一项占用同样大小的内存空间；
这些内存空间中的数据以相同的方式进行解释。
ndarry 对象中的 ``data-type`` 属性决定了这些数据该被如何解释。
除了使用基本数据类型（如整数、浮点数等），还可以使用其它的数据结构。

N\-维数组（ndarry）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ndarray 是一个包含多项同种类型数据的多维的（通常是固定大小的）容器（可称为数组）。
ndarray 对象的维数和包含数据的数量由它的 ``shape`` 属性决定，
这是一个 ``tuple`` 类型的属性，包含了 N 个非负的整数，每一个数字代表了对应维度上的尺寸。
数据的类型由 ``dtype`` 属性所确定。

和 Python 中其它的容器对象一样，可以通过索引、切片（例如使用 N 个整数）或者
相关方法和属性来访问和修改其中的内容。

不同的 ndarray 对象可以共享相同的数据，因此一个对象对数据的修改在另一个对象中也能看到。
即一个对象拥有另一个对象的数据的 **视图** 。
ndarray 对象也可以这种方式看到 Python 中的 string 类型或实现了 buffer 或着 array
接口的类型的对象的内存。

下面定义了一个尺寸为 2x3 且数据类型为 4 字节的整数的 2 维数组：

>>> x = np.array([[1, 2, 3], [4, 5, 6]], np.int32)
>>> type(x)
<class 'numpy.ndarray'>
>>> x.shape
(2, 3)
>>> x.dtype
dtype('int32')

可以使用 Python 中像容器那样的语法对其中的数据进行索引：

>>> # The element of x in the *second* row, *third* column, namely, 6.
>>> x[1, 2]
6

切片操作可以产生数组对象的视图：

>>> y = x[:,1]
>>> y
array([2, 5])
>>> y[0] = 9 # this also changes the corresponding element in x
>>> y
array([9, 5])
>>> x
array([[1, 9, 3],
       [4, 5, 6]])

#.  构造数组

    使用比较底层的构造函数：
    ``ndarray(shape, dtype=float, buffer=None, offset=0,strides=None, order=None)``

    常用创建方式：
    
    -   Ones 和 Zeros 填充
    
        ================================================    ========================================================================
        empty(shape,[,dtype,order,like])                    返回一个指定形状和数据类型的未对其中数据初始化的新数组
        empty_like(prototype[,dtype,order,subok,...])       返回一个和给定数组同同形状、同数据类型的新数组
        eye(N[,M,k,dtype,order,like])                       返回一个二维对角数组，对角线上的数据为 1 ，其它为 0 
        identity(N[,dtype,like])                            返回一个单位矩阵，主对角线上的数据为 1 ，其它为 0 
        ones(shape[,dtype,order,like])                      返回一个指定形状和数据类型数据的新数组，填充数据 1
        ones_like(a[,dtype,order,subok,shape])              返回一个和给定数组同形状、同数据类型的数组，填充数据 1
        zeros(shape[,dtype,order,like])                     返回一个指定形状和数据类型数据的新数组，填充数据 0
        zeros_like(a[,dtype,order,subok,shape])             返回一个和给定数组同形状、同数据类型的数组，填充数据 0        
        full(shape,fill_value[,dtype,order,like])           返回一个指定形状和数据类型的新数组，填充数据 fill_value
        full_like(a,fill_value[,dtype,order,...])           返回一个和给定数组同形状、同数据类型的数组，填充数据 fill_value
        ================================================    ========================================================================
    
    -   使用已有数据

        ================================================    ========================================================================
        array(object[,dtype,copy,order,subok,...])          使用给定的数据创建数组
        asarray(a[,dtype,order,like])                       使用给定的数据创建数组
        asanyarray(a[,dtype,order,like])                    Convert the input to an ndarray, but pass ndarray subclasses through.
        ascontiguousarray(a[,dtype,like])                   Return a contiguous array (ndim >= 1) in memory (C order).
        asmatrix(data[,dtype])                              将输入数据翻译为矩阵，等效为 matrix(data,copy = False)
        copy(a[,order,subok])                               返回给定数组的副本，等效为 array(a,copy = True)
        frombuffer(buffer[,dtype,count,offset,like])        将给定缓冲区中的数据翻译为一维数组
        fromfile(file[,dtype,count,seq,offset,like])        从文本或二进制文件中的数据构造一个数组
        fromfunction(function,shape,*[,dtype,like])         通过在每个坐标上执行函数来构造数组，result[i][j] = func(i,j)
        fromiter(iter,dtype[,count,like])                   使用一个迭代器对象构建一个新的一维数组
        fromstring(string[,dtype,count,seq,like])           使用一个字符串数据构建一个新的一维数组
        loadtxt(fname[,dtype,comments,delimiter,...])       使用文件中的数据构建一个数组
        ================================================    ========================================================================


    -   创建记录数组（ numpy.rec ）
    
        ================================================    ========================================================================
        rec.array(obj[,dtype,shape,...])                    使用各种各样的对象构造一个记录数组
        rec.fromarrays(arrayList[,dtype,...])               Create a record array from a (flat) list of arrays
        rec.fromrecords(recList[,dtype,...])                使用文本数据中的记录创建一个记录数组
        rec.fromstring(datastring[,dtype,...])              使用二进制数据创建一个记录数组
        rec.fromfile(fd[,dtype,shape,...])                  使用文件中的二进制数据创建一个记录数组
        ================================================    ========================================================================

    -   创建字符数组（ numpy.char ）
    
        ================================================    ========================================================================
        char.array(obj[,itemsize,...])                      创建一个字符数组
        char.char.asarray(obj[,itemsize,...])               将数据转换为字符数组，仅在必要时复制数据
        ================================================    ========================================================================

    -   数值范围

        ================================================    ========================================================================
        arange([start,]stop[,step,][,dtype,like])           在给定的区间（[start,stop)）内均匀间隔的值
        linspace(start,stop[,num,endpoint,...])             在给定的区间（[start,stop]）内返回均匀间隔的指定数量的数据。
        logspace(start,stop[,num,endpoint,base,...])        返回在对数尺度上均匀间隔的数字
        geomspace(start,stop[,num,endpoint,...])            返回在对数尺度上均匀间隔的数字(几何级数)
        meshgrid(*xi[,copy,sparse, indexing])               从坐标向量返回坐标矩阵
        mgrid                                               nd_grid instance which returns a dense multi-dimensional “meshgrid”.
        ogrid                                               nd_grid instance which returns an open multi-dimensional “meshgrid”.
        ================================================    ========================================================================

    -   创建矩阵

        ================================================    ========================================================================
        diag(v[,K])                                         提取对角线或构造对角线数组
        diagflat(V[,K])                                     Create a two-dimensional array with the flattened input as a diagonal.
        tri(N[,M,k,dtype,like])                             在给定的对角线处和下面为 1，其他地方为 0 的数组
        tril(m[,K])                                         数组的下三角形
        triu(m[,K])                                         数组的上三角形
        vander(X[,N,increasing])                            生成范德蒙矩阵
        ================================================    ========================================================================

    -   矩阵类

        ================================================    ========================================================================
        mat(data[,dtype])                                   将输入数据解释为一个矩阵
        bmat(obj[,ldict,gdict])                             从字符串、嵌套序列或数组数据构建矩阵对象
        ================================================    ========================================================================

#.  索引数组

    可以使用扩展的 Python 切片语法对数组建立索引 ``array[selection]`` 。
    类似的语法也用于访问 **结构化数据类型** 中的字段。
    
#.  数组的内存布局
#.  数组的特性
#.  数组的方法
#.  算术、矩阵乘法和比较运算
#.  特殊方法

标量
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  内置的标量类型
#.  特性
#.  索引
#.  方法
#.  定义新类型


数据类型对象（ dtype ）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  指定并构建数据类型
#.  dtype

索引
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  基本的切片和索引
#.  高级索引
#.  详细说明
#.  字段访问
#.  Flat iterator 索引

数组遍历
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  Single Array Iteration
#.  Broadcasting Array Iteration
#.  Putting the Inner Loop in Cython

数组的标准子类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  特殊特性和方法
#.  矩阵对象
#.  内存映射文件数组
#.  字符数组（ numpy.char ）
#.  记录数组（ numpy.rec ）
#.  掩码数组（ numpy.ma ）
#.  标准容器类
#.  数组迭代器

掩码数组
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#.  numpy.ma 模块
#.  numpy.ma 的使用
#.  示例
#.  numpy.ma 模块的常量
#.  MaskArray 类
#.  MaskArray 类的方法
#.  掩码数组的操作


数组接口
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   Python side
-   C-struct access
-   Type description examples
-   Differences with Array interface (Version 2)

时间和时间差
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   基本的日期时间
-   Datetime 和 Timedelta 的相关运算
-   日期时间的单位
-   Business Day Functionality

常量
--------------------------------------------------------------------------------

NumPy 包含了一些常量：

-   ``numpy.inf`` ``numpy.Inf`` ``numpy.Infinity`` ``numpy.PINF`` ``numpy.infty``

    说明：(正）无穷大的 IEEE 754 浮点表示。
    
    类型：float 
    
    相关方法： ``numpy.isinf()`` ``numpy.isposinf()`` ``numpy.isneginf()``
    ``numpy.isnan()`` ``numpy.isfinite()``
    
-   ``numpy.NINF``

    说明：负无穷的 IEEE 754浮点表示。
    
    类型：float

-   ``numpy.nan`` ``numpy.NaN`` ``numpy.NAN``
    
    说明：非数字的浮点表示。

-   ``numpy.NZERO``

    说明：负零的 IEEE 754 浮点表示。
    
    类型：float

-   ``numpy.PZERO``

    说明：正零的 IEEE 754 浮点表示。
    
    类型：float

-   ``numpy.pi``

    说明：圆周率

-   ``numpy.e``

    说明：欧拉数，自然对数函数的底数，纳皮尔常数。
    
    相关方法：``numpy.exp()`` ``numpy.log()``
    
-   ``numpy.euler_gamma``

    说明： `Euler-Mascheroni_constant <https://en.wikipedia.org/wiki/Euler-Mascheroni_constant>`_

-   ``numpy.newaxis``

    说明： ``No​​ne`` 的别名，对索引数组很有用。
    

全局函数
--------------------------------------------------------------------------------